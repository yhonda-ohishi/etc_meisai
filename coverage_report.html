
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>adapters: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/yhonda-ohishi/etc_meisai/src/adapters/etc_compat_adapter.go (94.0%)</option>
				
				<option value="file1">github.com/yhonda-ohishi/etc_meisai/src/adapters/etc_mapping_converter.go (18.8%)</option>
				
				<option value="file2">github.com/yhonda-ohishi/etc_meisai/src/adapters/etc_record_converter.go (94.3%)</option>
				
				<option value="file3">github.com/yhonda-ohishi/etc_meisai/src/adapters/field_converter.go (88.0%)</option>
				
				<option value="file4">github.com/yhonda-ohishi/etc_meisai/src/adapters/import_session_converter.go (33.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package adapters

import (
        "fmt"
        "time"

        "github.com/yhonda-ohishi/etc_meisai/src/models"
        "github.com/yhonda-ohishi/etc_meisai/src/pb"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// ETCMeisaiCompatAdapter provides compatibility between new GORM model and legacy 38-field API
type ETCMeisaiCompatAdapter struct{}

// NewETCMeisaiCompatAdapter creates a new compatibility adapter
func NewETCMeisaiCompatAdapter() *ETCMeisaiCompatAdapter <span class="cov8" title="1">{
        return &amp;ETCMeisaiCompatAdapter{}
}</span>

// ToCompat converts GORM ETCMeisai to compatibility format
func (a *ETCMeisaiCompatAdapter) ToCompat(etc *models.ETCMeisai) *ETCMeisaiCompat <span class="cov8" title="1">{
        if etc == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">compat := &amp;ETCMeisaiCompat{
                // Core fields
                ID:        etc.ID,
                UseDate:   etc.UseDate,
                UseTime:   etc.UseTime,
                EntryIC:   etc.EntryIC,
                ExitIC:    etc.ExitIC,
                Amount:    etc.Amount,
                CarNumber: etc.CarNumber,
                ETCNumber: etc.ETCNumber,
                Hash:      etc.Hash,
                CreatedAt: etc.CreatedAt,
                UpdatedAt: etc.UpdatedAt,
        }

        // Legacy alias fields
        compat.ICEntry = &amp;etc.EntryIC
        compat.ICExit = &amp;etc.ExitIC
        usageDate := etc.UseDate.Format("2006-01-02")
        compat.UsageDate = &amp;usageDate
        compat.UsageTime = &amp;etc.UseTime
        compat.ETCCardNum = &amp;etc.ETCNumber
        compat.VehicleNum = &amp;etc.CarNumber
        compat.TollAmount = &amp;etc.Amount

        // Additional computed fields
        date := etc.UseDate.Format("2006-01-02")
        compat.Date = &amp;date
        time := etc.UseTime
        compat.Time = &amp;time

        // Default values for missing legacy fields
        defaultStr := ""
        defaultInt := int32(0)
        defaultFloat := float64(0)

        compat.TollGate = &amp;defaultStr
        compat.VehicleType = &amp;defaultStr
        compat.DiscountAmount = &amp;defaultInt
        compat.PaymentMethod = &amp;defaultStr
        compat.RouteCode = &amp;defaultStr
        compat.Distance = &amp;defaultFloat
        compat.Remarks = &amp;defaultStr
        compat.UsageType = &amp;defaultStr
        compat.AccountType = &amp;defaultStr
        compat.UnkoNo = &amp;defaultStr

        // Set some computed values
        totalAmount := etc.Amount
        compat.TotalAmount = &amp;totalAmount

        return compat</span>
}

// FromCompat converts compatibility format to GORM ETCMeisai
func (a *ETCMeisaiCompatAdapter) FromCompat(compat *ETCMeisaiCompat) *models.ETCMeisai <span class="cov8" title="1">{
        if compat == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">etc := &amp;models.ETCMeisai{
                ID:        compat.ID,
                UseDate:   compat.UseDate,
                UseTime:   compat.UseTime,
                EntryIC:   compat.EntryIC,
                ExitIC:    compat.ExitIC,
                Amount:    compat.Amount,
                CarNumber: compat.CarNumber,
                ETCNumber: compat.ETCNumber,
                Hash:      compat.Hash,
                CreatedAt: compat.CreatedAt,
                UpdatedAt: compat.UpdatedAt,
        }

        // Handle legacy field mappings
        if compat.ICEntry != nil </span><span class="cov8" title="1">{
                etc.EntryIC = *compat.ICEntry
        }</span>
        <span class="cov8" title="1">if compat.ICExit != nil </span><span class="cov8" title="1">{
                etc.ExitIC = *compat.ICExit
        }</span>
        <span class="cov8" title="1">if compat.UsageDate != nil </span><span class="cov8" title="1">{
                if parsed, err := time.Parse("2006-01-02", *compat.UsageDate); err == nil </span><span class="cov8" title="1">{
                        etc.UseDate = parsed
                }</span>
        }
        <span class="cov8" title="1">if compat.UsageTime != nil </span><span class="cov8" title="1">{
                etc.UseTime = *compat.UsageTime
        }</span>
        <span class="cov8" title="1">if compat.ETCCardNum != nil </span><span class="cov8" title="1">{
                etc.ETCNumber = *compat.ETCCardNum
        }</span>
        <span class="cov8" title="1">if compat.VehicleNum != nil </span><span class="cov8" title="1">{
                etc.CarNumber = *compat.VehicleNum
        }</span>
        <span class="cov8" title="1">if compat.TollAmount != nil </span><span class="cov8" title="1">{
                etc.Amount = *compat.TollAmount
        }</span>

        // Handle alternative date/time fields
        <span class="cov8" title="1">if compat.Date != nil &amp;&amp; etc.UseDate.IsZero() </span><span class="cov0" title="0">{
                if parsed, err := time.Parse("2006-01-02", *compat.Date); err == nil </span><span class="cov0" title="0">{
                        etc.UseDate = parsed
                }</span>
        }
        <span class="cov8" title="1">if compat.Time != nil &amp;&amp; etc.UseTime == "" </span><span class="cov0" title="0">{
                etc.UseTime = *compat.Time
        }</span>

        // Handle alternative amount fields
        <span class="cov8" title="1">if compat.TotalAmount != nil &amp;&amp; etc.Amount == 0 </span><span class="cov0" title="0">{
                etc.Amount = *compat.TotalAmount
        }</span>

        <span class="cov8" title="1">return etc</span>
}

// ToCompatList converts a slice of ETCMeisai to compatibility format
func (a *ETCMeisaiCompatAdapter) ToCompatList(etcList []*models.ETCMeisai) []*ETCMeisaiCompat <span class="cov8" title="1">{
        if etcList == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">compatList := make([]*ETCMeisaiCompat, len(etcList))
        for i, etc := range etcList </span><span class="cov8" title="1">{
                compatList[i] = a.ToCompat(etc)
        }</span>
        <span class="cov8" title="1">return compatList</span>
}

// FromCompatList converts a slice of compatibility format to ETCMeisai
func (a *ETCMeisaiCompatAdapter) FromCompatList(compatList []*ETCMeisaiCompat) []*models.ETCMeisai <span class="cov8" title="1">{
        if compatList == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">etcList := make([]*models.ETCMeisai, len(compatList))
        for i, compat := range compatList </span><span class="cov8" title="1">{
                etcList[i] = a.FromCompat(compat)
        }</span>
        <span class="cov8" title="1">return etcList</span>
}

// ETCMeisaiCompat provides compatibility with existing 38-field API
type ETCMeisaiCompat struct {
        // Core GORM fields
        ID        int64     `json:"id"`
        UseDate   time.Time `json:"use_date"`
        UseTime   string    `json:"use_time"`
        EntryIC   string    `json:"entry_ic"`
        ExitIC    string    `json:"exit_ic"`
        Amount    int32     `json:"amount"`
        CarNumber string    `json:"car_number"`
        ETCNumber string    `json:"etc_number"`
        Hash      string    `json:"hash"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`

        // Legacy alias fields (all pointers to allow omitempty)
        ICEntry        *string  `json:"ic_entry,omitempty"`
        ICExit         *string  `json:"ic_exit,omitempty"`
        Date           *string  `json:"date,omitempty"`
        Time           *string  `json:"time,omitempty"`
        UsageDate      *string  `json:"usage_date,omitempty"`
        UsageTime      *string  `json:"usage_time,omitempty"`
        ETCCardNum     *string  `json:"etc_card_num,omitempty"`
        ETCCardNumber  *string  `json:"etc_card_number,omitempty"`
        VehicleNum     *string  `json:"vehicle_num,omitempty"`
        VehicleNumber  *string  `json:"vehicle_number,omitempty"`
        VehicleNo      *string  `json:"vehicle_no,omitempty"`
        TollAmount     *int32   `json:"toll_amount,omitempty"`
        TotalAmount    *int32   `json:"total_amount,omitempty"`
        CardNo         *string  `json:"card_no,omitempty"`
        CardNumber     *string  `json:"card_number,omitempty"`
        ETCNum         *string  `json:"etc_num,omitempty"`

        // Additional legacy fields that may be needed
        TollGate       *string  `json:"toll_gate,omitempty"`
        VehicleType    *string  `json:"vehicle_type,omitempty"`
        DiscountAmount *int32   `json:"discount_amount,omitempty"`
        PaymentMethod  *string  `json:"payment_method,omitempty"`
        RouteCode      *string  `json:"route_code,omitempty"`
        Distance       *float64 `json:"distance,omitempty"`
        Remarks        *string  `json:"remarks,omitempty"`
        UsageType      *string  `json:"usage_type,omitempty"`
        AccountType    *string  `json:"account_type,omitempty"`
        UnkoNo         *string  `json:"unko_no,omitempty"`
        RowID          *int64   `json:"row_id,omitempty"`
        ImportedAt     *time.Time `json:"imported_at,omitempty"`

        // Runtime computed fields
        RouteType      *string `json:"route_type,omitempty"`
        DiscountType   *string `json:"discount_type,omitempty"`
        TransType      *string `json:"trans_type,omitempty"`
}

// GetActualAmount returns the actual amount from various possible fields
func (c *ETCMeisaiCompat) GetActualAmount() int32 <span class="cov8" title="1">{
        if c.Amount != 0 </span><span class="cov8" title="1">{
                return c.Amount
        }</span>
        <span class="cov8" title="1">if c.TollAmount != nil &amp;&amp; *c.TollAmount != 0 </span><span class="cov8" title="1">{
                return *c.TollAmount
        }</span>
        <span class="cov8" title="1">if c.TotalAmount != nil &amp;&amp; *c.TotalAmount != 0 </span><span class="cov8" title="1">{
                return *c.TotalAmount
        }</span>
        <span class="cov8" title="1">return 0</span>
}

// GetActualETCNumber returns the actual ETC number from various possible fields
func (c *ETCMeisaiCompat) GetActualETCNumber() string <span class="cov8" title="1">{
        if c.ETCNumber != "" </span><span class="cov8" title="1">{
                return c.ETCNumber
        }</span>
        <span class="cov8" title="1">if c.ETCCardNum != nil &amp;&amp; *c.ETCCardNum != "" </span><span class="cov8" title="1">{
                return *c.ETCCardNum
        }</span>
        <span class="cov8" title="1">if c.ETCCardNumber != nil &amp;&amp; *c.ETCCardNumber != "" </span><span class="cov8" title="1">{
                return *c.ETCCardNumber
        }</span>
        <span class="cov8" title="1">if c.ETCNum != nil &amp;&amp; *c.ETCNum != "" </span><span class="cov8" title="1">{
                return *c.ETCNum
        }</span>
        <span class="cov8" title="1">if c.CardNo != nil &amp;&amp; *c.CardNo != "" </span><span class="cov0" title="0">{
                return *c.CardNo
        }</span>
        <span class="cov8" title="1">if c.CardNumber != nil &amp;&amp; *c.CardNumber != "" </span><span class="cov0" title="0">{
                return *c.CardNumber
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// GetActualVehicleNumber returns the actual vehicle number from various possible fields
func (c *ETCMeisaiCompat) GetActualVehicleNumber() string <span class="cov8" title="1">{
        if c.CarNumber != "" </span><span class="cov8" title="1">{
                return c.CarNumber
        }</span>
        <span class="cov8" title="1">if c.VehicleNum != nil &amp;&amp; *c.VehicleNum != "" </span><span class="cov8" title="1">{
                return *c.VehicleNum
        }</span>
        <span class="cov8" title="1">if c.VehicleNumber != nil &amp;&amp; *c.VehicleNumber != "" </span><span class="cov8" title="1">{
                return *c.VehicleNumber
        }</span>
        <span class="cov8" title="1">if c.VehicleNo != nil &amp;&amp; *c.VehicleNo != "" </span><span class="cov0" title="0">{
                return *c.VehicleNo
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// GetActualEntryIC returns the actual entry IC from various possible fields
func (c *ETCMeisaiCompat) GetActualEntryIC() string <span class="cov8" title="1">{
        if c.EntryIC != "" </span><span class="cov8" title="1">{
                return c.EntryIC
        }</span>
        <span class="cov8" title="1">if c.ICEntry != nil &amp;&amp; *c.ICEntry != "" </span><span class="cov8" title="1">{
                return *c.ICEntry
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// GetActualExitIC returns the actual exit IC from various possible fields
func (c *ETCMeisaiCompat) GetActualExitIC() string <span class="cov8" title="1">{
        if c.ExitIC != "" </span><span class="cov8" title="1">{
                return c.ExitIC
        }</span>
        <span class="cov8" title="1">if c.ICExit != nil &amp;&amp; *c.ICExit != "" </span><span class="cov8" title="1">{
                return *c.ICExit
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// ConvertToStandardFormat normalizes a compatibility record to use standard fields
func (a *ETCMeisaiCompatAdapter) ConvertToStandardFormat(compat *ETCMeisaiCompat) *ETCMeisaiCompat <span class="cov8" title="1">{
        if compat == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Create a copy and normalize to standard fields
        <span class="cov8" title="1">normalized := *compat

        // Normalize amount
        normalized.Amount = compat.GetActualAmount()

        // Normalize ETC number
        normalized.ETCNumber = compat.GetActualETCNumber()

        // Normalize vehicle number
        normalized.CarNumber = compat.GetActualVehicleNumber()

        // Normalize IC fields
        normalized.EntryIC = compat.GetActualEntryIC()
        normalized.ExitIC = compat.GetActualExitIC()

        // Handle date fields
        if compat.Date != nil &amp;&amp; normalized.UseDate.IsZero() </span><span class="cov8" title="1">{
                if parsed, err := time.Parse("2006-01-02", *compat.Date); err == nil </span><span class="cov8" title="1">{
                        normalized.UseDate = parsed
                }</span>
        }
        <span class="cov8" title="1">if compat.UsageDate != nil &amp;&amp; normalized.UseDate.IsZero() </span><span class="cov8" title="1">{
                if parsed, err := time.Parse("2006-01-02", *compat.UsageDate); err == nil </span><span class="cov8" title="1">{
                        normalized.UseDate = parsed
                }</span>
        }

        // Handle time fields
        <span class="cov8" title="1">if compat.Time != nil &amp;&amp; normalized.UseTime == "" </span><span class="cov8" title="1">{
                normalized.UseTime = *compat.Time
        }</span>
        <span class="cov8" title="1">if compat.UsageTime != nil &amp;&amp; normalized.UseTime == "" </span><span class="cov8" title="1">{
                normalized.UseTime = *compat.UsageTime
        }</span>

        <span class="cov8" title="1">return &amp;normalized</span>
}

// ConvertToProto converts ETCMeisaiCompat to protobuf format
func (a *ETCMeisaiCompatAdapter) ConvertToProto(compat *ETCMeisaiCompat) (*pb.ETCMeisaiRecord, error) <span class="cov8" title="1">{
        if compat == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("compat cannot be nil")
        }</span>

        // Normalize the compatibility record first
        <span class="cov8" title="1">normalized := a.ConvertToStandardFormat(compat)
        if normalized == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to normalize compatibility record")
        }</span>

        <span class="cov8" title="1">proto := &amp;pb.ETCMeisaiRecord{
                Id:            normalized.ID,
                Hash:          normalized.Hash,
                Date:          normalized.UseDate.Format("2006-01-02"),
                Time:          normalized.UseTime,
                EntranceIc:    normalized.EntryIC,
                ExitIc:        normalized.ExitIC,
                TollAmount:    normalized.Amount,
                CarNumber:     normalized.CarNumber,
                EtcCardNumber: normalized.ETCNumber,
        }

        // Convert timestamps
        if !normalized.CreatedAt.IsZero() </span><span class="cov8" title="1">{
                proto.CreatedAt = timestamppb.New(normalized.CreatedAt)
        }</span>
        <span class="cov8" title="1">if !normalized.UpdatedAt.IsZero() </span><span class="cov8" title="1">{
                proto.UpdatedAt = timestamppb.New(normalized.UpdatedAt)
        }</span>

        <span class="cov8" title="1">return proto, nil</span>
}

// ConvertToProtoList converts a slice of ETCMeisaiCompat to protobuf format
func (a *ETCMeisaiCompatAdapter) ConvertToProtoList(compatList []*ETCMeisaiCompat) ([]*pb.ETCMeisaiRecord, error) <span class="cov8" title="1">{
        if compatList == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">protoList := make([]*pb.ETCMeisaiRecord, 0, len(compatList))
        for i, compat := range compatList </span><span class="cov8" title="1">{
                if compat == nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("compat at index %d cannot be nil", i)
                }</span>

                <span class="cov8" title="1">proto, err := a.ConvertToProto(compat)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error converting compat at index %d: %w", i, err)
                }</span>

                <span class="cov8" title="1">protoList = append(protoList, proto)</span>
        }

        <span class="cov8" title="1">return protoList, nil</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package adapters

import (
        "fmt"
        "strings"

        "github.com/yhonda-ohishi/etc_meisai/src/models"
        "github.com/yhonda-ohishi/etc_meisai/src/pb"
        "google.golang.org/protobuf/types/known/structpb"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// ETCMappingToProto converts a GORM model to a Proto message
func ETCMappingToProto(model *models.ETCMapping) (*pb.ETCMapping, error) <span class="cov8" title="1">{
        if model == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("model cannot be nil")
        }</span>

        <span class="cov8" title="1">proto := &amp;pb.ETCMapping{
                Id:               model.ID,
                EtcRecordId:      model.ETCRecordID,
                MappingType:      model.MappingType,
                MappedEntityId:   model.MappedEntityID,
                MappedEntityType: model.MappedEntityType,
                Confidence:       model.Confidence,
                CreatedBy:        model.CreatedBy,
        }

        // Convert status string to proto enum
        status, err := stringToMappingStatus(model.Status)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid mapping status: %w", err)
        }</span>
        <span class="cov8" title="1">proto.Status = status

        // Convert ETCRecord if present
        if model.ETCRecord.ID != 0 </span><span class="cov0" title="0">{
                etcRecord, err := ETCMeisaiRecordToProto(&amp;model.ETCRecord)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error converting ETC record: %w", err)
                }</span>
                <span class="cov0" title="0">proto.EtcRecord = etcRecord</span>
        }

        // Convert metadata JSON to protobuf Struct
        <span class="cov8" title="1">if model.Metadata != nil </span><span class="cov0" title="0">{
                metadata, err := model.GetMetadata()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error getting metadata: %w", err)
                }</span>
                <span class="cov0" title="0">if metadata != nil </span><span class="cov0" title="0">{
                        metadataStruct, err := structpb.NewStruct(metadata)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error converting metadata to struct: %w", err)
                        }</span>
                        <span class="cov0" title="0">proto.Metadata = metadataStruct</span>
                }
        }

        // Convert timestamps
        <span class="cov8" title="1">if !model.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                proto.CreatedAt = timestamppb.New(model.CreatedAt)
        }</span>
        <span class="cov8" title="1">if !model.UpdatedAt.IsZero() </span><span class="cov0" title="0">{
                proto.UpdatedAt = timestamppb.New(model.UpdatedAt)
        }</span>

        <span class="cov8" title="1">return proto, nil</span>
}

// ProtoToETCMapping converts a Proto message to a GORM model
func ProtoToETCMapping(proto *pb.ETCMapping) (*models.ETCMapping, error) <span class="cov0" title="0">{
        if proto == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("proto cannot be nil")
        }</span>

        <span class="cov0" title="0">model := &amp;models.ETCMapping{
                ID:               proto.Id,
                ETCRecordID:      proto.EtcRecordId,
                MappingType:      proto.MappingType,
                MappedEntityID:   proto.MappedEntityId,
                MappedEntityType: proto.MappedEntityType,
                Confidence:       proto.Confidence,
                CreatedBy:        proto.CreatedBy,
        }

        // Convert status enum to string
        model.Status = mappingStatusToString(proto.Status)

        // Convert ETCRecord if present
        if proto.EtcRecord != nil </span><span class="cov0" title="0">{
                etcRecord, err := ProtoToETCMeisaiRecord(proto.EtcRecord)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error converting ETC record: %w", err)
                }</span>
                <span class="cov0" title="0">model.ETCRecord = *etcRecord</span>
        }

        // Convert metadata Struct to JSON
        <span class="cov0" title="0">if proto.Metadata != nil </span><span class="cov0" title="0">{
                metadata := proto.Metadata.AsMap()
                if err := model.SetMetadata(metadata); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error setting metadata: %w", err)
                }</span>
        }

        // Convert timestamps
        <span class="cov0" title="0">if proto.CreatedAt != nil </span><span class="cov0" title="0">{
                if err := proto.CreatedAt.CheckValid(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid created_at timestamp: %w", err)
                }</span>
                <span class="cov0" title="0">model.CreatedAt = proto.CreatedAt.AsTime()</span>
        }
        <span class="cov0" title="0">if proto.UpdatedAt != nil </span><span class="cov0" title="0">{
                if err := proto.UpdatedAt.CheckValid(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid updated_at timestamp: %w", err)
                }</span>
                <span class="cov0" title="0">model.UpdatedAt = proto.UpdatedAt.AsTime()</span>
        }

        <span class="cov0" title="0">return model, nil</span>
}

// ETCMappingsToProto converts a slice of GORM models to a slice of Proto messages
func ETCMappingsToProto(models []*models.ETCMapping) ([]*pb.ETCMapping, error) <span class="cov0" title="0">{
        if models == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">protos := make([]*pb.ETCMapping, 0, len(models))
        for i, model := range models </span><span class="cov0" title="0">{
                if model == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("model at index %d cannot be nil", i)
                }</span>

                <span class="cov0" title="0">proto, err := ETCMappingToProto(model)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error converting model at index %d: %w", i, err)
                }</span>

                <span class="cov0" title="0">protos = append(protos, proto)</span>
        }

        <span class="cov0" title="0">return protos, nil</span>
}

// ProtoToETCMappings converts a slice of Proto messages to a slice of GORM models
func ProtoToETCMappings(protos []*pb.ETCMapping) ([]*models.ETCMapping, error) <span class="cov0" title="0">{
        if protos == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">models := make([]*models.ETCMapping, 0, len(protos))
        for i, proto := range protos </span><span class="cov0" title="0">{
                if proto == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("proto at index %d cannot be nil", i)
                }</span>

                <span class="cov0" title="0">model, err := ProtoToETCMapping(proto)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error converting proto at index %d: %w", i, err)
                }</span>

                <span class="cov0" title="0">models = append(models, model)</span>
        }

        <span class="cov0" title="0">return models, nil</span>
}

// stringToMappingStatus converts string status to proto enum
func stringToMappingStatus(status string) (pb.MappingStatus, error) <span class="cov8" title="1">{
        status = strings.ToLower(strings.TrimSpace(status))

        switch status </span>{
        case "active":<span class="cov8" title="1">
                return pb.MappingStatus_MAPPING_STATUS_ACTIVE, nil</span>
        case "inactive":<span class="cov0" title="0">
                return pb.MappingStatus_MAPPING_STATUS_INACTIVE, nil</span>
        case "pending":<span class="cov0" title="0">
                return pb.MappingStatus_MAPPING_STATUS_PENDING, nil</span>
        case "rejected":<span class="cov0" title="0">
                return pb.MappingStatus_MAPPING_STATUS_REJECTED, nil</span>
        case "":<span class="cov0" title="0">
                return pb.MappingStatus_MAPPING_STATUS_UNSPECIFIED, nil</span>
        default:<span class="cov8" title="1">
                return pb.MappingStatus_MAPPING_STATUS_UNSPECIFIED,
                        fmt.Errorf("unknown mapping status: %s", status)</span>
        }
}

// mappingStatusToString converts proto enum to string
func mappingStatusToString(status pb.MappingStatus) string <span class="cov0" title="0">{
        switch status </span>{
        case pb.MappingStatus_MAPPING_STATUS_ACTIVE:<span class="cov0" title="0">
                return "active"</span>
        case pb.MappingStatus_MAPPING_STATUS_INACTIVE:<span class="cov0" title="0">
                return "inactive"</span>
        case pb.MappingStatus_MAPPING_STATUS_PENDING:<span class="cov0" title="0">
                return "pending"</span>
        case pb.MappingStatus_MAPPING_STATUS_REJECTED:<span class="cov0" title="0">
                return "rejected"</span>
        case pb.MappingStatus_MAPPING_STATUS_UNSPECIFIED:<span class="cov0" title="0">
                return ""</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}</pre>
		
		<pre class="file" id="file2" style="display: none">package adapters

import (
        "fmt"
        "time"

        "github.com/yhonda-ohishi/etc_meisai/src/models"
        "github.com/yhonda-ohishi/etc_meisai/src/pb"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// ETCMeisaiRecordToProto converts a GORM model to a Proto message
func ETCMeisaiRecordToProto(model *models.ETCMeisaiRecord) (*pb.ETCMeisaiRecord, error) <span class="cov8" title="1">{
        if model == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("model cannot be nil")
        }</span>

        <span class="cov8" title="1">proto := &amp;pb.ETCMeisaiRecord{
                Id:            model.ID,
                Hash:          model.Hash,
                Date:          model.Date.Format("2006-01-02"), // YYYY-MM-DD format
                Time:          model.Time,
                EntranceIc:    model.EntranceIC,
                ExitIc:        model.ExitIC,
                TollAmount:    int32(model.TollAmount), // Convert int to int32
                CarNumber:     model.CarNumber,
                EtcCardNumber: model.ETCCardNumber,
        }

        // Handle optional ETCNum field
        if model.ETCNum != nil </span><span class="cov8" title="1">{
                proto.EtcNum = model.ETCNum
        }</span>

        // Handle optional DtakoRowID field
        <span class="cov8" title="1">if model.DtakoRowID != nil </span><span class="cov8" title="1">{
                proto.DtakoRowId = model.DtakoRowID
        }</span>

        // Convert timestamps
        <span class="cov8" title="1">if !model.CreatedAt.IsZero() </span><span class="cov8" title="1">{
                proto.CreatedAt = timestamppb.New(model.CreatedAt)
        }</span>
        <span class="cov8" title="1">if !model.UpdatedAt.IsZero() </span><span class="cov8" title="1">{
                proto.UpdatedAt = timestamppb.New(model.UpdatedAt)
        }</span>

        <span class="cov8" title="1">return proto, nil</span>
}

// ProtoToETCMeisaiRecord converts a Proto message to a GORM model
func ProtoToETCMeisaiRecord(proto *pb.ETCMeisaiRecord) (*models.ETCMeisaiRecord, error) <span class="cov8" title="1">{
        if proto == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("proto cannot be nil")
        }</span>

        // Parse date string to time.Time
        <span class="cov8" title="1">date, err := time.Parse("2006-01-02", proto.Date)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid date format: %w", err)
        }</span>

        <span class="cov8" title="1">model := &amp;models.ETCMeisaiRecord{
                ID:              proto.Id,
                Hash:            proto.Hash,
                Date:            date,
                Time:            proto.Time,
                EntranceIC:      proto.EntranceIc,
                ExitIC:          proto.ExitIc,
                TollAmount:      int(proto.TollAmount), // Convert int32 to int
                CarNumber:       proto.CarNumber,
                ETCCardNumber:   proto.EtcCardNumber,
        }

        // Handle optional ETCNum field
        if proto.EtcNum != nil </span><span class="cov8" title="1">{
                model.ETCNum = proto.EtcNum
        }</span>

        // Handle optional DtakoRowID field
        <span class="cov8" title="1">if proto.DtakoRowId != nil </span><span class="cov8" title="1">{
                model.DtakoRowID = proto.DtakoRowId
        }</span>

        // Convert timestamps
        <span class="cov8" title="1">if proto.CreatedAt != nil </span><span class="cov8" title="1">{
                if err := proto.CreatedAt.CheckValid(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid created_at timestamp: %w", err)
                }</span>
                <span class="cov8" title="1">model.CreatedAt = proto.CreatedAt.AsTime()</span>
        }
        <span class="cov8" title="1">if proto.UpdatedAt != nil </span><span class="cov8" title="1">{
                if err := proto.UpdatedAt.CheckValid(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid updated_at timestamp: %w", err)
                }</span>
                <span class="cov8" title="1">model.UpdatedAt = proto.UpdatedAt.AsTime()</span>
        }

        <span class="cov8" title="1">return model, nil</span>
}

// ETCMeisaiRecordsToProto converts a slice of GORM models to a slice of Proto messages
func ETCMeisaiRecordsToProto(models []*models.ETCMeisaiRecord) ([]*pb.ETCMeisaiRecord, error) <span class="cov8" title="1">{
        if models == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">protos := make([]*pb.ETCMeisaiRecord, 0, len(models))
        for i, model := range models </span><span class="cov8" title="1">{
                if model == nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("model at index %d cannot be nil", i)
                }</span>

                <span class="cov8" title="1">proto, err := ETCMeisaiRecordToProto(model)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error converting model at index %d: %w", i, err)
                }</span>

                <span class="cov8" title="1">protos = append(protos, proto)</span>
        }

        <span class="cov8" title="1">return protos, nil</span>
}

// ProtoToETCMeisaiRecords converts a slice of Proto messages to a slice of GORM models
func ProtoToETCMeisaiRecords(protos []*pb.ETCMeisaiRecord) ([]*models.ETCMeisaiRecord, error) <span class="cov8" title="1">{
        if protos == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">models := make([]*models.ETCMeisaiRecord, 0, len(protos))
        for i, proto := range protos </span><span class="cov8" title="1">{
                if proto == nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("proto at index %d cannot be nil", i)
                }</span>

                <span class="cov8" title="1">model, err := ProtoToETCMeisaiRecord(proto)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("error converting proto at index %d: %w", i, err)
                }</span>

                <span class="cov8" title="1">models = append(models, model)</span>
        }

        <span class="cov8" title="1">return models, nil</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package adapters

import (
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "time"
)

// FieldConverter provides utilities for converting between different field formats
type FieldConverter struct{}

// NewFieldConverter creates a new field converter
func NewFieldConverter() *FieldConverter <span class="cov8" title="1">{
        return &amp;FieldConverter{}
}</span>

// ConvertStringToInt32 safely converts string to int32
func (fc *FieldConverter) ConvertStringToInt32(s string) (int32, error) <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return 0, nil
        }</span>

        // Remove common formatting characters
        <span class="cov8" title="1">s = strings.ReplaceAll(s, ",", "")
        s = strings.ReplaceAll(s, "¥", "")
        s = strings.ReplaceAll(s, "円", "")
        s = strings.TrimSpace(s)

        i, err := strconv.ParseInt(s, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("cannot convert '%s' to int32: %w", s, err)
        }</span>

        <span class="cov8" title="1">return int32(i), nil</span>
}

// ConvertStringToFloat64 safely converts string to float64
func (fc *FieldConverter) ConvertStringToFloat64(s string) (float64, error) <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return 0, nil
        }</span>

        // Remove common formatting characters
        <span class="cov8" title="1">s = strings.ReplaceAll(s, ",", "")
        s = strings.TrimSpace(s)

        f, err := strconv.ParseFloat(s, 64)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("cannot convert '%s' to float64: %w", s, err)
        }</span>

        <span class="cov8" title="1">return f, nil</span>
}

// ConvertStringToTime converts string to time with multiple format attempts
func (fc *FieldConverter) ConvertStringToTime(s string) (time.Time, error) <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return time.Time{}, nil
        }</span>

        // Try multiple date formats commonly used in CSV files
        <span class="cov8" title="1">formats := []string{
                "2006-01-02",
                "2006/01/02",
                "01/02/2006",
                "02/01/2006",
                "2006-01-02 15:04:05",
                "2006/01/02 15:04:05",
                "01/02/2006 15:04:05",
                "2006年01月02日",
                "平成18年01月02日", // Handle Japanese era years if needed
        }

        for _, format := range formats </span><span class="cov8" title="1">{
                if t, err := time.Parse(format, s); err == nil </span><span class="cov8" title="1">{
                        return t, nil
                }</span>
        }

        <span class="cov8" title="1">return time.Time{}, fmt.Errorf("cannot parse time '%s' with any known format", s)</span>
}

// ConvertTimeToString converts time to standard string format
func (fc *FieldConverter) ConvertTimeToString(t time.Time, format string) string <span class="cov8" title="1">{
        if t.IsZero() </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">if format == "" </span><span class="cov8" title="1">{
                format = "2006-01-02"
        }</span>

        <span class="cov8" title="1">return t.Format(format)</span>
}

// NormalizeTimeString normalizes time string to HH:MM format
func (fc *FieldConverter) NormalizeTimeString(s string) (string, error) <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return "", nil
        }</span>

        // Remove common formatting
        <span class="cov8" title="1">s = strings.TrimSpace(s)
        s = strings.ReplaceAll(s, "：", ":")

        // Try to parse as time
        formats := []string{
                "15:04",
                "15:04:05",
                "3:04PM",
                "3:04:05PM",
                "15時04分",
        }

        for _, format := range formats </span><span class="cov8" title="1">{
                if t, err := time.Parse(format, s); err == nil </span><span class="cov8" title="1">{
                        return t.Format("15:04"), nil
                }</span>
        }

        // If no format matches, check if it's already in HH:MM format
        <span class="cov8" title="1">if matched := isValidTimeFormat(s); matched </span><span class="cov8" title="1">{
                return s, nil
        }</span>

        <span class="cov8" title="1">return "", fmt.Errorf("cannot normalize time string '%s'", s)</span>
}

// NormalizeICName normalizes IC (interchange) names
func (fc *FieldConverter) NormalizeICName(s string) string <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Trim whitespace
        <span class="cov8" title="1">s = strings.TrimSpace(s)

        // Normalize common suffixes
        suffixes := []string{"IC", "インター", "ｲﾝﾀｰ", "料金所"}
        for _, suffix := range suffixes </span><span class="cov8" title="1">{
                if strings.HasSuffix(s, suffix) &amp;&amp; !strings.HasSuffix(s, "IC") </span><span class="cov8" title="1">{
                        s = strings.TrimSuffix(s, suffix) + "IC"
                        break</span>
                }
        }

        // Ensure it ends with IC if it doesn't already
        <span class="cov8" title="1">if !strings.HasSuffix(s, "IC") &amp;&amp; s != "" </span><span class="cov8" title="1">{
                s += "IC"
        }</span>

        <span class="cov8" title="1">return s</span>
}

// NormalizeVehicleNumber normalizes vehicle numbers
func (fc *FieldConverter) NormalizeVehicleNumber(s string) string <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Trim whitespace
        <span class="cov8" title="1">s = strings.TrimSpace(s)

        // Convert full-width characters to half-width
        s = fc.convertFullWidthToHalfWidth(s)

        // Remove common prefixes/suffixes
        prefixes := []string{"車両番号", "車番", "No.", "No", "#"}
        for _, prefix := range prefixes </span><span class="cov8" title="1">{
                s = strings.TrimPrefix(s, prefix)
        }</span>

        <span class="cov8" title="1">s = strings.TrimSpace(s)

        return s</span>
}

// NormalizeETCNumber normalizes ETC card numbers
func (fc *FieldConverter) NormalizeETCNumber(s string) string <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Trim whitespace
        <span class="cov8" title="1">s = strings.TrimSpace(s)

        // Convert full-width to half-width
        s = fc.convertFullWidthToHalfWidth(s)

        // Remove non-numeric characters
        var result strings.Builder
        for _, r := range s </span><span class="cov8" title="1">{
                if r &gt;= '0' &amp;&amp; r &lt;= '9' </span><span class="cov8" title="1">{
                        result.WriteRune(r)
                }</span>
        }

        <span class="cov8" title="1">return result.String()</span>
}

// convertFullWidthToHalfWidth converts full-width characters to half-width
func (fc *FieldConverter) convertFullWidthToHalfWidth(s string) string <span class="cov8" title="1">{
        // Mapping of full-width to half-width characters
        fullToHalf := map[rune]rune{
                '０': '0', '１': '1', '２': '2', '３': '3', '４': '4',
                '５': '5', '６': '6', '７': '7', '８': '8', '９': '9',
                '－': '-', '：': ':', '／': '/',
        }

        var result strings.Builder
        for _, r := range s </span><span class="cov8" title="1">{
                if half, ok := fullToHalf[r]; ok </span><span class="cov8" title="1">{
                        result.WriteRune(half)
                }</span> else<span class="cov8" title="1"> {
                        result.WriteRune(r)
                }</span>
        }

        <span class="cov8" title="1">return result.String()</span>
}

// MapLegacyFields maps legacy field names to standard field names
func (fc *FieldConverter) MapLegacyFields(data map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        // Field mapping from legacy names to standard names
        fieldMap := map[string]string{
                // Date fields
                "date":        "use_date",
                "usage_date":  "use_date",
                "利用日":        "use_date",
                "使用日":        "use_date",

                // Time fields
                "time":        "use_time",
                "usage_time":  "use_time",
                "利用時間":       "use_time",
                "使用時間":       "use_time",

                // IC fields
                "ic_entry":    "entry_ic",
                "entry":       "entry_ic",
                "入口":         "entry_ic",
                "入口IC":       "entry_ic",
                "ic_exit":     "exit_ic",
                "exit":        "exit_ic",
                "出口":         "exit_ic",
                "出口IC":       "exit_ic",

                // Amount fields
                "toll_amount":   "amount",
                "total_amount":  "amount",
                "料金":          "amount",
                "通行料金":        "amount",

                // Vehicle fields
                "vehicle_num":     "car_number",
                "vehicle_number":  "car_number",
                "vehicle_no":      "car_number",
                "車両番号":          "car_number",
                "車番":            "car_number",

                // ETC number fields
                "etc_card_num":    "etc_number",
                "etc_card_number": "etc_number",
                "card_no":         "etc_number",
                "card_number":     "etc_number",
                "etc_num":         "etc_number",
                "ETCカード番号":       "etc_number",
        }

        result := make(map[string]interface{})

        // Copy all fields, mapping legacy names to standard names
        for key, value := range data </span><span class="cov8" title="1">{
                standardKey := key
                if mapped, ok := fieldMap[strings.ToLower(key)]; ok </span><span class="cov8" title="1">{
                        standardKey = mapped
                }</span>
                <span class="cov8" title="1">result[standardKey] = value</span>
        }

        <span class="cov8" title="1">return result</span>
}

// ConvertFieldValue converts a field value to the appropriate type
func (fc *FieldConverter) ConvertFieldValue(value interface{}, targetType string) (interface{}, error) <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">stringValue := fmt.Sprintf("%v", value)
        stringValue = strings.TrimSpace(stringValue)

        switch targetType </span>{
        case "int32":<span class="cov8" title="1">
                return fc.ConvertStringToInt32(stringValue)</span>
        case "int64":<span class="cov8" title="1">
                i, err := strconv.ParseInt(stringValue, 10, 64)
                return i, err</span>
        case "float64":<span class="cov8" title="1">
                return fc.ConvertStringToFloat64(stringValue)</span>
        case "time":<span class="cov8" title="1">
                return fc.ConvertStringToTime(stringValue)</span>
        case "string":<span class="cov8" title="1">
                return stringValue, nil</span>
        case "bool":<span class="cov8" title="1">
                b, err := strconv.ParseBool(stringValue)
                return b, err</span>
        default:<span class="cov8" title="1">
                return value, nil</span>
        }
}

// ValidateFieldType checks if a value can be converted to the target type
func (fc *FieldConverter) ValidateFieldType(value interface{}, targetType string) error <span class="cov8" title="1">{
        _, err := fc.ConvertFieldValue(value, targetType)
        return err
}</span>

// ConvertStructFields converts fields in a struct using reflection
func (fc *FieldConverter) ConvertStructFields(src interface{}, dst interface{}) error <span class="cov8" title="1">{
        srcVal := reflect.ValueOf(src)
        dstVal := reflect.ValueOf(dst)

        if srcVal.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                srcVal = srcVal.Elem()
        }</span>
        <span class="cov8" title="1">if dstVal.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                dstVal = dstVal.Elem()
        }</span>

        <span class="cov8" title="1">if !dstVal.CanSet() </span><span class="cov8" title="1">{
                return fmt.Errorf("destination struct is not settable")
        }</span>

        <span class="cov8" title="1">srcType := srcVal.Type()
        dstType := dstVal.Type()

        for i := 0; i &lt; srcType.NumField(); i++ </span><span class="cov8" title="1">{
                srcField := srcType.Field(i)
                srcFieldValue := srcVal.Field(i)

                // Find corresponding field in destination
                dstField, found := dstType.FieldByName(srcField.Name)
                if !found </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">dstFieldValue := dstVal.FieldByName(srcField.Name)
                if !dstFieldValue.CanSet() </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Convert value if types are different
                <span class="cov8" title="1">if srcField.Type != dstField.Type </span><span class="cov8" title="1">{
                        converted, err := fc.convertValue(srcFieldValue.Interface(), dstField.Type)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error converting field %s: %w", srcField.Name, err)
                        }</span>
                        <span class="cov8" title="1">dstFieldValue.Set(reflect.ValueOf(converted))</span>
                } else<span class="cov8" title="1"> {
                        dstFieldValue.Set(srcFieldValue)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// convertValue converts a value to the target type using reflection
func (fc *FieldConverter) convertValue(value interface{}, targetType reflect.Type) (interface{}, error) <span class="cov8" title="1">{
        if value == nil </span><span class="cov0" title="0">{
                return reflect.Zero(targetType).Interface(), nil
        }</span>

        <span class="cov8" title="1">sourceValue := reflect.ValueOf(value)
        if sourceValue.Type() == targetType </span><span class="cov0" title="0">{
                return value, nil
        }</span>

        // Handle string conversions
        <span class="cov8" title="1">if sourceValue.Kind() == reflect.String </span><span class="cov0" title="0">{
                stringVal := sourceValue.String()
                switch targetType.Kind() </span>{
                case reflect.Int32:<span class="cov0" title="0">
                        i, err := fc.ConvertStringToInt32(stringVal)
                        return i, err</span>
                case reflect.Int64:<span class="cov0" title="0">
                        i, err := strconv.ParseInt(stringVal, 10, 64)
                        return i, err</span>
                case reflect.Float64:<span class="cov0" title="0">
                        f, err := fc.ConvertStringToFloat64(stringVal)
                        return f, err</span>
                }
        }

        // Handle time conversions
        <span class="cov8" title="1">if targetType == reflect.TypeOf(time.Time{}) &amp;&amp; sourceValue.Kind() == reflect.String </span><span class="cov0" title="0">{
                t, err := fc.ConvertStringToTime(sourceValue.String())
                return t, err
        }</span>

        // Default: try direct conversion
        <span class="cov8" title="1">if sourceValue.Type().ConvertibleTo(targetType) </span><span class="cov8" title="1">{
                return sourceValue.Convert(targetType).Interface(), nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("cannot convert %v to %v", sourceValue.Type(), targetType)</span>
}

// isValidTimeFormat checks if time string is in HH:MM format (copied from validation.go)
func isValidTimeFormat(timeStr string) bool <span class="cov8" title="1">{
        // Simple regex check for HH:MM format
        if len(timeStr) != 5 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if timeStr[2] != ':' </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for i, r := range timeStr </span><span class="cov8" title="1">{
                if i == 2 </span><span class="cov8" title="1">{
                        continue</span> // skip the ':'
                }
                <span class="cov8" title="1">if r &lt; '0' || r &gt; '9' </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package adapters

import (
        "encoding/json"
        "fmt"
        "strings"

        "github.com/yhonda-ohishi/etc_meisai/src/models"
        "github.com/yhonda-ohishi/etc_meisai/src/pb"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// ImportSessionToProto converts a GORM model to a Proto message
func ImportSessionToProto(model *models.ImportSession) (*pb.ImportSession, error) <span class="cov8" title="1">{
        if model == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("model cannot be nil")
        }</span>

        <span class="cov8" title="1">proto := &amp;pb.ImportSession{
                Id:            model.ID,
                AccountType:   model.AccountType,
                AccountId:     model.AccountID,
                FileName:      model.FileName,
                FileSize:      model.FileSize,
                TotalRows:     int32(model.TotalRows),
                ProcessedRows: int32(model.ProcessedRows),
                SuccessRows:   int32(model.SuccessRows),
                ErrorRows:     int32(model.ErrorRows),
                DuplicateRows: int32(model.DuplicateRows),
                CreatedBy:     model.CreatedBy,
        }

        // Convert status string to proto enum
        status, err := stringToImportStatus(model.Status)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid import status: %w", err)
        }</span>
        <span class="cov8" title="1">proto.Status = status

        // Convert timestamps
        if !model.StartedAt.IsZero() </span><span class="cov8" title="1">{
                proto.StartedAt = timestamppb.New(model.StartedAt)
        }</span>
        <span class="cov8" title="1">if model.CompletedAt != nil &amp;&amp; !model.CompletedAt.IsZero() </span><span class="cov0" title="0">{
                proto.CompletedAt = timestamppb.New(*model.CompletedAt)
        }</span>
        <span class="cov8" title="1">if !model.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                proto.CreatedAt = timestamppb.New(model.CreatedAt)
        }</span>

        // Convert error log JSON array to protobuf ImportError slice
        <span class="cov8" title="1">if model.ErrorLog != nil </span><span class="cov0" title="0">{
                var errorLogArray []models.ImportError
                if err := json.Unmarshal([]byte(model.ErrorLog), &amp;errorLogArray); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error unmarshaling error log: %w", err)
                }</span>

                <span class="cov0" title="0">if len(errorLogArray) &gt; 0 </span><span class="cov0" title="0">{
                        protoErrors := make([]*pb.ImportError, 0, len(errorLogArray))
                        for _, modelError := range errorLogArray </span><span class="cov0" title="0">{
                                protoError := &amp;pb.ImportError{
                                        RowNumber:    int32(modelError.RowNumber),
                                        ErrorType:    modelError.ErrorType,
                                        ErrorMessage: modelError.ErrorMessage,
                                        RawData:      modelError.RawData,
                                }
                                protoErrors = append(protoErrors, protoError)
                        }</span>
                        <span class="cov0" title="0">proto.ErrorLog = protoErrors</span>
                }
        }

        <span class="cov8" title="1">return proto, nil</span>
}

// ProtoToImportSession converts a Proto message to a GORM model
func ProtoToImportSession(proto *pb.ImportSession) (*models.ImportSession, error) <span class="cov8" title="1">{
        if proto == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("proto cannot be nil")
        }</span>

        <span class="cov8" title="1">model := &amp;models.ImportSession{
                ID:            proto.Id,
                AccountType:   proto.AccountType,
                AccountID:     proto.AccountId,
                FileName:      proto.FileName,
                FileSize:      proto.FileSize,
                TotalRows:     int(proto.TotalRows),
                ProcessedRows: int(proto.ProcessedRows),
                SuccessRows:   int(proto.SuccessRows),
                ErrorRows:     int(proto.ErrorRows),
                DuplicateRows: int(proto.DuplicateRows),
                CreatedBy:     proto.CreatedBy,
        }

        // Convert status enum to string
        model.Status = importStatusToString(proto.Status)

        // Convert timestamps
        if proto.StartedAt != nil </span><span class="cov8" title="1">{
                if err := proto.StartedAt.CheckValid(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid started_at timestamp: %w", err)
                }</span>
                <span class="cov8" title="1">model.StartedAt = proto.StartedAt.AsTime()</span>
        }
        <span class="cov8" title="1">if proto.CompletedAt != nil </span><span class="cov0" title="0">{
                if err := proto.CompletedAt.CheckValid(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid completed_at timestamp: %w", err)
                }</span>
                <span class="cov0" title="0">completedAt := proto.CompletedAt.AsTime()
                model.CompletedAt = &amp;completedAt</span>
        }
        <span class="cov8" title="1">if proto.CreatedAt != nil </span><span class="cov0" title="0">{
                if err := proto.CreatedAt.CheckValid(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid created_at timestamp: %w", err)
                }</span>
                <span class="cov0" title="0">model.CreatedAt = proto.CreatedAt.AsTime()</span>
        }

        // Convert error log slice to JSON
        <span class="cov8" title="1">if len(proto.ErrorLog) &gt; 0 </span><span class="cov0" title="0">{
                modelErrors := make([]models.ImportError, 0, len(proto.ErrorLog))
                for _, protoError := range proto.ErrorLog </span><span class="cov0" title="0">{
                        modelError := models.ImportError{
                                RowNumber:    int(protoError.RowNumber),
                                ErrorType:    protoError.ErrorType,
                                ErrorMessage: protoError.ErrorMessage,
                                RawData:      protoError.RawData,
                        }
                        modelErrors = append(modelErrors, modelError)
                }</span>

                // Use the model's AddError method for each error to properly set ErrorLog
                <span class="cov0" title="0">for _, importError := range modelErrors </span><span class="cov0" title="0">{
                        if err := model.AddError(
                                importError.RowNumber,
                                importError.ErrorType,
                                importError.ErrorMessage,
                                importError.RawData,
                        ); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error adding import error: %w", err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return model, nil</span>
}

// ImportSessionsToProto converts a slice of GORM models to a slice of Proto messages
func ImportSessionsToProto(models []*models.ImportSession) ([]*pb.ImportSession, error) <span class="cov0" title="0">{
        if models == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">protos := make([]*pb.ImportSession, 0, len(models))
        for i, model := range models </span><span class="cov0" title="0">{
                if model == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("model at index %d cannot be nil", i)
                }</span>

                <span class="cov0" title="0">proto, err := ImportSessionToProto(model)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error converting model at index %d: %w", i, err)
                }</span>

                <span class="cov0" title="0">protos = append(protos, proto)</span>
        }

        <span class="cov0" title="0">return protos, nil</span>
}

// ProtoToImportSessions converts a slice of Proto messages to a slice of GORM models
func ProtoToImportSessions(protos []*pb.ImportSession) ([]*models.ImportSession, error) <span class="cov0" title="0">{
        if protos == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">models := make([]*models.ImportSession, 0, len(protos))
        for i, proto := range protos </span><span class="cov0" title="0">{
                if proto == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("proto at index %d cannot be nil", i)
                }</span>

                <span class="cov0" title="0">model, err := ProtoToImportSession(proto)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error converting proto at index %d: %w", i, err)
                }</span>

                <span class="cov0" title="0">models = append(models, model)</span>
        }

        <span class="cov0" title="0">return models, nil</span>
}

// stringToImportStatus converts string status to proto enum
func stringToImportStatus(status string) (pb.ImportStatus, error) <span class="cov8" title="1">{
        status = strings.ToLower(strings.TrimSpace(status))

        switch status </span>{
        case "pending":<span class="cov8" title="1">
                return pb.ImportStatus_IMPORT_STATUS_PENDING, nil</span>
        case "processing":<span class="cov0" title="0">
                return pb.ImportStatus_IMPORT_STATUS_PROCESSING, nil</span>
        case "completed":<span class="cov0" title="0">
                return pb.ImportStatus_IMPORT_STATUS_COMPLETED, nil</span>
        case "failed":<span class="cov0" title="0">
                return pb.ImportStatus_IMPORT_STATUS_FAILED, nil</span>
        case "cancelled":<span class="cov0" title="0">
                return pb.ImportStatus_IMPORT_STATUS_CANCELLED, nil</span>
        case "":<span class="cov0" title="0">
                return pb.ImportStatus_IMPORT_STATUS_UNSPECIFIED, nil</span>
        default:<span class="cov8" title="1">
                return pb.ImportStatus_IMPORT_STATUS_UNSPECIFIED,
                        fmt.Errorf("unknown import status: %s", status)</span>
        }
}

// importStatusToString converts proto enum to string
func importStatusToString(status pb.ImportStatus) string <span class="cov8" title="1">{
        switch status </span>{
        case pb.ImportStatus_IMPORT_STATUS_PENDING:<span class="cov8" title="1">
                return "pending"</span>
        case pb.ImportStatus_IMPORT_STATUS_PROCESSING:<span class="cov0" title="0">
                return "processing"</span>
        case pb.ImportStatus_IMPORT_STATUS_COMPLETED:<span class="cov0" title="0">
                return "completed"</span>
        case pb.ImportStatus_IMPORT_STATUS_FAILED:<span class="cov0" title="0">
                return "failed"</span>
        case pb.ImportStatus_IMPORT_STATUS_CANCELLED:<span class="cov0" title="0">
                return "cancelled"</span>
        case pb.ImportStatus_IMPORT_STATUS_UNSPECIFIED:<span class="cov0" title="0">
                return ""</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
