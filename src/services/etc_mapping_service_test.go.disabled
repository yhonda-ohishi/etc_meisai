package services_test

import (
	"context"
	"fmt"
	"log"
	"os"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/yhonda-ohishi/etc_meisai/src/models"
	"github.com/yhonda-ohishi/etc_meisai/src/repositories"
	"github.com/yhonda-ohishi/etc_meisai/src/services"
)

func TestNewETCMappingService(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name       string
		mappingRepo repositories.ETCMappingRepository
		recordRepo  repositories.ETCMeisaiRecordRepository
		logger      *log.Logger
	}{
		{
			name:        "with repositories and logger",
			mappingRepo: &repositories.MockETCMappingRepository{},
			recordRepo:  &repositories.MockETCMeisaiRecordRepository{},
			logger:      log.New(os.Stdout, "test", log.LstdFlags),
		},
		{
			name:        "with repositories, no logger",
			mappingRepo: &repositories.MockETCMappingRepository{},
			recordRepo:  &repositories.MockETCMeisaiRecordRepository{},
			logger:      nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			service := services.NewETCMappingService(tt.mappingRepo, tt.recordRepo, tt.logger)
			assert.NotNil(t, service, "Service should not be nil")
		})
	}
}

func TestETCMappingService_CreateMapping(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name        string
		params      *services.CreateMappingParams
		setupMock   func(*repositories.MockETCMappingRepository, *repositories.MockETCMeisaiRecordRepository)
		expectError bool
		errorMsg    string
	}{
		{
			name: "valid mapping",
			params: &services.CreateMappingParams{
				ETCRecordID:      1,
				MappingType:      "dtako",
				MappedEntityID:   100,
				MappedEntityType: "dtako_record",
				Confidence:       0.95,
				Status:           "active",
				CreatedBy:        "test_user",
			},
			setupMock: func(m *repositories.MockETCMappingRepository, r *repositories.MockETCMeisaiRecordRepository) {
				// Record exists check
				record := &models.ETCMeisaiRecord{ID: 1}
				r.On("GetByID", mock.Anything, int64(1)).Return(record, nil)

				// Create transaction mock
				txMock := &repositories.MockETCMappingRepository{}
				m.On("BeginTx", mock.Anything).Return(txMock, nil)
				txMock.On("GetActiveMapping", mock.Anything, int64(1)).Return(nil, fmt.Errorf("not found"))
				txMock.On("Create", mock.Anything, mock.Anything).Return(nil)
				txMock.On("CommitTx").Return(nil)
				txMock.On("RollbackTx").Return(nil).Maybe()
			},
			expectError: false,
		},
		{
			name: "active mapping already exists",
			params: &services.CreateMappingParams{
				ETCRecordID:      1,
				MappingType:      "dtako",
				MappedEntityID:   100,
				MappedEntityType: "dtako_record",
			},
			setupMock: func(m *repositories.MockETCMappingRepository, r *repositories.MockETCMeisaiRecordRepository) {
				record := &models.ETCMeisaiRecord{ID: 1}
				r.On("GetByID", mock.Anything, int64(1)).Return(record, nil)

				txMock := &repositories.MockETCMappingRepository{}
				m.On("BeginTx", mock.Anything).Return(txMock, nil)

				// Active mapping exists
				existingMapping := &models.ETCMapping{ID: 99}
				txMock.On("GetActiveMapping", mock.Anything, int64(1)).Return(existingMapping, nil)
				txMock.On("RollbackTx").Return(nil)
			},
			expectError: true,
			errorMsg:    "active mapping already exists",
		},
		{
			name: "ETC record not found",
			params: &services.CreateMappingParams{
				ETCRecordID:      999,
				MappingType:      "dtako",
				MappedEntityID:   100,
				MappedEntityType: "dtako_record",
			},
			setupMock: func(m *repositories.MockETCMappingRepository, r *repositories.MockETCMeisaiRecordRepository) {
				r.On("GetByID", mock.Anything, int64(999)).Return(nil, fmt.Errorf("record not found"))

				txMock := &repositories.MockETCMappingRepository{}
				m.On("BeginTx", mock.Anything).Return(txMock, nil)
				txMock.On("RollbackTx").Return(nil)
			},
			expectError: true,
			errorMsg:    "ETC record not found",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockMappingRepo := &repositories.MockETCMappingRepository{}
			mockRecordRepo := &repositories.MockETCMeisaiRecordRepository{}
			tt.setupMock(mockMappingRepo, mockRecordRepo)

			service := services.NewETCMappingService(mockMappingRepo, mockRecordRepo, nil)
			ctx := context.Background()

			mapping, err := service.CreateMapping(ctx, tt.params)

			if tt.expectError {
				assert.Error(t, err)
				if tt.errorMsg != "" {
					assert.Contains(t, err.Error(), tt.errorMsg)
				}
				assert.Nil(t, mapping)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, mapping)
			}

			mockMappingRepo.AssertExpectations(t)
			mockRecordRepo.AssertExpectations(t)
		})
	}
}

func TestETCMappingService_GetMapping(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name        string
		id          int64
		setupMock   func(*repositories.MockETCMappingRepository)
		expectError bool
		errorMsg    string
	}{
		{
			name: "valid ID",
			id:   1,
			setupMock: func(m *repositories.MockETCMappingRepository) {
				mapping := &models.ETCMapping{
					ID:               1,
					ETCRecordID:      1,
					MappingType:      "dtako",
					MappedEntityID:   100,
					MappedEntityType: "dtako_record",
					Confidence:       0.95,
					Status:           "active",
				}
				m.On("GetByID", mock.Anything, int64(1)).Return(mapping, nil)
			},
			expectError: false,
		},
		{
			name: "invalid ID - zero",
			id:   0,
			setupMock: func(m *repositories.MockETCMappingRepository) {
				// No mock needed - validation fails before repository call
			},
			expectError: true,
			errorMsg:    "invalid mapping ID",
		},
		{
			name: "invalid ID - negative",
			id:   -1,
			setupMock: func(m *repositories.MockETCMappingRepository) {
				// No mock needed - validation fails before repository call
			},
			expectError: true,
			errorMsg:    "invalid mapping ID",
		},
		{
			name: "mapping not found",
			id:   999,
			setupMock: func(m *repositories.MockETCMappingRepository) {
				m.On("GetByID", mock.Anything, int64(999)).Return(nil, fmt.Errorf("mapping not found"))
			},
			expectError: true,
			errorMsg:    "failed to retrieve mapping",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockRepo := &repositories.MockETCMappingRepository{}
			tt.setupMock(mockRepo)

			service := services.NewETCMappingService(mockRepo, nil, nil)
			ctx := context.Background()

			mapping, err := service.GetMapping(ctx, tt.id)

			if tt.expectError {
				assert.Error(t, err)
				if tt.errorMsg != "" {
					assert.Contains(t, err.Error(), tt.errorMsg)
				}
				assert.Nil(t, mapping)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, mapping)
			}

			mockRepo.AssertExpectations(t)
		})
	}
}

func TestETCMappingService_UpdateStatus(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name        string
		id          int64
		status      string
		setupMock   func(*repositories.MockETCMappingRepository)
		expectError bool
		errorMsg    string
	}{
		{
			name:   "valid status update",
			id:     1,
			status: "inactive",
			setupMock: func(m *repositories.MockETCMappingRepository) {
				m.On("UpdateStatus", mock.Anything, int64(1), "inactive").Return(nil)
			},
			expectError: false,
		},
		{
			name:   "invalid ID",
			id:     0,
			status: "inactive",
			setupMock: func(m *repositories.MockETCMappingRepository) {
				// No mock needed - validation fails before repository call
			},
			expectError: true,
			errorMsg:    "invalid mapping ID",
		},
		{
			name:   "update failed",
			id:     1,
			status: "invalid_status",
			setupMock: func(m *repositories.MockETCMappingRepository) {
				m.On("UpdateStatus", mock.Anything, int64(1), "invalid_status").Return(fmt.Errorf("invalid status"))
			},
			expectError: true,
			errorMsg:    "failed to update mapping status",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockRepo := &repositories.MockETCMappingRepository{}
			tt.setupMock(mockRepo)

			service := services.NewETCMappingService(mockRepo, nil, nil)
			ctx := context.Background()

			err := service.UpdateStatus(ctx, tt.id, tt.status)

			if tt.expectError {
				assert.Error(t, err)
				if tt.errorMsg != "" {
					assert.Contains(t, err.Error(), tt.errorMsg)
				}
			} else {
				assert.NoError(t, err)
			}

			mockRepo.AssertExpectations(t)
		})
	}
}

func TestETCMappingService_HealthCheck(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name        string
		setupMock   func(*repositories.MockETCMappingRepository, *repositories.MockETCMeisaiRecordRepository)
		expectError bool
		errorMsg    string
	}{
		{
			name: "healthy repositories",
			setupMock: func(m *repositories.MockETCMappingRepository, r *repositories.MockETCMeisaiRecordRepository) {
				m.On("Ping", mock.Anything).Return(nil)
				r.On("Ping", mock.Anything).Return(nil)
			},
			expectError: false,
		},
		{
			name: "unhealthy mapping repository",
			setupMock: func(m *repositories.MockETCMappingRepository, r *repositories.MockETCMeisaiRecordRepository) {
				m.On("Ping", mock.Anything).Return(fmt.Errorf("connection failed"))
			},
			expectError: true,
			errorMsg:    "mapping repository ping failed",
		},
		{
			name: "unhealthy record repository",
			setupMock: func(m *repositories.MockETCMappingRepository, r *repositories.MockETCMeisaiRecordRepository) {
				m.On("Ping", mock.Anything).Return(nil)
				r.On("Ping", mock.Anything).Return(fmt.Errorf("connection failed"))
			},
			expectError: true,
			errorMsg:    "record repository ping failed",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockMappingRepo := &repositories.MockETCMappingRepository{}
			mockRecordRepo := &repositories.MockETCMeisaiRecordRepository{}
			tt.setupMock(mockMappingRepo, mockRecordRepo)

			service := services.NewETCMappingService(mockMappingRepo, mockRecordRepo, nil)
			ctx := context.Background()

			err := service.HealthCheck(ctx)

			if tt.expectError {
				assert.Error(t, err)
				if tt.errorMsg != "" {
					assert.Contains(t, err.Error(), tt.errorMsg)
				}
			} else {
				assert.NoError(t, err)
			}

			mockMappingRepo.AssertExpectations(t)
			mockRecordRepo.AssertExpectations(t)
		})
	}
}

// Helper functions
func mappingStringPtr(s string) *string {
	return &s
}

func mappingFloat32Ptr(f float32) *float32 {
	return &f
}