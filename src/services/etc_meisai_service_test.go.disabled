package services_test

import (
	"context"
	"fmt"
	"log"
	"os"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/yhonda-ohishi/etc_meisai/src/models"
	"github.com/yhonda-ohishi/etc_meisai/src/repositories"
	"github.com/yhonda-ohishi/etc_meisai/src/services"
)

func TestNewETCMeisaiService(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name   string
		repo   repositories.ETCMeisaiRecordRepository
		logger *log.Logger
	}{
		{
			name:   "with repository and logger",
			repo:   &repositories.MockETCMeisaiRecordRepository{},
			logger: log.New(os.Stdout, "test", log.LstdFlags),
		},
		{
			name:   "with repository, no logger",
			repo:   &repositories.MockETCMeisaiRecordRepository{},
			logger: nil,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			service := services.NewETCMeisaiService(tt.repo, tt.logger)
			assert.NotNil(t, service, "Service should not be nil")
		})
	}
}

func TestETCMeisaiService_CreateRecord(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name        string
		params      *services.CreateRecordParams
		setupMock   func(*repositories.MockETCMeisaiRecordRepository)
		expectError bool
		errorMsg    string
	}{
		{
			name: "valid record",
			params: &services.CreateRecordParams{
				Date:          time.Date(2024, 1, 15, 0, 0, 0, 0, time.UTC),
				Time:          "10:30:00",
				EntranceIC:    "羽田空港IC",
				ExitIC:        "新宿IC",
				TollAmount:    1200,
				CarNumber:     "あ123",
				ETCCardNumber: "1234567890123456",
				ETCNum:        etcStringPtr("ETC123"),
				DtakoRowID:    etcInt64Ptr(100),
			},
			setupMock: func(m *repositories.MockETCMeisaiRecordRepository) {
				// Create transaction mock
				txMock := &repositories.MockETCMeisaiRecordRepository{}
				m.On("BeginTx", mock.Anything).Return(txMock, nil)
				txMock.On("CheckDuplicateHash", mock.Anything, mock.Anything).Return(false, nil)
				txMock.On("Create", mock.Anything, mock.Anything).Return(nil)
				txMock.On("CommitTx").Return(nil)
				txMock.On("RollbackTx").Return(nil).Maybe() // In case of panic
			},
			expectError: false,
		},
		{
			name: "duplicate hash",
			params: &services.CreateRecordParams{
				Date:          time.Date(2024, 1, 15, 0, 0, 0, 0, time.UTC),
				Time:          "10:30:00",
				EntranceIC:    "羽田空港IC",
				ExitIC:        "新宿IC",
				TollAmount:    1200,
				CarNumber:     "あ123",
				ETCCardNumber: "1234567890123456",
			},
			setupMock: func(m *repositories.MockETCMeisaiRecordRepository) {
				txMock := &repositories.MockETCMeisaiRecordRepository{}
				m.On("BeginTx", mock.Anything).Return(txMock, nil)
				txMock.On("CheckDuplicateHash", mock.Anything, mock.Anything).Return(true, nil)
				txMock.On("RollbackTx").Return(nil)
			},
			expectError: true,
			errorMsg:    "duplicate record with hash",
		},
		{
			name: "invalid time format",
			params: &services.CreateRecordParams{
				Date:          time.Date(2024, 1, 15, 0, 0, 0, 0, time.UTC),
				Time:          "25:30:00", // Invalid hour
				EntranceIC:    "羽田空港IC",
				ExitIC:        "新宿IC",
				TollAmount:    1200,
				CarNumber:     "あ123",
				ETCCardNumber: "1234567890123456",
			},
			setupMock:   func(m *repositories.MockETCMeisaiRecordRepository) {},
			expectError: true,
			errorMsg:    "time must be in HH:MM:SS format",
		},
		{
			name: "future date",
			params: &services.CreateRecordParams{
				Date:          time.Now().Add(24 * time.Hour), // Future date
				Time:          "10:30:00",
				EntranceIC:    "羽田空港IC",
				ExitIC:        "新宿IC",
				TollAmount:    1200,
				CarNumber:     "あ123",
				ETCCardNumber: "1234567890123456",
			},
			setupMock:   func(m *repositories.MockETCMeisaiRecordRepository) {},
			expectError: true,
			errorMsg:    "date cannot be in the future",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockRepo := &repositories.MockETCMeisaiRecordRepository{}
			tt.setupMock(mockRepo)

			service := services.NewETCMeisaiService(mockRepo, nil)
			ctx := context.Background()

			record, err := service.CreateRecord(ctx, tt.params)

			if tt.expectError {
				assert.Error(t, err)
				if tt.errorMsg != "" {
					assert.Contains(t, err.Error(), tt.errorMsg)
				}
				assert.Nil(t, record)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, record)
			}

			mockRepo.AssertExpectations(t)
		})
	}
}

func TestETCMeisaiService_GetRecord(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name        string
		id          int64
		setupMock   func(*repositories.MockETCMeisaiRecordRepository)
		expectError bool
		errorMsg    string
	}{
		{
			name: "valid ID",
			id:   1,
			setupMock: func(m *repositories.MockETCMeisaiRecordRepository) {
				record := &models.ETCMeisaiRecord{
					ID:            1,
					Hash:          "test-hash",
					Date:          time.Date(2024, 1, 15, 0, 0, 0, 0, time.UTC),
					Time:          "10:30:00",
					EntranceIC:    "羽田空港IC",
					ExitIC:        "新宿IC",
					TollAmount:    1200,
					CarNumber:     "あ123",
					ETCCardNumber: "1234567890123456",
				}
				m.On("GetByID", mock.Anything, int64(1)).Return(record, nil)
			},
			expectError: false,
		},
		{
			name: "invalid ID - zero",
			id:   0,
			setupMock: func(m *repositories.MockETCMeisaiRecordRepository) {
				// No mock needed - validation fails before repository call
			},
			expectError: true,
			errorMsg:    "invalid record ID",
		},
		{
			name: "invalid ID - negative",
			id:   -1,
			setupMock: func(m *repositories.MockETCMeisaiRecordRepository) {
				// No mock needed - validation fails before repository call
			},
			expectError: true,
			errorMsg:    "invalid record ID",
		},
		{
			name: "record not found",
			id:   999,
			setupMock: func(m *repositories.MockETCMeisaiRecordRepository) {
				m.On("GetByID", mock.Anything, int64(999)).Return(nil, fmt.Errorf("record not found"))
			},
			expectError: true,
			errorMsg:    "failed to retrieve record",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockRepo := &repositories.MockETCMeisaiRecordRepository{}
			tt.setupMock(mockRepo)

			service := services.NewETCMeisaiService(mockRepo, nil)
			ctx := context.Background()

			record, err := service.GetRecord(ctx, tt.id)

			if tt.expectError {
				assert.Error(t, err)
				if tt.errorMsg != "" {
					assert.Contains(t, err.Error(), tt.errorMsg)
				}
				assert.Nil(t, record)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, record)
			}

			mockRepo.AssertExpectations(t)
		})
	}
}

func TestETCMeisaiService_ListRecords(t *testing.T) {
	t.Parallel()

	dateFrom := time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)
	dateTo := time.Date(2024, 1, 31, 0, 0, 0, 0, time.UTC)
	carNumber := "あ123"

	tests := []struct {
		name        string
		params      *services.ListRecordsParams
		setupMock   func(*repositories.MockETCMeisaiRecordRepository)
		expectError bool
	}{
		{
			name: "default parameters",
			params: &services.ListRecordsParams{},
			setupMock: func(m *repositories.MockETCMeisaiRecordRepository) {
				expectedParams := repositories.ListRecordsParams{
					Page:      1,
					PageSize:  50,
					SortBy:    "date",
					SortOrder: "desc",
				}
				m.On("List", mock.Anything, expectedParams).Return([]*models.ETCMeisaiRecord{}, int64(0), nil)
			},
			expectError: false,
		},
		{
			name: "with filters",
			params: &services.ListRecordsParams{
				Page:      2,
				PageSize:  20,
				DateFrom:  &dateFrom,
				DateTo:    &dateTo,
				CarNumber: &carNumber,
				SortBy:    "toll_amount",
				SortOrder: "asc",
			},
			setupMock: func(m *repositories.MockETCMeisaiRecordRepository) {
				expectedParams := repositories.ListRecordsParams{
					Page:      2,
					PageSize:  20,
					DateFrom:  &dateFrom,
					DateTo:    &dateTo,
					CarNumber: &carNumber,
					SortBy:    "toll_amount",
					SortOrder: "asc",
				}
				records := []*models.ETCMeisaiRecord{
					{ID: 1, TollAmount: 1200},
					{ID: 2, TollAmount: 1500},
				}
				m.On("List", mock.Anything, expectedParams).Return(records, int64(10), nil)
			},
			expectError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockRepo := &repositories.MockETCMeisaiRecordRepository{}
			tt.setupMock(mockRepo)

			service := services.NewETCMeisaiService(mockRepo, nil)
			ctx := context.Background()

			response, err := service.ListRecords(ctx, tt.params)

			if tt.expectError {
				assert.Error(t, err)
				assert.Nil(t, response)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, response)
			}

			mockRepo.AssertExpectations(t)
		})
	}
}

func TestETCMeisaiService_HealthCheck(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name        string
		setupMock   func(*repositories.MockETCMeisaiRecordRepository)
		expectError bool
		errorMsg    string
	}{
		{
			name: "healthy repository",
			setupMock: func(m *repositories.MockETCMeisaiRecordRepository) {
				m.On("Ping", mock.Anything).Return(nil)
			},
			expectError: false,
		},
		{
			name: "unhealthy repository",
			setupMock: func(m *repositories.MockETCMeisaiRecordRepository) {
				m.On("Ping", mock.Anything).Return(fmt.Errorf("connection failed"))
			},
			expectError: true,
			errorMsg:    "repository ping failed",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockRepo := &repositories.MockETCMeisaiRecordRepository{}
			tt.setupMock(mockRepo)

			service := services.NewETCMeisaiService(mockRepo, nil)
			ctx := context.Background()

			err := service.HealthCheck(ctx)

			if tt.expectError {
				assert.Error(t, err)
				if tt.errorMsg != "" {
					assert.Contains(t, err.Error(), tt.errorMsg)
				}
			} else {
				assert.NoError(t, err)
			}

			mockRepo.AssertExpectations(t)
		})
	}
}

// Helper functions
func etcStringPtr(s string) *string {
	return &s
}

func etcInt64Ptr(i int64) *int64 {
	return &i
}

// Benchmarks
func BenchmarkETCMeisaiService_CreateRecord(b *testing.B) {
	b.Skip("ETCMeisaiService has been refactored to use repository pattern")
}

func BenchmarkETCMeisaiService_GetRecord(b *testing.B) {
	b.Skip("ETCMeisaiService has been refactored to use repository pattern")
}

func BenchmarkETCMeisaiService_ListRecords(b *testing.B) {
	b.Skip("ETCMeisaiService has been refactored to use repository pattern")
}