package services_test

import (
	"errors"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/yhonda-ohishi/etc_meisai/src/services"
)

func TestNewLoggingService(t *testing.T) {
	t.Parallel()

	// Create a temporary directory for testing
	tempDir := t.TempDir()
	originalDir, _ := os.Getwd()
	defer os.Chdir(originalDir)
	os.Chdir(tempDir)

	tests := []struct {
		name        string
		serviceName string
		logLevel    services.LogLevel
		expectError bool
	}{
		{
			name:        "valid service creation",
			serviceName: "test_service",
			logLevel:    services.LogLevelInfo,
			expectError: false,
		},
		{
			name:        "debug level service",
			serviceName: "debug_service",
			logLevel:    services.LogLevelDebug,
			expectError: false,
		},
		{
			name:        "error level service",
			serviceName: "error_service",
			logLevel:    services.LogLevelError,
			expectError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			loggingService, err := services.NewLoggingService(tt.serviceName, tt.logLevel)

			if tt.expectError {
				assert.Error(t, err)
				assert.Nil(t, loggingService)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, loggingService)

				// Clean up
				if loggingService != nil {
					loggingService.Close()
				}

				// Verify log file was created
				logDir := "./logs"
				logFileName := tt.serviceName + "_" + time.Now().Format("2006-01-02") + ".log"
				logPath := filepath.Join(logDir, logFileName)
				_, err := os.Stat(logPath)
				assert.NoError(t, err, "Log file should be created")
			}
		})
	}
}

func TestLoggingService_ShouldLog(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name        string
		serviceLevel services.LogLevel
		messageLevel services.LogLevel
		shouldLog   bool
	}{
		{
			name:        "debug service logs debug",
			serviceLevel: services.LogLevelDebug,
			messageLevel: services.LogLevelDebug,
			shouldLog:   true,
		},
		{
			name:        "debug service logs info",
			serviceLevel: services.LogLevelDebug,
			messageLevel: services.LogLevelInfo,
			shouldLog:   true,
		},
		{
			name:        "info service skips debug",
			serviceLevel: services.LogLevelInfo,
			messageLevel: services.LogLevelDebug,
			shouldLog:   false,
		},
		{
			name:        "info service logs info",
			serviceLevel: services.LogLevelInfo,
			messageLevel: services.LogLevelInfo,
			shouldLog:   true,
		},
		{
			name:        "info service logs warn",
			serviceLevel: services.LogLevelInfo,
			messageLevel: services.LogLevelWarn,
			shouldLog:   true,
		},
		{
			name:        "error service skips info",
			serviceLevel: services.LogLevelError,
			messageLevel: services.LogLevelInfo,
			shouldLog:   false,
		},
		{
			name:        "error service logs error",
			serviceLevel: services.LogLevelError,
			messageLevel: services.LogLevelError,
			shouldLog:   true,
		},
		{
			name:        "any service logs fatal",
			serviceLevel: services.LogLevelWarn,
			messageLevel: services.LogLevelFatal,
			shouldLog:   true,
		},
	}

	tempDir := t.TempDir()
	originalDir, _ := os.Getwd()
	defer os.Chdir(originalDir)
	os.Chdir(tempDir)

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			loggingService, err := services.NewLoggingService("test", tt.serviceLevel)
			assert.NoError(t, err)
			defer loggingService.Close()

			// Test the shouldLog logic by checking log level filtering
			// We can't directly access shouldLog method, but we can test the behavior
			// by examining the level mapping logic

			levelMap := map[services.LogLevel]int{
				services.LogLevelDebug: 0,
				services.LogLevelInfo:  1,
				services.LogLevelWarn:  2,
				services.LogLevelError: 3,
				services.LogLevelFatal: 4,
			}

			shouldLog := levelMap[tt.messageLevel] >= levelMap[tt.serviceLevel]
			assert.Equal(t, tt.shouldLog, shouldLog)
		})
	}
}

func TestLoggingService_Metrics(t *testing.T) {
	t.Parallel()

	tempDir := t.TempDir()
	originalDir, _ := os.Getwd()
	defer os.Chdir(originalDir)
	os.Chdir(tempDir)

	loggingService, err := services.NewLoggingService("metrics_test", services.LogLevelDebug)
	assert.NoError(t, err)
	defer loggingService.Close()

	// Initial metrics should be zero
	metrics := loggingService.GetMetrics()
	assert.Equal(t, int64(0), metrics.TotalLogs)
	assert.Equal(t, int64(0), metrics.DebugCount)
	assert.Equal(t, int64(0), metrics.InfoCount)
	assert.Equal(t, int64(0), metrics.WarnCount)
	assert.Equal(t, int64(0), metrics.ErrorCount)

	// Log some messages
	loggingService.Debug("debug message", nil)
	loggingService.Info("info message", nil)
	loggingService.Warn("warning message", nil)
	loggingService.Error("error message", errors.New("test error"), nil)

	// Check updated metrics
	metrics = loggingService.GetMetrics()
	assert.Equal(t, int64(4), metrics.TotalLogs)
	assert.Equal(t, int64(1), metrics.DebugCount)
	assert.Equal(t, int64(1), metrics.InfoCount)
	assert.Equal(t, int64(1), metrics.WarnCount)
	assert.Equal(t, int64(1), metrics.ErrorCount)
	assert.False(t, metrics.LastLogTime.IsZero())
}

func TestLoggingService_SetLevel(t *testing.T) {
	t.Parallel()

	tempDir := t.TempDir()
	originalDir, _ := os.Getwd()
	defer os.Chdir(originalDir)
	os.Chdir(tempDir)

	loggingService, err := services.NewLoggingService("level_test", services.LogLevelInfo)
	assert.NoError(t, err)
	defer loggingService.Close()

	// Log a debug message (should be ignored)
	loggingService.Debug("debug message", nil)
	metrics := loggingService.GetMetrics()
	assert.Equal(t, int64(0), metrics.TotalLogs)

	// Change level to debug
	loggingService.SetLevel(services.LogLevelDebug)

	// Now debug message should be logged
	loggingService.Debug("debug message", nil)
	metrics = loggingService.GetMetrics()
	assert.Equal(t, int64(1), metrics.TotalLogs)
	assert.Equal(t, int64(1), metrics.DebugCount)
}

func TestLoggingService_LogHTTPRequest(t *testing.T) {
	t.Parallel()

	tempDir := t.TempDir()
	originalDir, _ := os.Getwd()
	defer os.Chdir(originalDir)
	os.Chdir(tempDir)

	loggingService, err := services.NewLoggingService("http_test", services.LogLevelInfo)
	assert.NoError(t, err)
	defer loggingService.Close()

	tests := []struct {
		name           string
		method         string
		path           string
		statusCode     int
		expectedLevel  services.LogLevel
		expectedMetric string
	}{
		{
			name:           "successful request",
			method:         "GET",
			path:           "/api/users",
			statusCode:     200,
			expectedLevel:  services.LogLevelInfo,
			expectedMetric: "info",
		},
		{
			name:           "client error",
			method:         "POST",
			path:           "/api/login",
			statusCode:     401,
			expectedLevel:  services.LogLevelWarn,
			expectedMetric: "warn",
		},
		{
			name:           "server error",
			method:         "GET",
			path:           "/api/data",
			statusCode:     500,
			expectedLevel:  services.LogLevelError,
			expectedMetric: "error",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			initialMetrics := loggingService.GetMetrics()
			duration := 150 * time.Millisecond

			loggingService.LogHTTPRequest(tt.method, tt.path, tt.statusCode, duration, nil)

			newMetrics := loggingService.GetMetrics()
			assert.Equal(t, initialMetrics.TotalLogs+1, newMetrics.TotalLogs)

			// Check appropriate metric was incremented
			switch tt.expectedMetric {
			case "info":
				assert.Equal(t, initialMetrics.InfoCount+1, newMetrics.InfoCount)
			case "warn":
				assert.Equal(t, initialMetrics.WarnCount+1, newMetrics.WarnCount)
			case "error":
				assert.Equal(t, initialMetrics.ErrorCount+1, newMetrics.ErrorCount)
			}
		})
	}
}

func TestLoggingService_LogOperation(t *testing.T) {
	t.Parallel()

	tempDir := t.TempDir()
	originalDir, _ := os.Getwd()
	defer os.Chdir(originalDir)
	os.Chdir(tempDir)

	loggingService, err := services.NewLoggingService("operation_test", services.LogLevelInfo)
	assert.NoError(t, err)
	defer loggingService.Close()

	startTime := time.Now().Add(-100 * time.Millisecond)

	tests := []struct {
		name          string
		operation     string
		err           error
		expectedLevel services.LogLevel
	}{
		{
			name:          "successful operation",
			operation:     "data_import",
			err:           nil,
			expectedLevel: services.LogLevelInfo,
		},
		{
			name:          "failed operation",
			operation:     "data_export",
			err:           errors.New("export failed"),
			expectedLevel: services.LogLevelError,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			initialMetrics := loggingService.GetMetrics()

			loggingService.LogOperation(tt.operation, startTime, tt.err, nil)

			newMetrics := loggingService.GetMetrics()
			assert.Equal(t, initialMetrics.TotalLogs+1, newMetrics.TotalLogs)

			if tt.err != nil {
				assert.Equal(t, initialMetrics.ErrorCount+1, newMetrics.ErrorCount)
			} else {
				assert.Equal(t, initialMetrics.InfoCount+1, newMetrics.InfoCount)
			}
		})
	}
}

func TestLoggingService_RotateLog(t *testing.T) {
	t.Parallel()

	tempDir := t.TempDir()
	originalDir, _ := os.Getwd()
	defer os.Chdir(originalDir)
	os.Chdir(tempDir)

	loggingService, err := services.NewLoggingService("rotate_test", services.LogLevelInfo)
	assert.NoError(t, err)
	defer loggingService.Close()

	// Log something before rotation
	loggingService.Info("before rotation", nil)

	// Rotate the log
	err = loggingService.RotateLog()
	assert.NoError(t, err)

	// Log something after rotation
	loggingService.Info("after rotation", nil)

	// Both messages should be logged
	metrics := loggingService.GetMetrics()
	assert.Equal(t, int64(2), metrics.InfoCount)
}

func TestRequestLogger(t *testing.T) {
	t.Parallel()

	tempDir := t.TempDir()
	originalDir, _ := os.Getwd()
	defer os.Chdir(originalDir)
	os.Chdir(tempDir)

	loggingService, err := services.NewLoggingService("request_test", services.LogLevelInfo)
	assert.NoError(t, err)
	defer loggingService.Close()

	requestID := "req_123"
	userID := "user_456"

	requestLogger := loggingService.CreateRequestLogger(requestID, userID)
	assert.NotNil(t, requestLogger)

	// Test request logger methods
	requestLogger.Info("request started", map[string]interface{}{"endpoint": "/api/data"})
	requestLogger.Error("request error", errors.New("test error"), nil)
	requestLogger.Complete()

	// Verify metrics were updated
	metrics := loggingService.GetMetrics()
	assert.Equal(t, int64(3), metrics.TotalLogs) // info + error + complete
	assert.Equal(t, int64(2), metrics.InfoCount) // info + complete
	assert.Equal(t, int64(1), metrics.ErrorCount) // error
}

func TestLogEntry_Structure(t *testing.T) {
	t.Parallel()

	now := time.Now()
	duration := 150 * time.Millisecond
	metadata := map[string]interface{}{
		"key1": "value1",
		"key2": 123,
	}

	entry := &services.LogEntry{
		Timestamp:   now,
		Level:       services.LogLevelInfo,
		Message:     "test message",
		Service:     "test_service",
		Method:      "test_method",
		RequestID:   "req_123",
		UserID:      "user_456",
		Duration:    &duration,
		Error:       "test error",
		Metadata:    metadata,
	}

	assert.Equal(t, now, entry.Timestamp)
	assert.Equal(t, services.LogLevelInfo, entry.Level)
	assert.Equal(t, "test message", entry.Message)
	assert.Equal(t, "test_service", entry.Service)
	assert.Equal(t, "test_method", entry.Method)
	assert.Equal(t, "req_123", entry.RequestID)
	assert.Equal(t, "user_456", entry.UserID)
	assert.NotNil(t, entry.Duration)
	assert.Equal(t, duration, *entry.Duration)
	assert.Equal(t, "test error", entry.Error)
	assert.Equal(t, metadata, entry.Metadata)
}

func TestLogMetrics_Structure(t *testing.T) {
	t.Parallel()

	lastLogTime := time.Now()
	metrics := &services.LogMetrics{
		TotalLogs:   100,
		ErrorCount:  10,
		WarnCount:   20,
		InfoCount:   60,
		DebugCount:  10,
		LastLogTime: lastLogTime,
	}

	assert.Equal(t, int64(100), metrics.TotalLogs)
	assert.Equal(t, int64(10), metrics.ErrorCount)
	assert.Equal(t, int64(20), metrics.WarnCount)
	assert.Equal(t, int64(60), metrics.InfoCount)
	assert.Equal(t, int64(10), metrics.DebugCount)
	assert.Equal(t, lastLogTime, metrics.LastLogTime)
}

func TestLogLevel_Values(t *testing.T) {
	t.Parallel()

	// Test LogLevel constants
	assert.Equal(t, services.LogLevel("DEBUG"), services.LogLevelDebug)
	assert.Equal(t, services.LogLevel("INFO"), services.LogLevelInfo)
	assert.Equal(t, services.LogLevel("WARN"), services.LogLevelWarn)
	assert.Equal(t, services.LogLevel("ERROR"), services.LogLevelError)
	assert.Equal(t, services.LogLevel("FATAL"), services.LogLevelFatal)
}

func TestLoggingService_LogLevels(t *testing.T) {
	t.Parallel()

	tempDir := t.TempDir()
	originalDir, _ := os.Getwd()
	defer os.Chdir(originalDir)
	os.Chdir(tempDir)

	tests := []struct {
		name     string
		logLevel services.LogLevel
	}{
		{
			name:     "debug level",
			logLevel: services.LogLevelDebug,
		},
		{
			name:     "info level",
			logLevel: services.LogLevelInfo,
		},
		{
			name:     "warn level",
			logLevel: services.LogLevelWarn,
		},
		{
			name:     "error level",
			logLevel: services.LogLevelError,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			loggingService, err := services.NewLoggingService("level_test", tt.logLevel)
			assert.NoError(t, err)
			defer loggingService.Close()

			// Test all log methods
			loggingService.Debug("debug message", nil)
			loggingService.Info("info message", nil)
			loggingService.Warn("warn message", nil)
			loggingService.Error("error message", errors.New("test error"), nil)

			metrics := loggingService.GetMetrics()

			// Verify only appropriate levels are logged based on service level
			levelMap := map[services.LogLevel]int{
				services.LogLevelDebug: 0,
				services.LogLevelInfo:  1,
				services.LogLevelWarn:  2,
				services.LogLevelError: 3,
			}

			serviceLevel := levelMap[tt.logLevel]
			expectedLogs := int64(0)

			if serviceLevel <= 0 { // Debug level and above
				expectedLogs++ // debug
			}
			if serviceLevel <= 1 { // Info level and above
				expectedLogs++ // info
			}
			if serviceLevel <= 2 { // Warn level and above
				expectedLogs++ // warn
			}
			if serviceLevel <= 3 { // Error level and above
				expectedLogs++ // error
			}

			assert.Equal(t, expectedLogs, metrics.TotalLogs)
		})
	}
}

func TestLoggingService_ConcurrentLogging(t *testing.T) {
	t.Parallel()

	tempDir := t.TempDir()
	originalDir, _ := os.Getwd()
	defer os.Chdir(originalDir)
	os.Chdir(tempDir)

	loggingService, err := services.NewLoggingService("concurrent_test", services.LogLevelDebug)
	assert.NoError(t, err)
	defer loggingService.Close()

	const numGoroutines = 10
	const messagesPerGoroutine = 5

	// Log concurrently from multiple goroutines
	for i := 0; i < numGoroutines; i++ {
		go func(id int) {
			for j := 0; j < messagesPerGoroutine; j++ {
				loggingService.Info("concurrent message", map[string]interface{}{
					"goroutine": id,
					"message":   j,
				})
			}
		}(i)
	}

	// Wait for all goroutines to complete
	time.Sleep(100 * time.Millisecond)

	metrics := loggingService.GetMetrics()
	assert.Equal(t, int64(numGoroutines*messagesPerGoroutine), metrics.TotalLogs)
	assert.Equal(t, int64(numGoroutines*messagesPerGoroutine), metrics.InfoCount)
}

// Benchmark logging service operations
func BenchmarkLoggingService_Info(b *testing.B) {
	tempDir := b.TempDir()
	originalDir, _ := os.Getwd()
	defer os.Chdir(originalDir)
	os.Chdir(tempDir)

	loggingService, err := services.NewLoggingService("benchmark", services.LogLevelInfo)
	if err != nil {
		b.Fatal(err)
	}
	defer loggingService.Close()

	metadata := map[string]interface{}{
		"key1": "value1",
		"key2": 123,
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		loggingService.Info("benchmark message", metadata)
	}
}

func BenchmarkLoggingService_Error(b *testing.B) {
	tempDir := b.TempDir()
	originalDir, _ := os.Getwd()
	defer os.Chdir(originalDir)
	os.Chdir(tempDir)

	loggingService, err := services.NewLoggingService("benchmark", services.LogLevelInfo)
	if err != nil {
		b.Fatal(err)
	}
	defer loggingService.Close()

	testError := errors.New("benchmark error")
	metadata := map[string]interface{}{
		"key1": "value1",
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		loggingService.Error("benchmark error message", testError, metadata)
	}
}