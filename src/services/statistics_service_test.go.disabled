package services

import (
	"context"
	"errors"
	"log"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/yhonda-ohishi/etc_meisai/src/mocks"
	"github.com/yhonda-ohishi/etc_meisai/src/repositories"
)

func TestNewStatisticsService(t *testing.T) {
	mockRepo := new(mocks.MockStatisticsRepository)
	logger := log.New(log.Writer(), "[Test] ", log.LstdFlags)

	service := NewStatisticsService(mockRepo, logger)

	assert.NotNil(t, service)
	assert.Equal(t, mockRepo, service.statsRepo)
	assert.NotNil(t, service.logger)
}

func TestNewStatisticsService_NilLogger(t *testing.T) {
	mockRepo := new(mocks.MockStatisticsRepository)

	service := NewStatisticsService(mockRepo, nil)

	assert.NotNil(t, service)
	assert.NotNil(t, service.logger)
}

func TestGetGeneralStatistics_Success(t *testing.T) {
	ctx := context.Background()
	mockRepo := new(mocks.MockStatisticsRepository)
	service := NewStatisticsService(mockRepo, nil)

	// Setup test data
	dateFrom := time.Now().AddDate(0, -1, 0)
	dateTo := time.Now()
	filter := &StatisticsFilter{
		DateFrom: &dateFrom,
		DateTo:   &dateTo,
	}

	// Setup mock expectations
	mockRepo.On("CountRecords", ctx, mock.AnythingOfType("repositories.StatisticsFilter")).Return(int64(100), nil)
	mockRepo.On("SumTollAmount", ctx, mock.AnythingOfType("repositories.StatisticsFilter")).Return(int64(50000), nil)
	mockRepo.On("AverageTollAmount", ctx, mock.AnythingOfType("repositories.StatisticsFilter")).Return(float64(500), nil)
	mockRepo.On("CountUniqueVehicles", ctx, mock.AnythingOfType("repositories.StatisticsFilter")).Return(int64(10), nil)
	mockRepo.On("CountUniqueCards", ctx, mock.AnythingOfType("repositories.StatisticsFilter")).Return(int64(5), nil)
	mockRepo.On("CountUniqueEntranceICs", ctx, mock.AnythingOfType("repositories.StatisticsFilter")).Return(int64(15), nil)
	mockRepo.On("CountUniqueExitICs", ctx, mock.AnythingOfType("repositories.StatisticsFilter")).Return(int64(20), nil)

	mockRepo.On("GetTopRoutes", ctx, mock.AnythingOfType("repositories.StatisticsFilter"), 10).Return([]repositories.RouteStatistic{
		{EntranceIC: "東京", ExitIC: "横浜", Count: 50, TotalAmount: 25000, AvgAmount: 500},
	}, nil)

	mockRepo.On("GetTopVehicles", ctx, mock.AnythingOfType("repositories.StatisticsFilter"), 10).Return([]repositories.VehicleStatistic{
		{CarNumber: "品川300あ1234", Count: 30, TotalAmount: 15000, AvgAmount: 500},
	}, nil)

	mockRepo.On("GetTopCards", ctx, mock.AnythingOfType("repositories.StatisticsFilter"), 10).Return([]repositories.CardStatistic{
		{ETCCardNumber: "1234567890", Count: 20, TotalAmount: 10000, AvgAmount: 500},
	}, nil)

	mockRepo.On("GetHourlyDistribution", ctx, mock.AnythingOfType("repositories.StatisticsFilter")).Return([]repositories.HourlyStatistic{
		{Hour: 8, Count: 10, TotalAmount: 5000, AvgAmount: 500},
	}, nil)

	// Execute
	result, err := service.GetGeneralStatistics(ctx, filter)

	// Assert
	assert.NoError(t, err)
	assert.NotNil(t, result)
	assert.Equal(t, int64(100), result.TotalRecords)
	assert.Equal(t, int64(50000), result.TotalAmount)
	assert.Equal(t, float64(500), result.AverageAmount)
	assert.Equal(t, int64(10), result.UniqueVehicles)
	assert.Equal(t, int64(5), result.UniqueCards)
	assert.Equal(t, int64(15), result.UniqueEntranceICs)
	assert.Equal(t, int64(20), result.UniqueExitICs)
	assert.Len(t, result.TopRoutes, 1)
	assert.Len(t, result.TopVehicles, 1)
	assert.Len(t, result.TopCards, 1)
	assert.Len(t, result.HourlyDistribution, 1)

	mockRepo.AssertExpectations(t)
}

func TestGetGeneralStatistics_RepositoryError(t *testing.T) {
	ctx := context.Background()
	mockRepo := new(mocks.MockStatisticsRepository)
	service := NewStatisticsService(mockRepo, nil)

	filter := &StatisticsFilter{}

	// Setup mock to return error
	mockRepo.On("CountRecords", ctx, mock.AnythingOfType("repositories.StatisticsFilter")).Return(int64(0), errors.New("database error"))

	// Execute
	result, err := service.GetGeneralStatistics(ctx, filter)

	// Assert
	assert.Error(t, err)
	assert.Nil(t, result)
	assert.Contains(t, err.Error(), "failed to count records")

	mockRepo.AssertExpectations(t)
}

func TestGetDailyStatistics_Success(t *testing.T) {
	ctx := context.Background()
	mockRepo := new(mocks.MockStatisticsRepository)
	service := NewStatisticsService(mockRepo, nil)

	// Setup test data
	dateFrom := time.Now().AddDate(0, -1, 0)
	dateTo := time.Now()
	filter := &StatisticsFilter{
		DateFrom: &dateFrom,
		DateTo:   &dateTo,
	}

	// Setup mock expectations
	mockRepo.On("GetDailyDistribution", ctx, mock.AnythingOfType("repositories.StatisticsFilter")).Return([]repositories.DailyStatistic{
		{Date: time.Now(), Count: 10, TotalAmount: 5000, AvgAmount: 500},
		{Date: time.Now().AddDate(0, 0, -1), Count: 15, TotalAmount: 7500, AvgAmount: 500},
	}, nil)

	// Execute
	result, err := service.GetDailyStatistics(ctx, filter)

	// Assert
	assert.NoError(t, err)
	assert.NotNil(t, result)
	assert.Len(t, result.Statistics, 2)
	assert.Equal(t, int64(10), result.Statistics[0].Count)
	assert.Equal(t, int64(15), result.Statistics[1].Count)

	mockRepo.AssertExpectations(t)
}

func TestGetMonthlyStatistics_Success(t *testing.T) {
	ctx := context.Background()
	mockRepo := new(mocks.MockStatisticsRepository)
	service := NewStatisticsService(mockRepo, nil)

	// Setup test data
	dateFrom := time.Now().AddDate(0, -6, 0)
	dateTo := time.Now()
	filter := &StatisticsFilter{
		DateFrom: &dateFrom,
		DateTo:   &dateTo,
	}

	// Setup mock expectations
	mockRepo.On("GetMonthlyDistribution", ctx, mock.AnythingOfType("repositories.StatisticsFilter")).Return([]repositories.MonthlyStatistic{
		{Year: 2025, Month: 1, Count: 100, TotalAmount: 50000, AvgAmount: 500},
		{Year: 2025, Month: 2, Count: 120, TotalAmount: 60000, AvgAmount: 500},
	}, nil)

	// Execute
	result, err := service.GetMonthlyStatistics(ctx, filter)

	// Assert
	assert.NoError(t, err)
	assert.NotNil(t, result)
	assert.Len(t, result.Statistics, 2)
	assert.Equal(t, "January", result.Statistics[0].MonthName)
	assert.Equal(t, "February", result.Statistics[1].MonthName)

	mockRepo.AssertExpectations(t)
}

func TestGetVehicleStatistics_Success(t *testing.T) {
	ctx := context.Background()
	mockRepo := new(mocks.MockStatisticsRepository)
	service := NewStatisticsService(mockRepo, nil)

	carNumbers := []string{"品川300あ1234", "横浜400い5678"}
	filter := &StatisticsFilter{}

	// Setup mock expectations
	mockRepo.On("GetTopVehicles", ctx, mock.AnythingOfType("repositories.StatisticsFilter"), 2).Return([]repositories.VehicleStatistic{
		{CarNumber: "品川300あ1234", Count: 30, TotalAmount: 15000, AvgAmount: 500},
		{CarNumber: "横浜400い5678", Count: 20, TotalAmount: 10000, AvgAmount: 500},
	}, nil)

	// Execute
	result, err := service.GetVehicleStatistics(ctx, carNumbers, filter)

	// Assert
	assert.NoError(t, err)
	assert.NotNil(t, result)
	assert.Len(t, result.Vehicles, 2)
	assert.Equal(t, "品川300あ1234", result.Vehicles[0].CarNumber)
	assert.Equal(t, "横浜400い5678", result.Vehicles[1].CarNumber)

	mockRepo.AssertExpectations(t)
}

func TestGetMappingStatistics_Success(t *testing.T) {
	ctx := context.Background()
	mockRepo := new(mocks.MockStatisticsRepository)
	service := NewStatisticsService(mockRepo, nil)

	filter := &StatisticsFilter{}

	// Setup mock expectations
	mockRepo.On("GetMappingStatistics", ctx, mock.AnythingOfType("repositories.StatisticsFilter")).Return(&repositories.MappingStatistics{
		TotalRecords:    100,
		MappedRecords:   80,
		UnmappedRecords: 20,
		MappingRate:     0.8,
	}, nil)

	// Execute
	result, err := service.GetMappingStatistics(ctx, filter)

	// Assert
	assert.NoError(t, err)
	assert.NotNil(t, result)
	assert.Equal(t, int64(100), result.TotalRecords)
	assert.Equal(t, int64(80), result.MappedRecords)
	assert.Equal(t, int64(20), result.UnmappedRecords)
	assert.Equal(t, 0.8, result.MappingRate)
	assert.Equal(t, "80.00%", result.MappingRatePercentage)

	mockRepo.AssertExpectations(t)
}

func TestHealthCheck_Success(t *testing.T) {
	ctx := context.Background()
	mockRepo := new(mocks.MockStatisticsRepository)
	service := NewStatisticsService(mockRepo, nil)

	// Setup mock expectations
	mockRepo.On("Ping", ctx).Return(nil)

	// Execute
	err := service.HealthCheck(ctx)

	// Assert
	assert.NoError(t, err)
	mockRepo.AssertExpectations(t)
}

func TestHealthCheck_NilRepository(t *testing.T) {
	ctx := context.Background()
	service := &StatisticsService{
		statsRepo: nil,
	}

	// Execute
	err := service.HealthCheck(ctx)

	// Assert
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "statistics repository not initialized")
}

func TestHealthCheck_PingError(t *testing.T) {
	ctx := context.Background()
	mockRepo := new(mocks.MockStatisticsRepository)
	service := NewStatisticsService(mockRepo, nil)

	// Setup mock expectations
	mockRepo.On("Ping", ctx).Return(errors.New("connection failed"))

	// Execute
	err := service.HealthCheck(ctx)

	// Assert
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "statistics repository ping failed")
	mockRepo.AssertExpectations(t)
}

func TestFormatDateRange_AllTime(t *testing.T) {
	service := &StatisticsService{}

	// Test with nil filter
	result := service.formatDateRange(nil)
	assert.Equal(t, "All Time", result)

	// Test with empty filter
	filter := &StatisticsFilter{}
	result = service.formatDateRange(filter)
	assert.Equal(t, "All Time", result)
}

func TestFormatDateRange_WithDates(t *testing.T) {
	service := &StatisticsService{}

	dateFrom := time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC)
	dateTo := time.Date(2025, 1, 31, 0, 0, 0, 0, time.UTC)

	// Test with both dates
	filter := &StatisticsFilter{
		DateFrom: &dateFrom,
		DateTo:   &dateTo,
	}
	result := service.formatDateRange(filter)
	assert.Equal(t, "2025-01-01 to 2025-01-31", result)

	// Test with only DateFrom
	filter = &StatisticsFilter{
		DateFrom: &dateFrom,
	}
	result = service.formatDateRange(filter)
	assert.Equal(t, "2025-01-01 to Present", result)

	// Test with only DateTo
	filter = &StatisticsFilter{
		DateTo: &dateTo,
	}
	result = service.formatDateRange(filter)
	assert.Equal(t, "Beginning to 2025-01-31", result)
}

func TestConvertRouteStats(t *testing.T) {
	service := &StatisticsService{}

	repoRoutes := []repositories.RouteStatistic{
		{EntranceIC: "東京", ExitIC: "横浜", Count: 50, TotalAmount: 25000, AvgAmount: 500},
		{EntranceIC: "大阪", ExitIC: "神戸", Count: 30, TotalAmount: 15000, AvgAmount: 500},
	}

	result := service.convertRouteStats(repoRoutes)

	assert.Len(t, result, 2)
	assert.Equal(t, "東京", result[0].EntranceIC)
	assert.Equal(t, "横浜", result[0].ExitIC)
	assert.Equal(t, int64(50), result[0].Count)
}

func TestConvertVehicleStats(t *testing.T) {
	service := &StatisticsService{}

	repoVehicles := []repositories.VehicleStatistic{
		{CarNumber: "品川300あ1234", Count: 30, TotalAmount: 15000, AvgAmount: 500},
		{CarNumber: "横浜400い5678", Count: 20, TotalAmount: 10000, AvgAmount: 500},
	}

	result := service.convertVehicleStats(repoVehicles)

	assert.Len(t, result, 2)
	assert.Equal(t, "品川300あ1234", result[0].CarNumber)
	assert.Equal(t, int64(30), result[0].Count)
}

func TestConvertCardStats(t *testing.T) {
	service := &StatisticsService{}

	repoCards := []repositories.CardStatistic{
		{ETCCardNumber: "1234567890", Count: 20, TotalAmount: 10000, AvgAmount: 500},
		{ETCCardNumber: "0987654321", Count: 15, TotalAmount: 7500, AvgAmount: 500},
	}

	result := service.convertCardStats(repoCards)

	assert.Len(t, result, 2)
	assert.Equal(t, "1234567890", result[0].ETCCardNumber)
	assert.Equal(t, int64(20), result[0].Count)
}

func TestConvertHourlyStats(t *testing.T) {
	service := &StatisticsService{}

	repoHourly := []repositories.HourlyStatistic{
		{Hour: 8, Count: 10, TotalAmount: 5000, AvgAmount: 500},
		{Hour: 17, Count: 15, TotalAmount: 7500, AvgAmount: 500},
	}

	result := service.convertHourlyStats(repoHourly)

	assert.Len(t, result, 2)
	assert.Equal(t, 8, result[0].Hour)
	assert.Equal(t, "08:00", result[0].HourLabel)
	assert.Equal(t, int64(10), result[0].Count)
	assert.Equal(t, 17, result[1].Hour)
	assert.Equal(t, "17:00", result[1].HourLabel)
}