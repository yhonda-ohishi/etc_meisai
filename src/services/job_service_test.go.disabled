package services_test

import (
	"errors"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/yhonda-ohishi/etc_meisai/src/services"
)

func TestNewJobService(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name               string
		maxWorkers         int
		expectedMaxWorkers int
	}{
		{
			name:               "with valid workers",
			maxWorkers:         3,
			expectedMaxWorkers: 3,
		},
		{
			name:               "with zero workers",
			maxWorkers:         0,
			expectedMaxWorkers: 5, // default
		},
		{
			name:               "with negative workers",
			maxWorkers:         -1,
			expectedMaxWorkers: 5, // default
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			jobService := services.NewJobService(tt.maxWorkers)
			assert.NotNil(t, jobService)

			stats := jobService.GetStats()
			assert.Equal(t, tt.expectedMaxWorkers, stats["maxWorkers"])
		})
	}
}

func TestJobService_CreateJob(t *testing.T) {
	t.Parallel()

	jobService := services.NewJobService(1)
	defer jobService.Shutdown()

	tests := []struct {
		name    string
		jobType string
	}{
		{
			name:    "import job",
			jobType: "import",
		},
		{
			name:    "export job",
			jobType: "export",
		},
		{
			name:    "download job",
			jobType: "download",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			job := jobService.CreateJob(tt.jobType)

			assert.NotNil(t, job)
			assert.NotEmpty(t, job.ID)
			assert.Equal(t, tt.jobType, job.Type)
			assert.Equal(t, services.JobStatusPending, job.Status)
			assert.Equal(t, 0, job.Progress)
			assert.Equal(t, 100, job.Total)
			assert.False(t, job.CreatedAt.IsZero())
			assert.Nil(t, job.StartedAt)
			assert.Nil(t, job.CompletedAt)
			assert.NotNil(t, job.Context)
			assert.NotNil(t, job.Cancel)
			assert.Nil(t, job.Error)
			assert.Nil(t, job.Result)

			// Verify job can be retrieved
			retrievedJob, err := jobService.GetJob(job.ID)
			assert.NoError(t, err)
			assert.Equal(t, job.ID, retrievedJob.ID)
		})
	}
}

func TestJobService_GetJob(t *testing.T) {
	t.Parallel()

	jobService := services.NewJobService(1)
	defer jobService.Shutdown()

	// Create a job
	job := jobService.CreateJob("test")

	tests := []struct {
		name        string
		jobID       string
		expectError bool
		errorMsg    string
	}{
		{
			name:        "existing job",
			jobID:       job.ID,
			expectError: false,
		},
		{
			name:        "non-existent job",
			jobID:       "non-existent",
			expectError: true,
			errorMsg:    "job not found",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			retrievedJob, err := jobService.GetJob(tt.jobID)

			if tt.expectError {
				assert.Error(t, err)
				assert.Nil(t, retrievedJob)
				if tt.errorMsg != "" {
					assert.Contains(t, err.Error(), tt.errorMsg)
				}
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, retrievedJob)
				assert.Equal(t, tt.jobID, retrievedJob.ID)
			}
		})
	}
}

func TestJobService_UpdateProgress(t *testing.T) {
	t.Parallel()

	jobService := services.NewJobService(1)
	defer jobService.Shutdown()

	job := jobService.CreateJob("test")

	tests := []struct {
		name        string
		jobID       string
		progress    int
		expectError bool
		errorMsg    string
	}{
		{
			name:        "valid progress update",
			jobID:       job.ID,
			progress:    50,
			expectError: false,
		},
		{
			name:        "progress 100%",
			jobID:       job.ID,
			progress:    100,
			expectError: false,
		},
		{
			name:        "non-existent job",
			jobID:       "non-existent",
			progress:    50,
			expectError: true,
			errorMsg:    "job not found",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := jobService.UpdateProgress(tt.jobID, tt.progress)

			if tt.expectError {
				assert.Error(t, err)
				if tt.errorMsg != "" {
					assert.Contains(t, err.Error(), tt.errorMsg)
				}
			} else {
				assert.NoError(t, err)

				// Verify progress was updated
				updatedJob, getErr := jobService.GetJob(tt.jobID)
				assert.NoError(t, getErr)
				assert.Equal(t, tt.progress, updatedJob.Progress)
			}
		})
	}
}

func TestJobService_CancelJob(t *testing.T) {
	t.Parallel()

	jobService := services.NewJobService(1)
	defer jobService.Shutdown()

	job := jobService.CreateJob("test")

	tests := []struct {
		name        string
		jobID       string
		expectError bool
		errorMsg    string
	}{
		{
			name:        "cancel pending job",
			jobID:       job.ID,
			expectError: false,
		},
		{
			name:        "cancel non-existent job",
			jobID:       "non-existent",
			expectError: true,
			errorMsg:    "job not found",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := jobService.CancelJob(tt.jobID)

			if tt.expectError {
				assert.Error(t, err)
				if tt.errorMsg != "" {
					assert.Contains(t, err.Error(), tt.errorMsg)
				}
			} else {
				assert.NoError(t, err)

				// Verify job was canceled
				canceledJob, getErr := jobService.GetJob(tt.jobID)
				assert.NoError(t, getErr)
				assert.Equal(t, services.JobStatusCanceled, canceledJob.Status)
				assert.NotNil(t, canceledJob.CompletedAt)
			}
		})
	}
}

func TestJobService_GetAllJobs(t *testing.T) {
	t.Parallel()

	jobService := services.NewJobService(1)
	defer jobService.Shutdown()

	// Create multiple jobs
	job1 := jobService.CreateJob("import")
	job2 := jobService.CreateJob("export")
	job3 := jobService.CreateJob("download")

	allJobs := jobService.GetAllJobs()

	assert.Len(t, allJobs, 3)

	jobIDs := make([]string, len(allJobs))
	for i, job := range allJobs {
		jobIDs[i] = job.ID
	}

	assert.Contains(t, jobIDs, job1.ID)
	assert.Contains(t, jobIDs, job2.ID)
	assert.Contains(t, jobIDs, job3.ID)
}

func TestJobService_GetJobsByStatus(t *testing.T) {
	t.Parallel()

	jobService := services.NewJobService(1)
	defer jobService.Shutdown()

	// Create jobs with different statuses
	pendingJob := jobService.CreateJob("pending_job")
	canceledJob := jobService.CreateJob("canceled_job")
	jobService.CancelJob(canceledJob.ID)

	tests := []struct {
		name            string
		status          services.JobStatus
		expectedCount   int
		expectedJobIDs  []string
	}{
		{
			name:           "pending jobs",
			status:         services.JobStatusPending,
			expectedCount:  1,
			expectedJobIDs: []string{pendingJob.ID},
		},
		{
			name:           "canceled jobs",
			status:         services.JobStatusCanceled,
			expectedCount:  1,
			expectedJobIDs: []string{canceledJob.ID},
		},
		{
			name:           "running jobs",
			status:         services.JobStatusRunning,
			expectedCount:  0,
			expectedJobIDs: []string{},
		},
		{
			name:           "completed jobs",
			status:         services.JobStatusCompleted,
			expectedCount:  0,
			expectedJobIDs: []string{},
		},
		{
			name:           "failed jobs",
			status:         services.JobStatusFailed,
			expectedCount:  0,
			expectedJobIDs: []string{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			jobs := jobService.GetJobsByStatus(tt.status)
			assert.Len(t, jobs, tt.expectedCount)

			for _, expectedID := range tt.expectedJobIDs {
				found := false
				for _, job := range jobs {
					if job.ID == expectedID {
						found = true
						assert.Equal(t, tt.status, job.Status)
						break
					}
				}
				assert.True(t, found, "Expected job ID %s not found", expectedID)
			}
		})
	}
}

func TestJobService_CleanupOldJobs(t *testing.T) {
	t.Parallel()

	jobService := services.NewJobService(1)
	defer jobService.Shutdown()

	// Create and immediately cancel a job to set its CompletedAt
	oldJob := jobService.CreateJob("old_job")
	jobService.CancelJob(oldJob.ID)

	// Create a pending job (should not be cleaned up)
	newJob := jobService.CreateJob("new_job")

	// Artificially set the CompletedAt to an old time
	retrievedOldJob, _ := jobService.GetJob(oldJob.ID)
	oldTime := time.Now().Add(-2 * time.Hour)
	retrievedOldJob.CompletedAt = &oldTime

	// Cleanup jobs older than 1 hour
	removedCount := jobService.CleanupOldJobs(1 * time.Hour)

	assert.Equal(t, 1, removedCount)

	// Verify old job was removed
	_, err := jobService.GetJob(oldJob.ID)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "job not found")

	// Verify new job still exists
	_, err = jobService.GetJob(newJob.ID)
	assert.NoError(t, err)
}

func TestJobService_GetStats(t *testing.T) {
	t.Parallel()

	jobService := services.NewJobService(3)
	defer jobService.Shutdown()

	// Create jobs with different statuses
	_ = jobService.CreateJob("pending")
	canceledJob := jobService.CreateJob("canceled")
	jobService.CancelJob(canceledJob.ID)

	stats := jobService.GetStats()

	assert.NotNil(t, stats)
	assert.Contains(t, stats, "stats")
	assert.Contains(t, stats, "maxWorkers")
	assert.Contains(t, stats, "queueSize")

	assert.Equal(t, 3, stats["maxWorkers"])

	jobStats := stats["stats"].(map[string]int)
	assert.Equal(t, 2, jobStats["total"])
	assert.Equal(t, 1, jobStats["pending"])
	assert.Equal(t, 0, jobStats["running"])
	assert.Equal(t, 0, jobStats["completed"])
	assert.Equal(t, 0, jobStats["failed"])
	assert.Equal(t, 1, jobStats["canceled"])
}

func TestJobService_SubmitJob_Success(t *testing.T) {
	t.Parallel()

	jobService := services.NewJobService(1)
	defer jobService.Shutdown()

	job := jobService.CreateJob("test")

	executed := false
	jobFunction := func(j *services.Job) error {
		executed = true
		j.Progress = 50
		j.Result = "test result"
		return nil
	}

	jobService.SubmitJob(job, jobFunction)

	// Wait for job to complete
	time.Sleep(100 * time.Millisecond)

	assert.True(t, executed)

	// Check final job status
	completedJob, err := jobService.GetJob(job.ID)
	assert.NoError(t, err)
	assert.Equal(t, services.JobStatusCompleted, completedJob.Status)
	assert.Equal(t, 100, completedJob.Progress) // Should be set to Total on completion
	assert.Equal(t, "test result", completedJob.Result)
	assert.NotNil(t, completedJob.StartedAt)
	assert.NotNil(t, completedJob.CompletedAt)
	assert.Nil(t, completedJob.Error)
}

func TestJobService_SubmitJob_Failure(t *testing.T) {
	t.Parallel()

	jobService := services.NewJobService(1)
	defer jobService.Shutdown()

	job := jobService.CreateJob("test")

	testError := errors.New("test error")
	jobFunction := func(j *services.Job) error {
		j.Progress = 30
		return testError
	}

	jobService.SubmitJob(job, jobFunction)

	// Wait for job to complete
	time.Sleep(100 * time.Millisecond)

	// Check final job status
	failedJob, err := jobService.GetJob(job.ID)
	assert.NoError(t, err)
	assert.Equal(t, services.JobStatusFailed, failedJob.Status)
	assert.Equal(t, 30, failedJob.Progress) // Should keep the progress set during execution
	assert.NotNil(t, failedJob.StartedAt)
	assert.NotNil(t, failedJob.CompletedAt)
	assert.Equal(t, testError, failedJob.Error)
}

func TestJobService_ConcurrentJobs(t *testing.T) {
	t.Parallel()

	jobService := services.NewJobService(2) // 2 workers
	defer jobService.Shutdown()

	const numJobs = 5
	jobs := make([]*services.Job, numJobs)
	executed := make([]bool, numJobs)

	// Create and submit multiple jobs
	for i := 0; i < numJobs; i++ {
		jobs[i] = jobService.CreateJob("concurrent")
		index := i // Capture for closure
		jobFunction := func(j *services.Job) error {
			executed[index] = true
			time.Sleep(50 * time.Millisecond) // Simulate work
			return nil
		}
		jobService.SubmitJob(jobs[i], jobFunction)
	}

	// Wait for all jobs to complete
	time.Sleep(500 * time.Millisecond)

	// Verify all jobs executed
	for i := 0; i < numJobs; i++ {
		assert.True(t, executed[i], "Job %d was not executed", i)

		completedJob, err := jobService.GetJob(jobs[i].ID)
		assert.NoError(t, err)
		assert.Equal(t, services.JobStatusCompleted, completedJob.Status)
	}
}

func TestJobService_Shutdown(t *testing.T) {
	t.Parallel()

	jobService := services.NewJobService(1)

	// Create some jobs
	job1 := jobService.CreateJob("test1")
	job2 := jobService.CreateJob("test2")

	// Submit a long-running job
	jobFunction := func(j *services.Job) error {
		time.Sleep(1 * time.Second)
		return nil
	}
	jobService.SubmitJob(job2, jobFunction)

	// Wait a bit for job to start
	time.Sleep(50 * time.Millisecond)

	// Shutdown should cancel all jobs
	jobService.Shutdown()

	// Verify jobs were handled appropriately
	_, err1 := jobService.GetJob(job1.ID)
	assert.NoError(t, err1) // Job still exists

	_, err2 := jobService.GetJob(job2.ID)
	assert.NoError(t, err2) // Job still exists
}

func TestJob_Structure(t *testing.T) {
	t.Parallel()

	jobService := services.NewJobService(1)
	defer jobService.Shutdown()

	job := jobService.CreateJob("test_structure")

	// Test Job structure
	assert.NotEmpty(t, job.ID)
	assert.Equal(t, "test_structure", job.Type)
	assert.Equal(t, services.JobStatusPending, job.Status)
	assert.Equal(t, 0, job.Progress)
	assert.Equal(t, 100, job.Total)
	assert.Nil(t, job.Result)
	assert.Nil(t, job.Error)
	assert.False(t, job.CreatedAt.IsZero())
	assert.Nil(t, job.StartedAt)
	assert.Nil(t, job.CompletedAt)
	assert.NotNil(t, job.Context)
	assert.NotNil(t, job.Cancel)
}

func TestJobStatus_Values(t *testing.T) {
	t.Parallel()

	// Test JobStatus constants
	assert.Equal(t, services.JobStatus("pending"), services.JobStatusPending)
	assert.Equal(t, services.JobStatus("running"), services.JobStatusRunning)
	assert.Equal(t, services.JobStatus("completed"), services.JobStatusCompleted)
	assert.Equal(t, services.JobStatus("failed"), services.JobStatusFailed)
	assert.Equal(t, services.JobStatus("canceled"), services.JobStatusCanceled)
}

// Benchmark job service operations
func BenchmarkJobService_CreateJob(b *testing.B) {
	jobService := services.NewJobService(1)
	defer jobService.Shutdown()

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		job := jobService.CreateJob("benchmark")
		_ = job
	}
}

func BenchmarkJobService_GetJob(b *testing.B) {
	jobService := services.NewJobService(1)
	defer jobService.Shutdown()

	job := jobService.CreateJob("benchmark")

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = jobService.GetJob(job.ID)
	}
}

func BenchmarkJobService_UpdateProgress(b *testing.B) {
	jobService := services.NewJobService(1)
	defer jobService.Shutdown()

	job := jobService.CreateJob("benchmark")

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = jobService.UpdateProgress(job.ID, i%100)
	}
}