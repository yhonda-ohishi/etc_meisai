// Protocol Buffer definition for ETC明細 gRPC service integration

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.32.1
// source: specs/001-db-service-integration/contracts/grpc_service.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ETCService_CreateETCMeisai_FullMethodName         = "/etc_service.ETCService/CreateETCMeisai"
	ETCService_GetETCMeisai_FullMethodName            = "/etc_service.ETCService/GetETCMeisai"
	ETCService_UpdateETCMeisai_FullMethodName         = "/etc_service.ETCService/UpdateETCMeisai"
	ETCService_DeleteETCMeisai_FullMethodName         = "/etc_service.ETCService/DeleteETCMeisai"
	ETCService_ListETCMeisai_FullMethodName           = "/etc_service.ETCService/ListETCMeisai"
	ETCService_BulkCreateETCMeisai_FullMethodName     = "/etc_service.ETCService/BulkCreateETCMeisai"
	ETCService_BulkUpdateETCMeisai_FullMethodName     = "/etc_service.ETCService/BulkUpdateETCMeisai"
	ETCService_GetETCMeisaiByDateRange_FullMethodName = "/etc_service.ETCService/GetETCMeisaiByDateRange"
	ETCService_GetETCMeisaiByHash_FullMethodName      = "/etc_service.ETCService/GetETCMeisaiByHash"
	ETCService_GetUnmappedETCMeisai_FullMethodName    = "/etc_service.ETCService/GetUnmappedETCMeisai"
	ETCService_CheckDuplicatesByHash_FullMethodName   = "/etc_service.ETCService/CheckDuplicatesByHash"
	ETCService_GenerateHash_FullMethodName            = "/etc_service.ETCService/GenerateHash"
	ETCService_GetETCSummary_FullMethodName           = "/etc_service.ETCService/GetETCSummary"
	ETCService_GetMonthlyStats_FullMethodName         = "/etc_service.ETCService/GetMonthlyStats"
)

// ETCServiceClient is the client API for ETCService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ETC明細 gRPC service definition
type ETCServiceClient interface {
	// Basic CRUD operations
	CreateETCMeisai(ctx context.Context, in *CreateETCMeisaiRequest, opts ...grpc.CallOption) (*ETCMeisaiResponse, error)
	GetETCMeisai(ctx context.Context, in *GetETCMeisaiRequest, opts ...grpc.CallOption) (*ETCMeisaiResponse, error)
	UpdateETCMeisai(ctx context.Context, in *UpdateETCMeisaiRequest, opts ...grpc.CallOption) (*ETCMeisaiResponse, error)
	DeleteETCMeisai(ctx context.Context, in *DeleteETCMeisaiRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListETCMeisai(ctx context.Context, in *ListETCMeisaiRequest, opts ...grpc.CallOption) (*ListETCMeisaiResponse, error)
	// Bulk operations
	BulkCreateETCMeisai(ctx context.Context, in *BulkCreateETCMeisaiRequest, opts ...grpc.CallOption) (*BulkCreateETCMeisaiResponse, error)
	BulkUpdateETCMeisai(ctx context.Context, in *BulkUpdateETCMeisaiRequest, opts ...grpc.CallOption) (*BulkUpdateETCMeisaiResponse, error)
	// Query operations
	GetETCMeisaiByDateRange(ctx context.Context, in *GetETCMeisaiByDateRangeRequest, opts ...grpc.CallOption) (*ListETCMeisaiResponse, error)
	GetETCMeisaiByHash(ctx context.Context, in *GetETCMeisaiByHashRequest, opts ...grpc.CallOption) (*ETCMeisaiResponse, error)
	GetUnmappedETCMeisai(ctx context.Context, in *GetUnmappedETCMeisaiRequest, opts ...grpc.CallOption) (*ListETCMeisaiResponse, error)
	// Hash operations
	CheckDuplicatesByHash(ctx context.Context, in *CheckDuplicatesByHashRequest, opts ...grpc.CallOption) (*CheckDuplicatesByHashResponse, error)
	GenerateHash(ctx context.Context, in *GenerateHashRequest, opts ...grpc.CallOption) (*GenerateHashResponse, error)
	// Aggregation operations
	GetETCSummary(ctx context.Context, in *GetETCSummaryRequest, opts ...grpc.CallOption) (*ETCSummaryResponse, error)
	GetMonthlyStats(ctx context.Context, in *GetMonthlyStatsRequest, opts ...grpc.CallOption) (*MonthlyStatsResponse, error)
}

type eTCServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewETCServiceClient(cc grpc.ClientConnInterface) ETCServiceClient {
	return &eTCServiceClient{cc}
}

func (c *eTCServiceClient) CreateETCMeisai(ctx context.Context, in *CreateETCMeisaiRequest, opts ...grpc.CallOption) (*ETCMeisaiResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ETCMeisaiResponse)
	err := c.cc.Invoke(ctx, ETCService_CreateETCMeisai_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCServiceClient) GetETCMeisai(ctx context.Context, in *GetETCMeisaiRequest, opts ...grpc.CallOption) (*ETCMeisaiResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ETCMeisaiResponse)
	err := c.cc.Invoke(ctx, ETCService_GetETCMeisai_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCServiceClient) UpdateETCMeisai(ctx context.Context, in *UpdateETCMeisaiRequest, opts ...grpc.CallOption) (*ETCMeisaiResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ETCMeisaiResponse)
	err := c.cc.Invoke(ctx, ETCService_UpdateETCMeisai_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCServiceClient) DeleteETCMeisai(ctx context.Context, in *DeleteETCMeisaiRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ETCService_DeleteETCMeisai_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCServiceClient) ListETCMeisai(ctx context.Context, in *ListETCMeisaiRequest, opts ...grpc.CallOption) (*ListETCMeisaiResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListETCMeisaiResponse)
	err := c.cc.Invoke(ctx, ETCService_ListETCMeisai_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCServiceClient) BulkCreateETCMeisai(ctx context.Context, in *BulkCreateETCMeisaiRequest, opts ...grpc.CallOption) (*BulkCreateETCMeisaiResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BulkCreateETCMeisaiResponse)
	err := c.cc.Invoke(ctx, ETCService_BulkCreateETCMeisai_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCServiceClient) BulkUpdateETCMeisai(ctx context.Context, in *BulkUpdateETCMeisaiRequest, opts ...grpc.CallOption) (*BulkUpdateETCMeisaiResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BulkUpdateETCMeisaiResponse)
	err := c.cc.Invoke(ctx, ETCService_BulkUpdateETCMeisai_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCServiceClient) GetETCMeisaiByDateRange(ctx context.Context, in *GetETCMeisaiByDateRangeRequest, opts ...grpc.CallOption) (*ListETCMeisaiResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListETCMeisaiResponse)
	err := c.cc.Invoke(ctx, ETCService_GetETCMeisaiByDateRange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCServiceClient) GetETCMeisaiByHash(ctx context.Context, in *GetETCMeisaiByHashRequest, opts ...grpc.CallOption) (*ETCMeisaiResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ETCMeisaiResponse)
	err := c.cc.Invoke(ctx, ETCService_GetETCMeisaiByHash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCServiceClient) GetUnmappedETCMeisai(ctx context.Context, in *GetUnmappedETCMeisaiRequest, opts ...grpc.CallOption) (*ListETCMeisaiResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListETCMeisaiResponse)
	err := c.cc.Invoke(ctx, ETCService_GetUnmappedETCMeisai_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCServiceClient) CheckDuplicatesByHash(ctx context.Context, in *CheckDuplicatesByHashRequest, opts ...grpc.CallOption) (*CheckDuplicatesByHashResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckDuplicatesByHashResponse)
	err := c.cc.Invoke(ctx, ETCService_CheckDuplicatesByHash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCServiceClient) GenerateHash(ctx context.Context, in *GenerateHashRequest, opts ...grpc.CallOption) (*GenerateHashResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateHashResponse)
	err := c.cc.Invoke(ctx, ETCService_GenerateHash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCServiceClient) GetETCSummary(ctx context.Context, in *GetETCSummaryRequest, opts ...grpc.CallOption) (*ETCSummaryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ETCSummaryResponse)
	err := c.cc.Invoke(ctx, ETCService_GetETCSummary_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCServiceClient) GetMonthlyStats(ctx context.Context, in *GetMonthlyStatsRequest, opts ...grpc.CallOption) (*MonthlyStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MonthlyStatsResponse)
	err := c.cc.Invoke(ctx, ETCService_GetMonthlyStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ETCServiceServer is the server API for ETCService service.
// All implementations must embed UnimplementedETCServiceServer
// for forward compatibility.
//
// ETC明細 gRPC service definition
type ETCServiceServer interface {
	// Basic CRUD operations
	CreateETCMeisai(context.Context, *CreateETCMeisaiRequest) (*ETCMeisaiResponse, error)
	GetETCMeisai(context.Context, *GetETCMeisaiRequest) (*ETCMeisaiResponse, error)
	UpdateETCMeisai(context.Context, *UpdateETCMeisaiRequest) (*ETCMeisaiResponse, error)
	DeleteETCMeisai(context.Context, *DeleteETCMeisaiRequest) (*emptypb.Empty, error)
	ListETCMeisai(context.Context, *ListETCMeisaiRequest) (*ListETCMeisaiResponse, error)
	// Bulk operations
	BulkCreateETCMeisai(context.Context, *BulkCreateETCMeisaiRequest) (*BulkCreateETCMeisaiResponse, error)
	BulkUpdateETCMeisai(context.Context, *BulkUpdateETCMeisaiRequest) (*BulkUpdateETCMeisaiResponse, error)
	// Query operations
	GetETCMeisaiByDateRange(context.Context, *GetETCMeisaiByDateRangeRequest) (*ListETCMeisaiResponse, error)
	GetETCMeisaiByHash(context.Context, *GetETCMeisaiByHashRequest) (*ETCMeisaiResponse, error)
	GetUnmappedETCMeisai(context.Context, *GetUnmappedETCMeisaiRequest) (*ListETCMeisaiResponse, error)
	// Hash operations
	CheckDuplicatesByHash(context.Context, *CheckDuplicatesByHashRequest) (*CheckDuplicatesByHashResponse, error)
	GenerateHash(context.Context, *GenerateHashRequest) (*GenerateHashResponse, error)
	// Aggregation operations
	GetETCSummary(context.Context, *GetETCSummaryRequest) (*ETCSummaryResponse, error)
	GetMonthlyStats(context.Context, *GetMonthlyStatsRequest) (*MonthlyStatsResponse, error)
	mustEmbedUnimplementedETCServiceServer()
}

// UnimplementedETCServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedETCServiceServer struct{}

func (UnimplementedETCServiceServer) CreateETCMeisai(context.Context, *CreateETCMeisaiRequest) (*ETCMeisaiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateETCMeisai not implemented")
}
func (UnimplementedETCServiceServer) GetETCMeisai(context.Context, *GetETCMeisaiRequest) (*ETCMeisaiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetETCMeisai not implemented")
}
func (UnimplementedETCServiceServer) UpdateETCMeisai(context.Context, *UpdateETCMeisaiRequest) (*ETCMeisaiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateETCMeisai not implemented")
}
func (UnimplementedETCServiceServer) DeleteETCMeisai(context.Context, *DeleteETCMeisaiRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteETCMeisai not implemented")
}
func (UnimplementedETCServiceServer) ListETCMeisai(context.Context, *ListETCMeisaiRequest) (*ListETCMeisaiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListETCMeisai not implemented")
}
func (UnimplementedETCServiceServer) BulkCreateETCMeisai(context.Context, *BulkCreateETCMeisaiRequest) (*BulkCreateETCMeisaiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkCreateETCMeisai not implemented")
}
func (UnimplementedETCServiceServer) BulkUpdateETCMeisai(context.Context, *BulkUpdateETCMeisaiRequest) (*BulkUpdateETCMeisaiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkUpdateETCMeisai not implemented")
}
func (UnimplementedETCServiceServer) GetETCMeisaiByDateRange(context.Context, *GetETCMeisaiByDateRangeRequest) (*ListETCMeisaiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetETCMeisaiByDateRange not implemented")
}
func (UnimplementedETCServiceServer) GetETCMeisaiByHash(context.Context, *GetETCMeisaiByHashRequest) (*ETCMeisaiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetETCMeisaiByHash not implemented")
}
func (UnimplementedETCServiceServer) GetUnmappedETCMeisai(context.Context, *GetUnmappedETCMeisaiRequest) (*ListETCMeisaiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUnmappedETCMeisai not implemented")
}
func (UnimplementedETCServiceServer) CheckDuplicatesByHash(context.Context, *CheckDuplicatesByHashRequest) (*CheckDuplicatesByHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckDuplicatesByHash not implemented")
}
func (UnimplementedETCServiceServer) GenerateHash(context.Context, *GenerateHashRequest) (*GenerateHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateHash not implemented")
}
func (UnimplementedETCServiceServer) GetETCSummary(context.Context, *GetETCSummaryRequest) (*ETCSummaryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetETCSummary not implemented")
}
func (UnimplementedETCServiceServer) GetMonthlyStats(context.Context, *GetMonthlyStatsRequest) (*MonthlyStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMonthlyStats not implemented")
}
func (UnimplementedETCServiceServer) mustEmbedUnimplementedETCServiceServer() {}
func (UnimplementedETCServiceServer) testEmbeddedByValue()                    {}

// UnsafeETCServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ETCServiceServer will
// result in compilation errors.
type UnsafeETCServiceServer interface {
	mustEmbedUnimplementedETCServiceServer()
}

func RegisterETCServiceServer(s grpc.ServiceRegistrar, srv ETCServiceServer) {
	// If the following call pancis, it indicates UnimplementedETCServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ETCService_ServiceDesc, srv)
}

func _ETCService_CreateETCMeisai_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateETCMeisaiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCServiceServer).CreateETCMeisai(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCService_CreateETCMeisai_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCServiceServer).CreateETCMeisai(ctx, req.(*CreateETCMeisaiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCService_GetETCMeisai_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetETCMeisaiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCServiceServer).GetETCMeisai(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCService_GetETCMeisai_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCServiceServer).GetETCMeisai(ctx, req.(*GetETCMeisaiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCService_UpdateETCMeisai_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateETCMeisaiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCServiceServer).UpdateETCMeisai(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCService_UpdateETCMeisai_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCServiceServer).UpdateETCMeisai(ctx, req.(*UpdateETCMeisaiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCService_DeleteETCMeisai_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteETCMeisaiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCServiceServer).DeleteETCMeisai(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCService_DeleteETCMeisai_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCServiceServer).DeleteETCMeisai(ctx, req.(*DeleteETCMeisaiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCService_ListETCMeisai_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListETCMeisaiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCServiceServer).ListETCMeisai(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCService_ListETCMeisai_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCServiceServer).ListETCMeisai(ctx, req.(*ListETCMeisaiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCService_BulkCreateETCMeisai_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkCreateETCMeisaiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCServiceServer).BulkCreateETCMeisai(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCService_BulkCreateETCMeisai_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCServiceServer).BulkCreateETCMeisai(ctx, req.(*BulkCreateETCMeisaiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCService_BulkUpdateETCMeisai_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkUpdateETCMeisaiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCServiceServer).BulkUpdateETCMeisai(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCService_BulkUpdateETCMeisai_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCServiceServer).BulkUpdateETCMeisai(ctx, req.(*BulkUpdateETCMeisaiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCService_GetETCMeisaiByDateRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetETCMeisaiByDateRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCServiceServer).GetETCMeisaiByDateRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCService_GetETCMeisaiByDateRange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCServiceServer).GetETCMeisaiByDateRange(ctx, req.(*GetETCMeisaiByDateRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCService_GetETCMeisaiByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetETCMeisaiByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCServiceServer).GetETCMeisaiByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCService_GetETCMeisaiByHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCServiceServer).GetETCMeisaiByHash(ctx, req.(*GetETCMeisaiByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCService_GetUnmappedETCMeisai_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUnmappedETCMeisaiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCServiceServer).GetUnmappedETCMeisai(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCService_GetUnmappedETCMeisai_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCServiceServer).GetUnmappedETCMeisai(ctx, req.(*GetUnmappedETCMeisaiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCService_CheckDuplicatesByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckDuplicatesByHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCServiceServer).CheckDuplicatesByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCService_CheckDuplicatesByHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCServiceServer).CheckDuplicatesByHash(ctx, req.(*CheckDuplicatesByHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCService_GenerateHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCServiceServer).GenerateHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCService_GenerateHash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCServiceServer).GenerateHash(ctx, req.(*GenerateHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCService_GetETCSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetETCSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCServiceServer).GetETCSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCService_GetETCSummary_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCServiceServer).GetETCSummary(ctx, req.(*GetETCSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCService_GetMonthlyStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMonthlyStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCServiceServer).GetMonthlyStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCService_GetMonthlyStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCServiceServer).GetMonthlyStats(ctx, req.(*GetMonthlyStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ETCService_ServiceDesc is the grpc.ServiceDesc for ETCService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ETCService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "etc_service.ETCService",
	HandlerType: (*ETCServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateETCMeisai",
			Handler:    _ETCService_CreateETCMeisai_Handler,
		},
		{
			MethodName: "GetETCMeisai",
			Handler:    _ETCService_GetETCMeisai_Handler,
		},
		{
			MethodName: "UpdateETCMeisai",
			Handler:    _ETCService_UpdateETCMeisai_Handler,
		},
		{
			MethodName: "DeleteETCMeisai",
			Handler:    _ETCService_DeleteETCMeisai_Handler,
		},
		{
			MethodName: "ListETCMeisai",
			Handler:    _ETCService_ListETCMeisai_Handler,
		},
		{
			MethodName: "BulkCreateETCMeisai",
			Handler:    _ETCService_BulkCreateETCMeisai_Handler,
		},
		{
			MethodName: "BulkUpdateETCMeisai",
			Handler:    _ETCService_BulkUpdateETCMeisai_Handler,
		},
		{
			MethodName: "GetETCMeisaiByDateRange",
			Handler:    _ETCService_GetETCMeisaiByDateRange_Handler,
		},
		{
			MethodName: "GetETCMeisaiByHash",
			Handler:    _ETCService_GetETCMeisaiByHash_Handler,
		},
		{
			MethodName: "GetUnmappedETCMeisai",
			Handler:    _ETCService_GetUnmappedETCMeisai_Handler,
		},
		{
			MethodName: "CheckDuplicatesByHash",
			Handler:    _ETCService_CheckDuplicatesByHash_Handler,
		},
		{
			MethodName: "GenerateHash",
			Handler:    _ETCService_GenerateHash_Handler,
		},
		{
			MethodName: "GetETCSummary",
			Handler:    _ETCService_GetETCSummary_Handler,
		},
		{
			MethodName: "GetMonthlyStats",
			Handler:    _ETCService_GetMonthlyStats_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "specs/001-db-service-integration/contracts/grpc_service.proto",
}

const (
	ETCMappingService_CreateMapping_FullMethodName        = "/etc_service.ETCMappingService/CreateMapping"
	ETCMappingService_GetMapping_FullMethodName           = "/etc_service.ETCMappingService/GetMapping"
	ETCMappingService_UpdateMapping_FullMethodName        = "/etc_service.ETCMappingService/UpdateMapping"
	ETCMappingService_DeleteMapping_FullMethodName        = "/etc_service.ETCMappingService/DeleteMapping"
	ETCMappingService_ListMappings_FullMethodName         = "/etc_service.ETCMappingService/ListMappings"
	ETCMappingService_FindPotentialMatches_FullMethodName = "/etc_service.ETCMappingService/FindPotentialMatches"
	ETCMappingService_CreateAutoMappings_FullMethodName   = "/etc_service.ETCMappingService/CreateAutoMappings"
)

// ETCMappingServiceClient is the client API for ETCMappingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Mapping service for ETC-DTako relationships
type ETCMappingServiceClient interface {
	// Basic CRUD
	CreateMapping(ctx context.Context, in *CreateMappingRequest, opts ...grpc.CallOption) (*MappingResponse, error)
	GetMapping(ctx context.Context, in *GetMappingRequest, opts ...grpc.CallOption) (*MappingResponse, error)
	UpdateMapping(ctx context.Context, in *UpdateMappingRequest, opts ...grpc.CallOption) (*MappingResponse, error)
	DeleteMapping(ctx context.Context, in *DeleteMappingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListMappings(ctx context.Context, in *ListMappingsRequest, opts ...grpc.CallOption) (*ListMappingsResponse, error)
	// Auto-matching
	FindPotentialMatches(ctx context.Context, in *FindPotentialMatchesRequest, opts ...grpc.CallOption) (*FindPotentialMatchesResponse, error)
	CreateAutoMappings(ctx context.Context, in *CreateAutoMappingsRequest, opts ...grpc.CallOption) (*CreateAutoMappingsResponse, error)
}

type eTCMappingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewETCMappingServiceClient(cc grpc.ClientConnInterface) ETCMappingServiceClient {
	return &eTCMappingServiceClient{cc}
}

func (c *eTCMappingServiceClient) CreateMapping(ctx context.Context, in *CreateMappingRequest, opts ...grpc.CallOption) (*MappingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MappingResponse)
	err := c.cc.Invoke(ctx, ETCMappingService_CreateMapping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCMappingServiceClient) GetMapping(ctx context.Context, in *GetMappingRequest, opts ...grpc.CallOption) (*MappingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MappingResponse)
	err := c.cc.Invoke(ctx, ETCMappingService_GetMapping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCMappingServiceClient) UpdateMapping(ctx context.Context, in *UpdateMappingRequest, opts ...grpc.CallOption) (*MappingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MappingResponse)
	err := c.cc.Invoke(ctx, ETCMappingService_UpdateMapping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCMappingServiceClient) DeleteMapping(ctx context.Context, in *DeleteMappingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ETCMappingService_DeleteMapping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCMappingServiceClient) ListMappings(ctx context.Context, in *ListMappingsRequest, opts ...grpc.CallOption) (*ListMappingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMappingsResponse)
	err := c.cc.Invoke(ctx, ETCMappingService_ListMappings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCMappingServiceClient) FindPotentialMatches(ctx context.Context, in *FindPotentialMatchesRequest, opts ...grpc.CallOption) (*FindPotentialMatchesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindPotentialMatchesResponse)
	err := c.cc.Invoke(ctx, ETCMappingService_FindPotentialMatches_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCMappingServiceClient) CreateAutoMappings(ctx context.Context, in *CreateAutoMappingsRequest, opts ...grpc.CallOption) (*CreateAutoMappingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAutoMappingsResponse)
	err := c.cc.Invoke(ctx, ETCMappingService_CreateAutoMappings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ETCMappingServiceServer is the server API for ETCMappingService service.
// All implementations must embed UnimplementedETCMappingServiceServer
// for forward compatibility.
//
// Mapping service for ETC-DTako relationships
type ETCMappingServiceServer interface {
	// Basic CRUD
	CreateMapping(context.Context, *CreateMappingRequest) (*MappingResponse, error)
	GetMapping(context.Context, *GetMappingRequest) (*MappingResponse, error)
	UpdateMapping(context.Context, *UpdateMappingRequest) (*MappingResponse, error)
	DeleteMapping(context.Context, *DeleteMappingRequest) (*emptypb.Empty, error)
	ListMappings(context.Context, *ListMappingsRequest) (*ListMappingsResponse, error)
	// Auto-matching
	FindPotentialMatches(context.Context, *FindPotentialMatchesRequest) (*FindPotentialMatchesResponse, error)
	CreateAutoMappings(context.Context, *CreateAutoMappingsRequest) (*CreateAutoMappingsResponse, error)
	mustEmbedUnimplementedETCMappingServiceServer()
}

// UnimplementedETCMappingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedETCMappingServiceServer struct{}

func (UnimplementedETCMappingServiceServer) CreateMapping(context.Context, *CreateMappingRequest) (*MappingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMapping not implemented")
}
func (UnimplementedETCMappingServiceServer) GetMapping(context.Context, *GetMappingRequest) (*MappingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMapping not implemented")
}
func (UnimplementedETCMappingServiceServer) UpdateMapping(context.Context, *UpdateMappingRequest) (*MappingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMapping not implemented")
}
func (UnimplementedETCMappingServiceServer) DeleteMapping(context.Context, *DeleteMappingRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMapping not implemented")
}
func (UnimplementedETCMappingServiceServer) ListMappings(context.Context, *ListMappingsRequest) (*ListMappingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMappings not implemented")
}
func (UnimplementedETCMappingServiceServer) FindPotentialMatches(context.Context, *FindPotentialMatchesRequest) (*FindPotentialMatchesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindPotentialMatches not implemented")
}
func (UnimplementedETCMappingServiceServer) CreateAutoMappings(context.Context, *CreateAutoMappingsRequest) (*CreateAutoMappingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAutoMappings not implemented")
}
func (UnimplementedETCMappingServiceServer) mustEmbedUnimplementedETCMappingServiceServer() {}
func (UnimplementedETCMappingServiceServer) testEmbeddedByValue()                           {}

// UnsafeETCMappingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ETCMappingServiceServer will
// result in compilation errors.
type UnsafeETCMappingServiceServer interface {
	mustEmbedUnimplementedETCMappingServiceServer()
}

func RegisterETCMappingServiceServer(s grpc.ServiceRegistrar, srv ETCMappingServiceServer) {
	// If the following call pancis, it indicates UnimplementedETCMappingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ETCMappingService_ServiceDesc, srv)
}

func _ETCMappingService_CreateMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCMappingServiceServer).CreateMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCMappingService_CreateMapping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCMappingServiceServer).CreateMapping(ctx, req.(*CreateMappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCMappingService_GetMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCMappingServiceServer).GetMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCMappingService_GetMapping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCMappingServiceServer).GetMapping(ctx, req.(*GetMappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCMappingService_UpdateMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCMappingServiceServer).UpdateMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCMappingService_UpdateMapping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCMappingServiceServer).UpdateMapping(ctx, req.(*UpdateMappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCMappingService_DeleteMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCMappingServiceServer).DeleteMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCMappingService_DeleteMapping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCMappingServiceServer).DeleteMapping(ctx, req.(*DeleteMappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCMappingService_ListMappings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMappingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCMappingServiceServer).ListMappings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCMappingService_ListMappings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCMappingServiceServer).ListMappings(ctx, req.(*ListMappingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCMappingService_FindPotentialMatches_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindPotentialMatchesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCMappingServiceServer).FindPotentialMatches(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCMappingService_FindPotentialMatches_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCMappingServiceServer).FindPotentialMatches(ctx, req.(*FindPotentialMatchesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCMappingService_CreateAutoMappings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAutoMappingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCMappingServiceServer).CreateAutoMappings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCMappingService_CreateAutoMappings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCMappingServiceServer).CreateAutoMappings(ctx, req.(*CreateAutoMappingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ETCMappingService_ServiceDesc is the grpc.ServiceDesc for ETCMappingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ETCMappingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "etc_service.ETCMappingService",
	HandlerType: (*ETCMappingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMapping",
			Handler:    _ETCMappingService_CreateMapping_Handler,
		},
		{
			MethodName: "GetMapping",
			Handler:    _ETCMappingService_GetMapping_Handler,
		},
		{
			MethodName: "UpdateMapping",
			Handler:    _ETCMappingService_UpdateMapping_Handler,
		},
		{
			MethodName: "DeleteMapping",
			Handler:    _ETCMappingService_DeleteMapping_Handler,
		},
		{
			MethodName: "ListMappings",
			Handler:    _ETCMappingService_ListMappings_Handler,
		},
		{
			MethodName: "FindPotentialMatches",
			Handler:    _ETCMappingService_FindPotentialMatches_Handler,
		},
		{
			MethodName: "CreateAutoMappings",
			Handler:    _ETCMappingService_CreateAutoMappings_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "specs/001-db-service-integration/contracts/grpc_service.proto",
}

const (
	ETCImportService_CreateImportBatch_FullMethodName = "/etc_service.ETCImportService/CreateImportBatch"
	ETCImportService_GetImportBatch_FullMethodName    = "/etc_service.ETCImportService/GetImportBatch"
	ETCImportService_UpdateBatchStatus_FullMethodName = "/etc_service.ETCImportService/UpdateBatchStatus"
	ETCImportService_ProcessCSVData_FullMethodName    = "/etc_service.ETCImportService/ProcessCSVData"
	ETCImportService_GetImportProgress_FullMethodName = "/etc_service.ETCImportService/GetImportProgress"
	ETCImportService_CancelImport_FullMethodName      = "/etc_service.ETCImportService/CancelImport"
)

// ETCImportServiceClient is the client API for ETCImportService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Import service for batch processing
type ETCImportServiceClient interface {
	// Batch management
	CreateImportBatch(ctx context.Context, in *CreateImportBatchRequest, opts ...grpc.CallOption) (*ImportBatchResponse, error)
	GetImportBatch(ctx context.Context, in *GetImportBatchRequest, opts ...grpc.CallOption) (*ImportBatchResponse, error)
	UpdateBatchStatus(ctx context.Context, in *UpdateBatchStatusRequest, opts ...grpc.CallOption) (*ImportBatchResponse, error)
	// Import operations
	ProcessCSVData(ctx context.Context, in *ProcessCSVDataRequest, opts ...grpc.CallOption) (*ProcessCSVDataResponse, error)
	GetImportProgress(ctx context.Context, in *GetImportProgressRequest, opts ...grpc.CallOption) (*ImportProgressResponse, error)
	CancelImport(ctx context.Context, in *CancelImportRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type eTCImportServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewETCImportServiceClient(cc grpc.ClientConnInterface) ETCImportServiceClient {
	return &eTCImportServiceClient{cc}
}

func (c *eTCImportServiceClient) CreateImportBatch(ctx context.Context, in *CreateImportBatchRequest, opts ...grpc.CallOption) (*ImportBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportBatchResponse)
	err := c.cc.Invoke(ctx, ETCImportService_CreateImportBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCImportServiceClient) GetImportBatch(ctx context.Context, in *GetImportBatchRequest, opts ...grpc.CallOption) (*ImportBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportBatchResponse)
	err := c.cc.Invoke(ctx, ETCImportService_GetImportBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCImportServiceClient) UpdateBatchStatus(ctx context.Context, in *UpdateBatchStatusRequest, opts ...grpc.CallOption) (*ImportBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportBatchResponse)
	err := c.cc.Invoke(ctx, ETCImportService_UpdateBatchStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCImportServiceClient) ProcessCSVData(ctx context.Context, in *ProcessCSVDataRequest, opts ...grpc.CallOption) (*ProcessCSVDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessCSVDataResponse)
	err := c.cc.Invoke(ctx, ETCImportService_ProcessCSVData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCImportServiceClient) GetImportProgress(ctx context.Context, in *GetImportProgressRequest, opts ...grpc.CallOption) (*ImportProgressResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportProgressResponse)
	err := c.cc.Invoke(ctx, ETCImportService_GetImportProgress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eTCImportServiceClient) CancelImport(ctx context.Context, in *CancelImportRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ETCImportService_CancelImport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ETCImportServiceServer is the server API for ETCImportService service.
// All implementations must embed UnimplementedETCImportServiceServer
// for forward compatibility.
//
// Import service for batch processing
type ETCImportServiceServer interface {
	// Batch management
	CreateImportBatch(context.Context, *CreateImportBatchRequest) (*ImportBatchResponse, error)
	GetImportBatch(context.Context, *GetImportBatchRequest) (*ImportBatchResponse, error)
	UpdateBatchStatus(context.Context, *UpdateBatchStatusRequest) (*ImportBatchResponse, error)
	// Import operations
	ProcessCSVData(context.Context, *ProcessCSVDataRequest) (*ProcessCSVDataResponse, error)
	GetImportProgress(context.Context, *GetImportProgressRequest) (*ImportProgressResponse, error)
	CancelImport(context.Context, *CancelImportRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedETCImportServiceServer()
}

// UnimplementedETCImportServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedETCImportServiceServer struct{}

func (UnimplementedETCImportServiceServer) CreateImportBatch(context.Context, *CreateImportBatchRequest) (*ImportBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateImportBatch not implemented")
}
func (UnimplementedETCImportServiceServer) GetImportBatch(context.Context, *GetImportBatchRequest) (*ImportBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImportBatch not implemented")
}
func (UnimplementedETCImportServiceServer) UpdateBatchStatus(context.Context, *UpdateBatchStatusRequest) (*ImportBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBatchStatus not implemented")
}
func (UnimplementedETCImportServiceServer) ProcessCSVData(context.Context, *ProcessCSVDataRequest) (*ProcessCSVDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessCSVData not implemented")
}
func (UnimplementedETCImportServiceServer) GetImportProgress(context.Context, *GetImportProgressRequest) (*ImportProgressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImportProgress not implemented")
}
func (UnimplementedETCImportServiceServer) CancelImport(context.Context, *CancelImportRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelImport not implemented")
}
func (UnimplementedETCImportServiceServer) mustEmbedUnimplementedETCImportServiceServer() {}
func (UnimplementedETCImportServiceServer) testEmbeddedByValue()                          {}

// UnsafeETCImportServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ETCImportServiceServer will
// result in compilation errors.
type UnsafeETCImportServiceServer interface {
	mustEmbedUnimplementedETCImportServiceServer()
}

func RegisterETCImportServiceServer(s grpc.ServiceRegistrar, srv ETCImportServiceServer) {
	// If the following call pancis, it indicates UnimplementedETCImportServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ETCImportService_ServiceDesc, srv)
}

func _ETCImportService_CreateImportBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateImportBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCImportServiceServer).CreateImportBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCImportService_CreateImportBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCImportServiceServer).CreateImportBatch(ctx, req.(*CreateImportBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCImportService_GetImportBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetImportBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCImportServiceServer).GetImportBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCImportService_GetImportBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCImportServiceServer).GetImportBatch(ctx, req.(*GetImportBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCImportService_UpdateBatchStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBatchStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCImportServiceServer).UpdateBatchStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCImportService_UpdateBatchStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCImportServiceServer).UpdateBatchStatus(ctx, req.(*UpdateBatchStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCImportService_ProcessCSVData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessCSVDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCImportServiceServer).ProcessCSVData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCImportService_ProcessCSVData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCImportServiceServer).ProcessCSVData(ctx, req.(*ProcessCSVDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCImportService_GetImportProgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetImportProgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCImportServiceServer).GetImportProgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCImportService_GetImportProgress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCImportServiceServer).GetImportProgress(ctx, req.(*GetImportProgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ETCImportService_CancelImport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelImportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ETCImportServiceServer).CancelImport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ETCImportService_CancelImport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ETCImportServiceServer).CancelImport(ctx, req.(*CancelImportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ETCImportService_ServiceDesc is the grpc.ServiceDesc for ETCImportService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ETCImportService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "etc_service.ETCImportService",
	HandlerType: (*ETCImportServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateImportBatch",
			Handler:    _ETCImportService_CreateImportBatch_Handler,
		},
		{
			MethodName: "GetImportBatch",
			Handler:    _ETCImportService_GetImportBatch_Handler,
		},
		{
			MethodName: "UpdateBatchStatus",
			Handler:    _ETCImportService_UpdateBatchStatus_Handler,
		},
		{
			MethodName: "ProcessCSVData",
			Handler:    _ETCImportService_ProcessCSVData_Handler,
		},
		{
			MethodName: "GetImportProgress",
			Handler:    _ETCImportService_GetImportProgress_Handler,
		},
		{
			MethodName: "CancelImport",
			Handler:    _ETCImportService_CancelImport_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "specs/001-db-service-integration/contracts/grpc_service.proto",
}
