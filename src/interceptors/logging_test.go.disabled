package interceptors_test

import (
	"context"
	"errors"
	"log/slog"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"
	"github.com/yhonda-ohishi/etc_meisai/src/interceptors"
)

func TestNewLoggingConfig(t *testing.T) {
	t.Parallel()

	config := interceptors.NewLoggingConfig()

	assert.NotNil(t, config)
	assert.NotNil(t, config.Logger)
	assert.False(t, config.LogPayloads)
	assert.Equal(t, 1024, config.MaxPayloadSize)
}

func TestLoggingInterceptor_UnaryInterceptor(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name          string
		fullMethod    string
		request       interface{}
		response      interface{}
		responseError error
		expectLogs    []string
		config        interceptors.LoggingConfig
	}{
		{
			name:       "successful request with full logging",
			fullMethod: "/TestService/TestMethod",
			request:    map[string]string{"test": "data"},
			response:   map[string]string{"result": "success"},
			config: interceptors.LoggingConfig{
				LogRequests:  true,
				LogResponses: true,
				LogLevel:     "info",
			},
			expectLogs: []string{
				"gRPC Request",
				"/TestService/TestMethod",
				"gRPC Response",
				"duration",
			},
		},
		{
			name:          "request with error",
			fullMethod:    "/TestService/ErrorMethod",
			request:       map[string]string{"test": "data"},
			responseError: status.Error(codes.InvalidArgument, "invalid input"),
			config: interceptors.LoggingConfig{
				LogRequests: true,
				LogErrors:   true,
				LogLevel:    "error",
			},
			expectLogs: []string{
				"gRPC Request",
				"gRPC Error",
				"InvalidArgument",
				"invalid input",
			},
		},
		{
			name:       "request only logging",
			fullMethod: "/TestService/RequestOnlyMethod",
			request:    map[string]string{"test": "data"},
			response:   "success",
			config: interceptors.LoggingConfig{
				LogRequests:  true,
				LogResponses: false,
				LogLevel:     "info",
			},
			expectLogs: []string{
				"gRPC Request",
				"/TestService/RequestOnlyMethod",
			},
		},
		{
			name:       "response only logging",
			fullMethod: "/TestService/ResponseOnlyMethod",
			request:    map[string]string{"test": "data"},
			response:   "success",
			config: interceptors.LoggingConfig{
				LogRequests:  false,
				LogResponses: true,
				LogLevel:     "info",
			},
			expectLogs: []string{
				"gRPC Response",
				"duration",
			},
		},
		{
			name:       "disabled logging",
			fullMethod: "/TestService/NoLogMethod",
			request:    map[string]string{"test": "data"},
			response:   "success",
			config: interceptors.LoggingConfig{
				LogRequests:  false,
				LogResponses: false,
				LogLevel:     "none",
			},
			expectLogs: []string{}, // No logs expected
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var logBuffer bytes.Buffer
			logger := log.New(&logBuffer, "", 0)
			interceptor := interceptors.NewLoggingInterceptor(logger, tt.config)

			ctx := context.Background()
			if tt.fullMethod != "" {
				ctx = metadata.NewIncomingContext(ctx, metadata.Pairs(
					"request-id", "test-request-123",
					"user-agent", "grpc-test-client",
				))
			}

			info := &grpc.UnaryServerInfo{
				FullMethod: tt.fullMethod,
			}

			handler := func(ctx context.Context, req interface{}) (interface{}, error) {
				if tt.responseError != nil {
					return nil, tt.responseError
				}
				return tt.response, nil
			}

			start := time.Now()
			resp, err := interceptor.UnaryInterceptor(ctx, tt.request, info, handler)
			duration := time.Since(start)

			if tt.responseError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.responseError, err)
			} else {
				assert.NoError(t, err)
				assert.Equal(t, tt.response, resp)
			}

			logOutput := logBuffer.String()
			for _, expectedLog := range tt.expectLogs {
				assert.Contains(t, logOutput, expectedLog, "Expected log: %s", expectedLog)
			}

			// Verify duration is reasonable
			if strings.Contains(logOutput, "duration") {
				assert.True(t, duration < time.Second, "Request should complete quickly in test")
			}
		})
	}
}

func TestLoggingInterceptor_StreamInterceptor(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name        string
		fullMethod  string
		streamError error
		expectLogs  []string
		config      interceptors.LoggingConfig
	}{
		{
			name:       "successful stream with logging",
			fullMethod: "/TestService/TestStreamMethod",
			config: interceptors.LoggingConfig{
				LogRequests:  true,
				LogResponses: true,
				LogLevel:     "info",
			},
			expectLogs: []string{
				"gRPC Stream Started",
				"/TestService/TestStreamMethod",
				"gRPC Stream Completed",
			},
		},
		{
			name:        "stream with error",
			fullMethod:  "/TestService/ErrorStreamMethod",
			streamError: status.Error(codes.Internal, "stream error"),
			config: interceptors.LoggingConfig{
				LogRequests: true,
				LogErrors:   true,
				LogLevel:    "error",
			},
			expectLogs: []string{
				"gRPC Stream Started",
				"gRPC Stream Error",
				"Internal",
				"stream error",
			},
		},
		{
			name:       "stream with minimal logging",
			fullMethod: "/TestService/MinimalStreamMethod",
			config: interceptors.LoggingConfig{
				LogRequests:  false,
				LogResponses: false,
				LogLevel:     "warn",
			},
			expectLogs: []string{}, // Minimal logs
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var logBuffer bytes.Buffer
			logger := log.New(&logBuffer, "", 0)
			interceptor := interceptors.NewLoggingInterceptor(logger, tt.config)

			ctx := metadata.NewIncomingContext(context.Background(), metadata.Pairs(
				"request-id", "stream-request-456",
			))

			info := &grpc.StreamServerInfo{
				FullMethod:     tt.fullMethod,
				IsClientStream: false,
				IsServerStream: true,
			}

			mockStream := &MockServerStream{ctx: ctx}
			handler := func(srv interface{}, stream grpc.ServerStream) error {
				return tt.streamError
			}

			err := interceptor.StreamInterceptor(nil, mockStream, info, handler)

			if tt.streamError != nil {
				assert.Error(t, err)
				assert.Equal(t, tt.streamError, err)
			} else {
				assert.NoError(t, err)
			}

			logOutput := logBuffer.String()
			for _, expectedLog := range tt.expectLogs {
				assert.Contains(t, logOutput, expectedLog, "Expected log: %s", expectedLog)
			}
		})
	}
}

func TestLoggingInterceptor_RequestIDExtraction(t *testing.T) {
	t.Parallel()

	var logBuffer bytes.Buffer
	logger := log.New(&logBuffer, "", 0)
	config := interceptors.LoggingConfig{
		LogRequests: true,
		LogLevel:    "info",
	}
	interceptor := interceptors.NewLoggingInterceptor(logger, config)

	tests := []struct {
		name      string
		metadata  metadata.MD
		expectID  bool
		requestID string
	}{
		{
			name: "request ID in metadata",
			metadata: metadata.Pairs(
				"request-id", "req-12345",
				"x-request-id", "x-req-67890",
			),
			expectID:  true,
			requestID: "req-12345", // First one should be used
		},
		{
			name: "x-request-id only",
			metadata: metadata.Pairs(
				"x-request-id", "x-req-67890",
			),
			expectID:  true,
			requestID: "x-req-67890",
		},
		{
			name:     "no request ID",
			metadata: metadata.MD{},
			expectID: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			logBuffer.Reset()

			ctx := metadata.NewIncomingContext(context.Background(), tt.metadata)
			info := &grpc.UnaryServerInfo{
				FullMethod: "/TestService/TestMethod",
			}

			handler := func(ctx context.Context, req interface{}) (interface{}, error) {
				return "success", nil
			}

			_, err := interceptor.UnaryInterceptor(ctx, nil, info, handler)
			assert.NoError(t, err)

			logOutput := logBuffer.String()
			if tt.expectID {
				assert.Contains(t, logOutput, tt.requestID)
			}
		})
	}
}

func TestLoggingInterceptor_PayloadSanitization(t *testing.T) {
	t.Parallel()

	var logBuffer bytes.Buffer
	logger := log.New(&logBuffer, "", 0)
	config := interceptors.LoggingConfig{
		LogRequests:  true,
		LogResponses: true,
		LogLevel:     "info",
		SensitiveFields: []string{"password", "token", "secret"},
	}
	interceptor := interceptors.NewLoggingInterceptor(logger, config)

	tests := []struct {
		name    string
		request interface{}
		expectSanitized bool
	}{
		{
			name: "request with sensitive data",
			request: map[string]interface{}{
				"username": "testuser",
				"password": "secret123",
				"token":    "bearer-token",
				"data":     "normal-data",
			},
			expectSanitized: true,
		},
		{
			name: "request without sensitive data",
			request: map[string]interface{}{
				"username": "testuser",
				"data":     "normal-data",
			},
			expectSanitized: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			logBuffer.Reset()

			ctx := context.Background()
			info := &grpc.UnaryServerInfo{
				FullMethod: "/TestService/TestMethod",
			}

			handler := func(ctx context.Context, req interface{}) (interface{}, error) {
				return "success", nil
			}

			_, err := interceptor.UnaryInterceptor(ctx, tt.request, info, handler)
			assert.NoError(t, err)

			logOutput := logBuffer.String()
			if tt.expectSanitized {
				assert.NotContains(t, logOutput, "secret123")
				assert.NotContains(t, logOutput, "bearer-token")
				assert.Contains(t, logOutput, "[REDACTED]")
			}
		})
	}
}

func TestLoggingInterceptor_LogLevels(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name     string
		logLevel string
		hasError bool
		expectLog bool
	}{
		{
			name:      "info level with success",
			logLevel:  "info",
			hasError:  false,
			expectLog: true,
		},
		{
			name:      "error level with success",
			logLevel:  "error",
			hasError:  false,
			expectLog: false, // Should not log successful requests at error level
		},
		{
			name:      "error level with error",
			logLevel:  "error",
			hasError:  true,
			expectLog: true,
		},
		{
			name:      "debug level with success",
			logLevel:  "debug",
			hasError:  false,
			expectLog: true,
		},
		{
			name:      "none level",
			logLevel:  "none",
			hasError:  false,
			expectLog: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var logBuffer bytes.Buffer
			logger := log.New(&logBuffer, "", 0)
			config := interceptors.LoggingConfig{
				LogRequests:  true,
				LogResponses: true,
				LogErrors:    true,
				LogLevel:     tt.logLevel,
			}
			interceptor := interceptors.NewLoggingInterceptor(logger, config)

			ctx := context.Background()
			info := &grpc.UnaryServerInfo{
				FullMethod: "/TestService/TestMethod",
			}

			handler := func(ctx context.Context, req interface{}) (interface{}, error) {
				if tt.hasError {
					return nil, errors.New("test error")
				}
				return "success", nil
			}

			_, err := interceptor.UnaryInterceptor(ctx, nil, info, handler)

			if tt.hasError {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}

			logOutput := logBuffer.String()
			if tt.expectLog {
				assert.NotEmpty(t, logOutput)
			} else {
				assert.Empty(t, logOutput)
			}
		})
	}
}

func TestLoggingInterceptor_Performance(t *testing.T) {
	t.Parallel()

	var logBuffer bytes.Buffer
	logger := log.New(&logBuffer, "", 0)
	config := interceptors.LoggingConfig{
		LogRequests:  true,
		LogResponses: true,
		LogLevel:     "info",
	}
	interceptor := interceptors.NewLoggingInterceptor(logger, config)

	ctx := context.Background()
	info := &grpc.UnaryServerInfo{
		FullMethod: "/TestService/TestMethod",
	}

	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		time.Sleep(10 * time.Millisecond) // Simulate processing time
		return "success", nil
	}

	start := time.Now()
	_, err := interceptor.UnaryInterceptor(ctx, nil, info, handler)
	totalDuration := time.Since(start)

	assert.NoError(t, err)
	assert.True(t, totalDuration >= 10*time.Millisecond)
	assert.True(t, totalDuration < 100*time.Millisecond) // Logging shouldn't add much overhead

	logOutput := logBuffer.String()
	assert.Contains(t, logOutput, "duration")
}

func TestLoggingInterceptor_NilLogger(t *testing.T) {
	t.Parallel()

	config := interceptors.LoggingConfig{
		LogRequests: true,
		LogLevel:    "info",
	}
	interceptor := interceptors.NewLoggingInterceptor(nil, config)

	ctx := context.Background()
	info := &grpc.UnaryServerInfo{
		FullMethod: "/TestService/TestMethod",
	}

	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return "success", nil
	}

	// Should not panic with nil logger
	assert.NotPanics(t, func() {
		_, err := interceptor.UnaryInterceptor(ctx, nil, info, handler)
		assert.NoError(t, err)
	})
}

func TestLoggingInterceptor_LargePayload(t *testing.T) {
	t.Parallel()

	var logBuffer bytes.Buffer
	logger := log.New(&logBuffer, "", 0)
	config := interceptors.LoggingConfig{
		LogRequests:    true,
		LogResponses:   true,
		LogLevel:       "info",
		MaxPayloadSize: 100, // Limit payload size in logs
	}
	interceptor := interceptors.NewLoggingInterceptor(logger, config)

	// Create a large request
	largeData := strings.Repeat("x", 1000)
	request := map[string]string{
		"large_field": largeData,
	}

	ctx := context.Background()
	info := &grpc.UnaryServerInfo{
		FullMethod: "/TestService/TestMethod",
	}

	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return "success", nil
	}

	_, err := interceptor.UnaryInterceptor(ctx, request, info, handler)
	assert.NoError(t, err)

	logOutput := logBuffer.String()
	// Should contain truncated marker
	assert.Contains(t, logOutput, "[TRUNCATED]")
	// Should not contain the full large data
	assert.NotContains(t, logOutput, largeData)
}

// Benchmark tests
func BenchmarkLoggingInterceptor_Enabled(b *testing.B) {
	var logBuffer bytes.Buffer
	logger := log.New(&logBuffer, "", 0)
	config := interceptors.LoggingConfig{
		LogRequests:  true,
		LogResponses: true,
		LogLevel:     "info",
	}
	interceptor := interceptors.NewLoggingInterceptor(logger, config)

	ctx := context.Background()
	info := &grpc.UnaryServerInfo{
		FullMethod: "/TestService/TestMethod",
	}

	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return "success", nil
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		interceptor.UnaryInterceptor(ctx, nil, info, handler)
	}
}

func BenchmarkLoggingInterceptor_Disabled(b *testing.B) {
	var logBuffer bytes.Buffer
	logger := log.New(&logBuffer, "", 0)
	config := interceptors.LoggingConfig{
		LogRequests:  false,
		LogResponses: false,
		LogLevel:     "none",
	}
	interceptor := interceptors.NewLoggingInterceptor(logger, config)

	ctx := context.Background()
	info := &grpc.UnaryServerInfo{
		FullMethod: "/TestService/TestMethod",
	}

	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return "success", nil
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		interceptor.UnaryInterceptor(ctx, nil, info, handler)
	}
}