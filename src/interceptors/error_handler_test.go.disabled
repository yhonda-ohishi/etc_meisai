package interceptors_test

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"log"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"
	"github.com/yhonda-ohishi/etc_meisai/src/interceptors"
)

func TestNewErrorHandlerInterceptor(t *testing.T) {
	t.Parallel()

	var logBuffer bytes.Buffer
	logger := log.New(&logBuffer, "", 0)
	config := interceptors.ErrorHandlerConfig{
		LogErrors:       true,
		IncludeDetails:  true,
		SanitizeDetails: true,
	}

	interceptor := interceptors.NewErrorHandlerInterceptor(logger, config)

	assert.NotNil(t, interceptor)
}

func TestErrorHandlerInterceptor_UnaryInterceptor(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name           string
		handlerError   error
		expectedCode   codes.Code
		expectedMsg    string
		expectPanic    bool
		expectLog      bool
		config         interceptors.ErrorHandlerConfig
	}{
		{
			name:         "no error",
			handlerError: nil,
			expectedCode: codes.OK,
			expectLog:    false,
			config: interceptors.ErrorHandlerConfig{
				LogErrors: true,
			},
		},
		{
			name:         "gRPC status error",
			handlerError: status.Error(codes.InvalidArgument, "invalid input"),
			expectedCode: codes.InvalidArgument,
			expectedMsg:  "invalid input",
			expectLog:    true,
			config: interceptors.ErrorHandlerConfig{
				LogErrors: true,
			},
		},
		{
			name:         "generic error",
			handlerError: errors.New("generic error"),
			expectedCode: codes.Internal,
			expectedMsg:  "generic error",
			expectLog:    true,
			config: interceptors.ErrorHandlerConfig{
				LogErrors: true,
			},
		},
		{
			name:         "context deadline exceeded",
			handlerError: context.DeadlineExceeded,
			expectedCode: codes.DeadlineExceeded,
			expectedMsg:  "context deadline exceeded",
			expectLog:    true,
			config: interceptors.ErrorHandlerConfig{
				LogErrors: true,
			},
		},
		{
			name:         "context canceled",
			handlerError: context.Canceled,
			expectedCode: codes.Canceled,
			expectedMsg:  "context canceled",
			expectLog:    true,
			config: interceptors.ErrorHandlerConfig{
				LogErrors: true,
			},
		},
		{
			name:        "panic recovery",
			expectPanic: true,
			expectedCode: codes.Internal,
			expectedMsg: "Internal server error",
			expectLog:   true,
			config: interceptors.ErrorHandlerConfig{
				LogErrors:     true,
				RecoverPanics: true,
			},
		},
		{
			name:         "error without logging",
			handlerError: errors.New("test error"),
			expectedCode: codes.Internal,
			expectedMsg:  "test error",
			expectLog:    false,
			config: interceptors.ErrorHandlerConfig{
				LogErrors: false,
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var logBuffer bytes.Buffer
			logger := log.New(&logBuffer, "", 0)
			interceptor := interceptors.NewErrorHandlerInterceptor(logger, tt.config)

			ctx := metadata.NewIncomingContext(context.Background(), metadata.Pairs(
				"request-id", "test-request-123",
			))
			info := &grpc.UnaryServerInfo{
				FullMethod: "/TestService/TestMethod",
			}

			handler := func(ctx context.Context, req interface{}) (interface{}, error) {
				if tt.expectPanic {
					panic("test panic")
				}
				if tt.handlerError != nil {
					return nil, tt.handlerError
				}
				return "success", nil
			}

			resp, err := interceptor.UnaryInterceptor(ctx, nil, info, handler)

			if tt.handlerError != nil || tt.expectPanic {
				assert.Error(t, err)
				st, ok := status.FromError(err)
				assert.True(t, ok)
				assert.Equal(t, tt.expectedCode, st.Code())
				if tt.expectedMsg != "" {
					assert.Contains(t, st.Message(), tt.expectedMsg)
				}
			} else {
				assert.NoError(t, err)
				assert.Equal(t, "success", resp)
			}

			logOutput := logBuffer.String()
			if tt.expectLog {
				assert.NotEmpty(t, logOutput)
				if tt.expectPanic {
					assert.Contains(t, logOutput, "Panic recovered")
				}
			} else {
				assert.Empty(t, logOutput)
			}
		})
	}
}

func TestErrorHandlerInterceptor_StreamInterceptor(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name           string
		handlerError   error
		expectedCode   codes.Code
		expectPanic    bool
		expectLog      bool
		config         interceptors.ErrorHandlerConfig
	}{
		{
			name:         "successful stream",
			handlerError: nil,
			expectedCode: codes.OK,
			expectLog:    false,
			config: interceptors.ErrorHandlerConfig{
				LogErrors: true,
			},
		},
		{
			name:         "stream error",
			handlerError: status.Error(codes.NotFound, "stream not found"),
			expectedCode: codes.NotFound,
			expectLog:    true,
			config: interceptors.ErrorHandlerConfig{
				LogErrors: true,
			},
		},
		{
			name:        "stream panic",
			expectPanic: true,
			expectedCode: codes.Internal,
			expectLog:   true,
			config: interceptors.ErrorHandlerConfig{
				LogErrors:     true,
				RecoverPanics: true,
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var logBuffer bytes.Buffer
			logger := log.New(&logBuffer, "", 0)
			interceptor := interceptors.NewErrorHandlerInterceptor(logger, tt.config)

			ctx := metadata.NewIncomingContext(context.Background(), metadata.Pairs(
				"request-id", "stream-request-456",
			))

			info := &grpc.StreamServerInfo{
				FullMethod:     "/TestService/TestStreamMethod",
				IsClientStream: false,
				IsServerStream: true,
			}

			mockStream := &MockServerStream{ctx: ctx}
			handler := func(srv interface{}, stream grpc.ServerStream) error {
				if tt.expectPanic {
					panic("stream panic")
				}
				return tt.handlerError
			}

			err := interceptor.StreamInterceptor(nil, mockStream, info, handler)

			if tt.handlerError != nil || tt.expectPanic {
				assert.Error(t, err)
				st, ok := status.FromError(err)
				assert.True(t, ok)
				assert.Equal(t, tt.expectedCode, st.Code())
			} else {
				assert.NoError(t, err)
			}

			logOutput := logBuffer.String()
			if tt.expectLog {
				assert.NotEmpty(t, logOutput)
				if tt.expectPanic {
					assert.Contains(t, logOutput, "Panic recovered")
				}
			} else {
				assert.Empty(t, logOutput)
			}
		})
	}
}

func TestErrorHandlerInterceptor_PanicRecovery(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name        string
		panicValue  interface{}
		expectedMsg string
	}{
		{
			name:        "string panic",
			panicValue:  "string panic message",
			expectedMsg: "string panic message",
		},
		{
			name:        "error panic",
			panicValue:  errors.New("error panic"),
			expectedMsg: "error panic",
		},
		{
			name:        "integer panic",
			panicValue:  42,
			expectedMsg: "42",
		},
		{
			name:        "nil panic",
			panicValue:  nil,
			expectedMsg: "unknown panic",
		},
		{
			name:        "complex panic",
			panicValue:  map[string]string{"error": "complex"},
			expectedMsg: "map[error:complex]",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var logBuffer bytes.Buffer
			logger := log.New(&logBuffer, "", 0)
			config := interceptors.ErrorHandlerConfig{
				LogErrors:     true,
				RecoverPanics: true,
			}
			interceptor := interceptors.NewErrorHandlerInterceptor(logger, config)

			ctx := context.Background()
			info := &grpc.UnaryServerInfo{
				FullMethod: "/TestService/TestMethod",
			}

			handler := func(ctx context.Context, req interface{}) (interface{}, error) {
				panic(tt.panicValue)
			}

			resp, err := interceptor.UnaryInterceptor(ctx, nil, info, handler)

			assert.Nil(t, resp)
			assert.Error(t, err)

			st, ok := status.FromError(err)
			assert.True(t, ok)
			assert.Equal(t, codes.Internal, st.Code())

			logOutput := logBuffer.String()
			assert.Contains(t, logOutput, "Panic recovered")
			assert.Contains(t, logOutput, tt.expectedMsg)
		})
	}
}

func TestErrorHandlerInterceptor_ErrorSanitization(t *testing.T) {
	t.Parallel()

	tests := []struct {
		name           string
		error          error
		config         interceptors.ErrorHandlerConfig
		expectSanitized bool
		expectedMsg    string
	}{
		{
			name:  "sensitive error with sanitization",
			error: errors.New("database connection failed: password=secret123"),
			config: interceptors.ErrorHandlerConfig{
				SanitizeDetails: true,
				SensitiveWords:  []string{"password", "token", "secret"},
			},
			expectSanitized: true,
			expectedMsg:     "Internal server error",
		},
		{
			name:  "sensitive error without sanitization",
			error: errors.New("database connection failed: password=secret123"),
			config: interceptors.ErrorHandlerConfig{
				SanitizeDetails: false,
			},
			expectSanitized: false,
			expectedMsg:     "database connection failed: password=secret123",
		},
		{
			name:  "non-sensitive error",
			error: errors.New("validation failed: invalid email format"),
			config: interceptors.ErrorHandlerConfig{
				SanitizeDetails: true,
				SensitiveWords:  []string{"password", "token", "secret"},
			},
			expectSanitized: false,
			expectedMsg:     "validation failed: invalid email format",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var logBuffer bytes.Buffer
			logger := log.New(&logBuffer, "", 0)
			tt.config.LogErrors = true
			interceptor := interceptors.NewErrorHandlerInterceptor(logger, tt.config)

			ctx := context.Background()
			info := &grpc.UnaryServerInfo{
				FullMethod: "/TestService/TestMethod",
			}

			handler := func(ctx context.Context, req interface{}) (interface{}, error) {
				return nil, tt.error
			}

			_, err := interceptor.UnaryInterceptor(ctx, nil, info, handler)

			assert.Error(t, err)
			st, ok := status.FromError(err)
			assert.True(t, ok)
			assert.Contains(t, st.Message(), tt.expectedMsg)
		})
	}
}

func TestErrorHandlerInterceptor_RequestIDPropagation(t *testing.T) {
	t.Parallel()

	var logBuffer bytes.Buffer
	logger := log.New(&logBuffer, "", 0)
	config := interceptors.ErrorHandlerConfig{
		LogErrors:      true,
		IncludeDetails: true,
	}
	interceptor := interceptors.NewErrorHandlerInterceptor(logger, config)

	tests := []struct {
		name      string
		metadata  metadata.MD
		expectID  string
	}{
		{
			name: "request ID in standard header",
			metadata: metadata.Pairs(
				"request-id", "req-12345",
			),
			expectID: "req-12345",
		},
		{
			name: "request ID in x-request-id header",
			metadata: metadata.Pairs(
				"x-request-id", "x-req-67890",
			),
			expectID: "x-req-67890",
		},
		{
			name: "multiple request ID headers",
			metadata: metadata.Pairs(
				"request-id", "req-first",
				"x-request-id", "req-second",
			),
			expectID: "req-first", // Should use the first one
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			logBuffer.Reset()

			ctx := metadata.NewIncomingContext(context.Background(), tt.metadata)
			info := &grpc.UnaryServerInfo{
				FullMethod: "/TestService/TestMethod",
			}

			handler := func(ctx context.Context, req interface{}) (interface{}, error) {
				return nil, errors.New("test error")
			}

			_, err := interceptor.UnaryInterceptor(ctx, nil, info, handler)

			assert.Error(t, err)

			logOutput := logBuffer.String()
			assert.Contains(t, logOutput, tt.expectID)
		})
	}
}

func TestErrorHandlerInterceptor_StackTrace(t *testing.T) {
	t.Parallel()

	var logBuffer bytes.Buffer
	logger := log.New(&logBuffer, "", 0)
	config := interceptors.ErrorHandlerConfig{
		LogErrors:        true,
		IncludeStackTrace: true,
	}
	interceptor := interceptors.NewErrorHandlerInterceptor(logger, config)

	ctx := context.Background()
	info := &grpc.UnaryServerInfo{
		FullMethod: "/TestService/TestMethod",
	}

	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		panic("test panic for stack trace")
	}

	_, err := interceptor.UnaryInterceptor(ctx, nil, info, handler)

	assert.Error(t, err)

	logOutput := logBuffer.String()
	assert.Contains(t, logOutput, "Stack trace:")
	assert.Contains(t, logOutput, "goroutine")
}

func TestErrorHandlerInterceptor_CustomErrorHandler(t *testing.T) {
	t.Parallel()

	var logBuffer bytes.Buffer
	logger := log.New(&logBuffer, "", 0)

	customHandler := func(err error, ctx context.Context, fullMethod string) error {
		if strings.Contains(err.Error(), "custom") {
			return status.Error(codes.FailedPrecondition, "custom handling applied")
		}
		return err
	}

	config := interceptors.ErrorHandlerConfig{
		LogErrors:      true,
		CustomHandler:  customHandler,
	}
	interceptor := interceptors.NewErrorHandlerInterceptor(logger, config)

	tests := []struct {
		name         string
		error        error
		expectedCode codes.Code
		expectedMsg  string
	}{
		{
			name:         "custom error handling",
			error:        errors.New("custom error message"),
			expectedCode: codes.FailedPrecondition,
			expectedMsg:  "custom handling applied",
		},
		{
			name:         "non-custom error",
			error:        errors.New("regular error"),
			expectedCode: codes.Internal,
			expectedMsg:  "regular error",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctx := context.Background()
			info := &grpc.UnaryServerInfo{
				FullMethod: "/TestService/TestMethod",
			}

			handler := func(ctx context.Context, req interface{}) (interface{}, error) {
				return nil, tt.error
			}

			_, err := interceptor.UnaryInterceptor(ctx, nil, info, handler)

			assert.Error(t, err)
			st, ok := status.FromError(err)
			assert.True(t, ok)
			assert.Equal(t, tt.expectedCode, st.Code())
			assert.Contains(t, st.Message(), tt.expectedMsg)
		})
	}
}

func TestErrorHandlerInterceptor_NilLogger(t *testing.T) {
	t.Parallel()

	config := interceptors.ErrorHandlerConfig{
		LogErrors: true,
	}
	interceptor := interceptors.NewErrorHandlerInterceptor(nil, config)

	ctx := context.Background()
	info := &grpc.UnaryServerInfo{
		FullMethod: "/TestService/TestMethod",
	}

	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return nil, errors.New("test error")
	}

	// Should not panic with nil logger
	assert.NotPanics(t, func() {
		_, err := interceptor.UnaryInterceptor(ctx, nil, info, handler)
		assert.Error(t, err)
	})
}

func TestErrorHandlerInterceptor_ConcurrentPanics(t *testing.T) {
	t.Parallel()

	var logBuffer bytes.Buffer
	logger := log.New(&logBuffer, "", 0)
	config := interceptors.ErrorHandlerConfig{
		LogErrors:     true,
		RecoverPanics: true,
	}
	interceptor := interceptors.NewErrorHandlerInterceptor(logger, config)

	ctx := context.Background()
	info := &grpc.UnaryServerInfo{
		FullMethod: "/TestService/TestMethod",
	}

	numGoroutines := 10
	done := make(chan bool, numGoroutines)
	errors := make(chan error, numGoroutines)

	for i := 0; i < numGoroutines; i++ {
		go func(id int) {
			handler := func(ctx context.Context, req interface{}) (interface{}, error) {
				panic(fmt.Sprintf("concurrent panic %d", id))
			}

			_, err := interceptor.UnaryInterceptor(ctx, nil, info, handler)
			errors <- err
			done <- true
		}(i)
	}

	// Wait for all goroutines to complete
	for i := 0; i < numGoroutines; i++ {
		<-done
		err := <-errors
		assert.Error(t, err)
		st, ok := status.FromError(err)
		assert.True(t, ok)
		assert.Equal(t, codes.Internal, st.Code())
	}

	// Verify all panics were logged
	logOutput := logBuffer.String()
	for i := 0; i < numGoroutines; i++ {
		assert.Contains(t, logOutput, fmt.Sprintf("concurrent panic %d", i))
	}
}

// Benchmark tests
func BenchmarkErrorHandlerInterceptor_NoError(b *testing.B) {
	var logBuffer bytes.Buffer
	logger := log.New(&logBuffer, "", 0)
	config := interceptors.ErrorHandlerConfig{
		LogErrors: true,
	}
	interceptor := interceptors.NewErrorHandlerInterceptor(logger, config)

	ctx := context.Background()
	info := &grpc.UnaryServerInfo{
		FullMethod: "/TestService/TestMethod",
	}

	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return "success", nil
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		interceptor.UnaryInterceptor(ctx, nil, info, handler)
	}
}

func BenchmarkErrorHandlerInterceptor_WithError(b *testing.B) {
	var logBuffer bytes.Buffer
	logger := log.New(&logBuffer, "", 0)
	config := interceptors.ErrorHandlerConfig{
		LogErrors: true,
	}
	interceptor := interceptors.NewErrorHandlerInterceptor(logger, config)

	ctx := context.Background()
	info := &grpc.UnaryServerInfo{
		FullMethod: "/TestService/TestMethod",
	}

	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return nil, errors.New("benchmark error")
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		interceptor.UnaryInterceptor(ctx, nil, info, handler)
	}
}

func BenchmarkErrorHandlerInterceptor_WithPanic(b *testing.B) {
	var logBuffer bytes.Buffer
	logger := log.New(&logBuffer, "", 0)
	config := interceptors.ErrorHandlerConfig{
		LogErrors:     true,
		RecoverPanics: true,
	}
	interceptor := interceptors.NewErrorHandlerInterceptor(logger, config)

	ctx := context.Background()
	info := &grpc.UnaryServerInfo{
		FullMethod: "/TestService/TestMethod",
	}

	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		panic("benchmark panic")
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		interceptor.UnaryInterceptor(ctx, nil, info, handler)
	}
}