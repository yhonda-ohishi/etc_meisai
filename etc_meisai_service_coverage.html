
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>services: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/yhonda-ohishi/etc_meisai/src/services/base_service.go (0.0%)</option>
				
				<option value="file1">github.com/yhonda-ohishi/etc_meisai/src/services/download_service.go (0.0%)</option>
				
				<option value="file2">github.com/yhonda-ohishi/etc_meisai/src/services/etc_mapping_service.go (0.0%)</option>
				
				<option value="file3">github.com/yhonda-ohishi/etc_meisai/src/services/etc_meisai_service.go (90.4%)</option>
				
				<option value="file4">github.com/yhonda-ohishi/etc_meisai/src/services/etc_service.go (0.0%)</option>
				
				<option value="file5">github.com/yhonda-ohishi/etc_meisai/src/services/import_service.go (0.0%)</option>
				
				<option value="file6">github.com/yhonda-ohishi/etc_meisai/src/services/import_service_legacy.go (0.0%)</option>
				
				<option value="file7">github.com/yhonda-ohishi/etc_meisai/src/services/job_service.go (0.0%)</option>
				
				<option value="file8">github.com/yhonda-ohishi/etc_meisai/src/services/logging_service.go (0.0%)</option>
				
				<option value="file9">github.com/yhonda-ohishi/etc_meisai/src/services/mapping_service.go (0.0%)</option>
				
				<option value="file10">github.com/yhonda-ohishi/etc_meisai/src/services/statistics_service.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package services

import (
        "context"
        "log"
        "sync"
        "time"

        // "github.com/yhonda-ohishi/etc_meisai/src/clients"
        "github.com/yhonda-ohishi/etc_meisai/src/repositories"
)

// BaseService provides common functionality for all services
type BaseService struct {
        // dbClient *clients.DBServiceClient // TODO: Fix after clients package is reimplemented
        dbClient          interface{} // temporary placeholder
        ETCRepository     repositories.ETCRepository
        MappingRepository repositories.MappingRepository
        Logger            *log.Logger
        mu                sync.RWMutex
}

// NewBaseService creates a new base service
func NewBaseService(dbClient interface{}) *BaseService <span class="cov0" title="0">{
        return &amp;BaseService{
                dbClient: dbClient,
                Logger:  log.New(log.Writer(), "[BaseService] ", log.LstdFlags),
        }
}</span>

// NewBaseServiceWithDependencies creates a new base service with full dependencies
func NewBaseServiceWithDependencies(dbClient interface{}, etcRepo repositories.ETCRepository, mappingRepo repositories.MappingRepository, logger *log.Logger) *BaseService <span class="cov0" title="0">{
        return &amp;BaseService{
                dbClient:          dbClient,
                ETCRepository:     etcRepo,
                MappingRepository: mappingRepo,
                Logger:            logger,
        }
}</span>

// GetDBClient returns the db_service gRPC client
// TODO: Restore when clients package is available
// func (s *BaseService) GetDBClient() *clients.DBServiceClient {
//        s.mu.RLock()
//        defer s.mu.RUnlock()
//        return s.dbClient
// }
func (s *BaseService) GetDBClient() interface{} <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.dbClient
}</span>


// HealthCheck performs a comprehensive health check
func (s *BaseService) HealthCheck(ctx context.Context) *HealthCheckResult <span class="cov0" title="0">{
        result := &amp;HealthCheckResult{
                Timestamp: time.Now(),
                Services:  make(map[string]*ServiceHealth),
        }


        // Check db_service connectivity
        // TODO: Restore when clients package is available
        // if s.dbClient != nil {
        //        grpcHealth := &amp;ServiceHealth{Name: "db_service_grpc"}
        //        if err := s.dbClient.HealthCheck(ctx); err != nil {
        //                grpcHealth.Status = "unhealthy"
        //                grpcHealth.Error = err.Error()
        //        } else {
        //                grpcHealth.Status = "healthy"
        //        }
        //        result.Services["db_service_grpc"] = grpcHealth
        // }
        if s.dbClient != nil </span><span class="cov0" title="0">{
                grpcHealth := &amp;ServiceHealth{Name: "db_service_grpc", Status: "disabled", Error: "clients package not available"}
                result.Services["db_service_grpc"] = grpcHealth
        }</span>

        // Determine overall status
        <span class="cov0" title="0">result.Status = "healthy"
        for _, service := range result.Services </span><span class="cov0" title="0">{
                if service.Status != "healthy" </span><span class="cov0" title="0">{
                        result.Status = "unhealthy"
                        break</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

// ServiceRegistry manages service instances
type ServiceRegistry struct {
        base            *BaseService
        etcService      *ETCService
        mappingService  *MappingService
        importService   *ImportServiceLegacy
        downloadService DownloadServiceInterface
        etcRepo         repositories.ETCRepository
        mappingRepo     repositories.MappingRepository
        logger          *log.Logger
        mu              sync.RWMutex
}

// ServiceFactory defines the interface for creating services
type ServiceFactory interface {
        CreateETCService() *ETCService
        CreateMappingService() *MappingService
        CreateBaseService() *BaseService
        CreateImportService() *ImportServiceLegacy
        CreateDownloadService() DownloadServiceInterface
}

// NewServiceRegistryGRPCOnly creates a service registry using only gRPC (no local database)
// TODO: Restore when clients package is available
// func NewServiceRegistryGRPCOnly(dbClient *clients.DBServiceClient, logger *log.Logger) *ServiceRegistry {
func NewServiceRegistryGRPCOnly(dbClient interface{}, logger *log.Logger) *ServiceRegistry <span class="cov0" title="0">{
        // Create gRPC-only repositories
        // TODO: Restore when clients package is available
        // etcRepo := repositories.NewGRPCRepository(dbClient)
        // mappingRepo := repositories.NewMappingGRPCRepository(dbClient)
        // Temporary placeholders
        var etcRepo repositories.ETCRepository
        var mappingRepo repositories.MappingRepository

        // Create services
        // TODO: Restore when clients package is available
        // etcService := NewETCService(etcRepo, dbClient)
        // mappingService := NewMappingService(mappingRepo, etcRepo)
        // importService := NewImportService(dbClient, etcRepo, mappingRepo)
        // Temporary placeholders
        var etcService *ETCService
        var mappingService *MappingService
        var importService *ImportServiceLegacy

        // Create base service without local DB
        base := NewBaseService(dbClient)

        return &amp;ServiceRegistry{
                base:            base,
                etcService:      etcService,
                mappingService:  mappingService,
                importService:   importService,
                downloadService: nil, // TODO: Initialize when download service is implemented
                etcRepo:         etcRepo,
                mappingRepo:     mappingRepo,
                logger:          logger,
        }
}</span>

// NewServiceRegistryWithFactory creates a service registry using a factory for dependency injection
func NewServiceRegistryWithFactory(factory ServiceFactory, etcRepo repositories.ETCRepository, mappingRepo repositories.MappingRepository, logger *log.Logger) *ServiceRegistry <span class="cov0" title="0">{
        return &amp;ServiceRegistry{
                base:            factory.CreateBaseService(),
                etcService:      factory.CreateETCService(),
                mappingService:  factory.CreateMappingService(),
                importService:   factory.CreateImportService(),
                downloadService: factory.CreateDownloadService(),
                etcRepo:         etcRepo,
                mappingRepo:     mappingRepo,
                logger:          logger,
        }
}</span>

// NewServiceRegistryWithDependencies creates a service registry with explicit dependencies (for testing)
func NewServiceRegistryWithDependencies(
        dbClient interface{},
        etcRepo repositories.ETCRepository,
        mappingRepo repositories.MappingRepository,
        logger *log.Logger,
) *ServiceRegistry <span class="cov0" title="0">{
        // Create base service with dependencies
        base := NewBaseServiceWithDependencies(dbClient, etcRepo, mappingRepo, logger)

        // Create services with repositories
        etcService := &amp;ETCService{
                repo:          etcRepo,
                dbClient:      dbClient,
                compatAdapter: nil, // Will be initialized in NewETCService
        }

        mappingService := &amp;MappingService{
                mappingRepo: mappingRepo,
                etcRepo:     etcRepo,
        }

        // ImportServiceLegacy needs proper initialization with parser
        // For now, create with nil parser (will be set later if needed)
        importService := &amp;ImportServiceLegacy{
                dbClient:    dbClient,
                etcRepo:     etcRepo,
                mappingRepo: mappingRepo,
                // parser will be nil - initialized when needed
        }

        return &amp;ServiceRegistry{
                base:            base,
                etcService:      etcService,
                mappingService:  mappingService,
                importService:   importService,
                downloadService: nil, // Will be set separately if needed
                etcRepo:         etcRepo,
                mappingRepo:     mappingRepo,
                logger:          logger,
        }
}</span>

// GetETCService returns the ETC service instance
func (r *ServiceRegistry) GetETCService() *ETCService <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return r.etcService
}</span>

// GetETCRepository returns the ETC repository instance
func (r *ServiceRegistry) GetETCRepository() repositories.ETCRepository <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return r.etcRepo
}</span>

// GetMappingService returns the mapping service instance
func (r *ServiceRegistry) GetMappingService() *MappingService <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return r.mappingService
}</span>

// GetMappingRepository returns the mapping repository instance
func (r *ServiceRegistry) GetMappingRepository() repositories.MappingRepository <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return r.mappingRepo
}</span>

// GetImportService returns the import service instance
func (r *ServiceRegistry) GetImportService() *ImportServiceLegacy <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return r.importService
}</span>

// GetBaseService returns the base service instance
func (r *ServiceRegistry) GetBaseService() *BaseService <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return r.base
}</span>

// GetDownloadService returns the download service instance
func (r *ServiceRegistry) GetDownloadService() DownloadServiceInterface <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return r.downloadService
}</span>

// HealthCheck performs health check on all services
func (r *ServiceRegistry) HealthCheck(ctx context.Context) *HealthCheckResult <span class="cov0" title="0">{
        result := r.base.HealthCheck(ctx)

        // Add ETC service health check
        if r.etcService != nil </span><span class="cov0" title="0">{
                etcHealth := &amp;ServiceHealth{Name: "etc_service"}
                if err := r.etcService.HealthCheck(ctx); err != nil </span><span class="cov0" title="0">{
                        etcHealth.Status = "unhealthy"
                        etcHealth.Error = err.Error()
                        result.Status = "unhealthy"
                }</span> else<span class="cov0" title="0"> {
                        etcHealth.Status = "healthy"
                }</span>
                <span class="cov0" title="0">result.Services["etc_service"] = etcHealth</span>
        }

        <span class="cov0" title="0">return result</span>
}

// SetDownloadService sets the download service (for testing)
func (r *ServiceRegistry) SetDownloadService(service DownloadServiceInterface) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.downloadService = service
}</span>

// HealthCheckResult represents the result of a health check
type HealthCheckResult struct {
        Status    string                    `json:"status"`
        Timestamp time.Time                 `json:"timestamp"`
        Services  map[string]*ServiceHealth `json:"services"`
}

// ServiceHealth represents the health status of a single service
type ServiceHealth struct {
        Name   string `json:"name"`
        Status string `json:"status"` // healthy, unhealthy, degraded
        Error  string `json:"error,omitempty"`
}

// IsHealthy returns true if all services are healthy
func (r *HealthCheckResult) IsHealthy() bool <span class="cov0" title="0">{
        return r.Status == "healthy"
}</span>

// GetUnhealthyServices returns a list of unhealthy services
func (r *HealthCheckResult) GetUnhealthyServices() []string <span class="cov0" title="0">{
        var unhealthy []string
        for name, service := range r.Services </span><span class="cov0" title="0">{
                if service.Status != "healthy" </span><span class="cov0" title="0">{
                        unhealthy = append(unhealthy, name)
                }</span>
        }
        <span class="cov0" title="0">return unhealthy</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package services

import (
        "database/sql"
        "fmt"
        "log"
        "os"
        "strings"
        "sync"
        "time"
)

// DownloadService はダウンロード処理を管理
type DownloadService struct {
        db       *sql.DB
        logger   *log.Logger
        jobs     map[string]*DownloadJob
        jobMutex sync.RWMutex
}

// DownloadJob はダウンロードジョブの状態
type DownloadJob struct {
        ID           string
        Status       string
        Progress     int
        TotalRecords int
        ErrorMessage string
        StartedAt    time.Time
        CompletedAt  *time.Time
}

// NewDownloadService creates a new download service
func NewDownloadService(db *sql.DB, logger *log.Logger) *DownloadService <span class="cov0" title="0">{
        return &amp;DownloadService{
                db:     db,
                logger: logger,
                jobs:   make(map[string]*DownloadJob),
        }
}</span>

// GetAllAccountIDs は設定されているすべてのアカウントIDを取得
func (s *DownloadService) GetAllAccountIDs() []string <span class="cov0" title="0">{
        var accountIDs []string

        // 法人アカウント
        corporateAccounts := os.Getenv("ETC_CORPORATE_ACCOUNTS")
        if corporateAccounts != "" </span><span class="cov0" title="0">{
                for _, accountStr := range strings.Split(corporateAccounts, ",") </span><span class="cov0" title="0">{
                        parts := strings.Split(accountStr, ":")
                        if len(parts) &gt;= 1 </span><span class="cov0" title="0">{
                                accountIDs = append(accountIDs, parts[0])
                        }</span>
                }
        }

        // 個人アカウント
        <span class="cov0" title="0">personalAccounts := os.Getenv("ETC_PERSONAL_ACCOUNTS")
        if personalAccounts != "" </span><span class="cov0" title="0">{
                for _, accountStr := range strings.Split(personalAccounts, ",") </span><span class="cov0" title="0">{
                        parts := strings.Split(accountStr, ":")
                        if len(parts) &gt;= 1 </span><span class="cov0" title="0">{
                                accountIDs = append(accountIDs, parts[0])
                        }</span>
                }
        }

        <span class="cov0" title="0">return accountIDs</span>
}

// ProcessAsync は非同期でダウンロードを実行
func (s *DownloadService) ProcessAsync(jobID string, accounts []string, fromDate, toDate string) <span class="cov0" title="0">{
        s.jobMutex.Lock()
        job := &amp;DownloadJob{
                ID:        jobID,
                Status:    "processing",
                Progress:  0,
                StartedAt: time.Now(),
        }
        s.jobs[jobID] = job
        s.jobMutex.Unlock()

        // ダウンロード処理をシミュレート
        go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                if s.logger != nil </span><span class="cov0" title="0">{
                                        s.logger.Printf("Panic in download job %s: %v", jobID, r)
                                }</span>
                                <span class="cov0" title="0">s.updateJobStatus(jobID, "failed", 0, fmt.Sprintf("Internal error: %v", r))</span>
                        }
                }()

                <span class="cov0" title="0">if s.logger != nil </span><span class="cov0" title="0">{
                        s.logger.Printf("Starting download job %s for %d accounts from %s to %s",
                                jobID, len(accounts), fromDate, toDate)
                }</span>

                // 各アカウントを処理
                <span class="cov0" title="0">totalAccounts := len(accounts)
                for i, account := range accounts </span><span class="cov0" title="0">{
                        // 進捗更新
                        progress := int(float64(i+1) / float64(totalAccounts) * 100)
                        s.updateJobProgress(jobID, progress)

                        // 実際のダウンロード処理
                        if err := s.downloadAccountData(account, fromDate, toDate); err != nil </span><span class="cov0" title="0">{
                                if s.logger != nil </span><span class="cov0" title="0">{
                                        s.logger.Printf("Error downloading data for account %s: %v", account, err)
                                }</span>
                                // エラーがあってもほかのアカウントの処理は続ける
                        }

                        // レート制限のため少し待機
                        <span class="cov0" title="0">time.Sleep(time.Second)</span>
                }

                // 完了
                <span class="cov0" title="0">now := time.Now()
                s.jobMutex.Lock()
                if job, exists := s.jobs[jobID]; exists </span><span class="cov0" title="0">{
                        job.Status = "completed"
                        job.Progress = 100
                        job.CompletedAt = &amp;now
                }</span>
                <span class="cov0" title="0">s.jobMutex.Unlock()

                if s.logger != nil </span><span class="cov0" title="0">{
                        s.logger.Printf("Completed download job %s", jobID)
                }</span>
        }()
}

// downloadAccountData は単一アカウントのデータをダウンロード
func (s *DownloadService) downloadAccountData(accountID, fromDate, toDate string) error <span class="cov0" title="0">{
        // TODO: 実際のスクレイピング処理を実装
        if s.logger != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Downloading data for account %s from %s to %s", accountID, fromDate, toDate)
        }</span>

        // シミュレーション用の待機
        <span class="cov0" title="0">time.Sleep(2 * time.Second)

        return nil</span>
}

// updateJobProgress はジョブの進捗を更新
func (s *DownloadService) updateJobProgress(jobID string, progress int) <span class="cov0" title="0">{
        s.jobMutex.Lock()
        defer s.jobMutex.Unlock()

        if job, exists := s.jobs[jobID]; exists </span><span class="cov0" title="0">{
                job.Progress = progress
        }</span>
}

// updateJobStatus はジョブのステータスを更新
func (s *DownloadService) updateJobStatus(jobID string, status string, progress int, errorMsg string) <span class="cov0" title="0">{
        s.jobMutex.Lock()
        defer s.jobMutex.Unlock()

        if job, exists := s.jobs[jobID]; exists </span><span class="cov0" title="0">{
                job.Status = status
                job.Progress = progress
                if errorMsg != "" </span><span class="cov0" title="0">{
                        job.ErrorMessage = errorMsg
                }</span>
                <span class="cov0" title="0">if status == "completed" || status == "failed" </span><span class="cov0" title="0">{
                        now := time.Now()
                        job.CompletedAt = &amp;now
                }</span>
        }
}

// GetJobStatus はジョブのステータスを取得
func (s *DownloadService) GetJobStatus(jobID string) (*DownloadJob, bool) <span class="cov0" title="0">{
        s.jobMutex.RLock()
        defer s.jobMutex.RUnlock()

        job, exists := s.jobs[jobID]
        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // コピーを返す
        <span class="cov0" title="0">jobCopy := *job
        return &amp;jobCopy, true</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package services

import (
        "context"
        "fmt"
        "log"

        "github.com/yhonda-ohishi/etc_meisai/src/models"
        "github.com/yhonda-ohishi/etc_meisai/src/repositories"
)

// CreateMappingParams contains parameters for creating an ETC mapping
type CreateMappingParams struct {
        ETCRecordID      int64                  `json:"etc_record_id" validate:"required,min=1"`
        MappingType      string                 `json:"mapping_type" validate:"required"`
        MappedEntityID   int64                  `json:"mapped_entity_id" validate:"required,min=1"`
        MappedEntityType string                 `json:"mapped_entity_type" validate:"required"`
        Confidence       float32                `json:"confidence" validate:"min=0,max=1"`
        Status           string                 `json:"status,omitempty"`
        Metadata         map[string]interface{} `json:"metadata,omitempty"`
        CreatedBy        string                 `json:"created_by,omitempty"`
}

// ListMappingsParams contains parameters for listing ETC mappings
type ListMappingsParams struct {
        Page             int     `json:"page" validate:"min=1"`
        PageSize         int     `json:"page_size" validate:"min=1,max=1000"`
        ETCRecordID      *int64  `json:"etc_record_id,omitempty"`
        MappingType      *string `json:"mapping_type,omitempty"`
        MappedEntityID   *int64  `json:"mapped_entity_id,omitempty"`
        MappedEntityType *string `json:"mapped_entity_type,omitempty"`
        Status           *string `json:"status,omitempty"`
        MinConfidence    *float32 `json:"min_confidence,omitempty"`
        MaxConfidence    *float32 `json:"max_confidence,omitempty"`
        CreatedBy        *string `json:"created_by,omitempty"`
        SortBy           string  `json:"sort_by"`     // created_at, confidence, etc_record_id
        SortOrder        string  `json:"sort_order"`  // asc, desc
}

// ListMappingsResponse contains the response for listing ETC mappings
type ListMappingsResponse struct {
        Mappings   []*models.ETCMapping `json:"mappings"`
        TotalCount int64                `json:"total_count"`
        Page       int                  `json:"page"`
        PageSize   int                  `json:"page_size"`
        TotalPages int                  `json:"total_pages"`
}

// UpdateMappingParams contains parameters for updating an ETC mapping
type UpdateMappingParams struct {
        MappingType      *string                `json:"mapping_type,omitempty"`
        MappedEntityID   *int64                 `json:"mapped_entity_id,omitempty"`
        MappedEntityType *string                `json:"mapped_entity_type,omitempty"`
        Confidence       *float32               `json:"confidence,omitempty"`
        Status           *string                `json:"status,omitempty"`
        Metadata         map[string]interface{} `json:"metadata,omitempty"`
}

// ETCMappingService handles business logic for ETC mapping management using repository pattern
type ETCMappingService struct {
        mappingRepo repositories.ETCMappingRepository
        recordRepo  repositories.ETCMeisaiRecordRepository
        logger      *log.Logger
}

// NewETCMappingService creates a new ETC mapping management service with repository pattern
func NewETCMappingService(
        mappingRepo repositories.ETCMappingRepository,
        recordRepo repositories.ETCMeisaiRecordRepository,
        logger *log.Logger,
) *ETCMappingService <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = log.New(log.Writer(), "[ETCMappingService] ", log.LstdFlags|log.Lshortfile)
        }</span>

        <span class="cov0" title="0">return &amp;ETCMappingService{
                mappingRepo: mappingRepo,
                recordRepo:  recordRepo,
                logger:      logger,
        }</span>
}

// CreateMapping creates a new ETC mapping with validation
func (s *ETCMappingService) CreateMapping(ctx context.Context, params *CreateMappingParams) (*models.ETCMapping, error) <span class="cov0" title="0">{
        if s.logger != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Creating ETC mapping for record ID: %d, entity ID: %d", params.ETCRecordID, params.MappedEntityID)
        }</span>

        // Set defaults
        <span class="cov0" title="0">if params.Confidence == 0 </span><span class="cov0" title="0">{
                params.Confidence = 1.0
        }</span>
        <span class="cov0" title="0">if params.Status == "" </span><span class="cov0" title="0">{
                params.Status = string(models.MappingStatusActive)
        }</span>

        // Create mapping model
        <span class="cov0" title="0">mapping := &amp;models.ETCMapping{
                ETCRecordID:      params.ETCRecordID,
                MappingType:      params.MappingType,
                MappedEntityID:   params.MappedEntityID,
                MappedEntityType: params.MappedEntityType,
                Confidence:       params.Confidence,
                Status:           params.Status,
                CreatedBy:        params.CreatedBy,
        }

        // Set metadata if provided
        if params.Metadata != nil </span><span class="cov0" title="0">{
                if err := mapping.SetMetadata(params.Metadata); err != nil </span><span class="cov0" title="0">{
                        s.logger.Printf("Failed to set metadata: %v", err)
                        return nil, fmt.Errorf("failed to set metadata: %w", err)
                }</span>
        }

        // Start transaction
        <span class="cov0" title="0">txRepo, err := s.mappingRepo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        txRepo.RollbackTx()
                }</span>
        }()

        // Verify ETC record exists
        <span class="cov0" title="0">_, err = s.recordRepo.GetByID(ctx, params.ETCRecordID)
        if err != nil </span><span class="cov0" title="0">{
                txRepo.RollbackTx()
                return nil, fmt.Errorf("ETC record not found with ID %d: %w", params.ETCRecordID, err)
        }</span>

        // Check for existing active mappings
        <span class="cov0" title="0">existingMapping, err := txRepo.GetActiveMapping(ctx, params.ETCRecordID)
        if err == nil &amp;&amp; existingMapping != nil </span><span class="cov0" title="0">{
                txRepo.RollbackTx()
                return nil, fmt.Errorf("active mapping already exists for ETC record %d", params.ETCRecordID)
        }</span>

        // Create the mapping
        <span class="cov0" title="0">if err := txRepo.Create(ctx, mapping); err != nil </span><span class="cov0" title="0">{
                txRepo.RollbackTx()
                s.logger.Printf("Failed to create mapping: %v", err)
                return nil, fmt.Errorf("failed to create mapping: %w", err)
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err := txRepo.CommitTx(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Successfully created ETC mapping with ID: %d", mapping.ID)
        return mapping, nil</span>
}

// GetMapping retrieves an ETC mapping by ID
func (s *ETCMappingService) GetMapping(ctx context.Context, id int64) (*models.ETCMapping, error) <span class="cov0" title="0">{
        if id &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid mapping ID: %d", id)
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Retrieving ETC mapping with ID: %d", id)

        mapping, err := s.mappingRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to retrieve mapping: %v", err)
                return nil, fmt.Errorf("failed to retrieve mapping: %w", err)
        }</span>

        <span class="cov0" title="0">return mapping, nil</span>
}

// ListMappings lists ETC mappings with filtering and pagination
func (s *ETCMappingService) ListMappings(ctx context.Context, params *ListMappingsParams) (*ListMappingsResponse, error) <span class="cov0" title="0">{
        // Set defaults
        if params.Page &lt;= 0 </span><span class="cov0" title="0">{
                params.Page = 1
        }</span>
        <span class="cov0" title="0">if params.PageSize &lt;= 0 </span><span class="cov0" title="0">{
                params.PageSize = 50
        }</span>
        <span class="cov0" title="0">if params.PageSize &gt; 1000 </span><span class="cov0" title="0">{
                params.PageSize = 1000
        }</span>
        <span class="cov0" title="0">if params.SortBy == "" </span><span class="cov0" title="0">{
                params.SortBy = "created_at"
        }</span>
        <span class="cov0" title="0">if params.SortOrder == "" </span><span class="cov0" title="0">{
                params.SortOrder = "desc"
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Listing ETC mappings - page: %d, size: %d", params.Page, params.PageSize)

        // Convert to repository params
        repoParams := repositories.ListMappingsParams{
                Page:             params.Page,
                PageSize:         params.PageSize,
                MappingType:      params.MappingType,
                Status:           params.Status,
                MinConfidence:    params.MinConfidence,
                MappedEntityType: params.MappedEntityType,
                SortBy:           params.SortBy,
                SortOrder:        params.SortOrder,
        }

        // Get mappings from repository
        mappings, totalCount, err := s.mappingRepo.List(ctx, repoParams)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to retrieve mappings: %v", err)
                return nil, fmt.Errorf("failed to retrieve mappings: %w", err)
        }</span>

        <span class="cov0" title="0">totalPages := int((totalCount + int64(params.PageSize) - 1) / int64(params.PageSize))

        // Use mappings directly since they're already ETCMapping

        response := &amp;ListMappingsResponse{
                Mappings:   mappings,
                TotalCount: totalCount,
                Page:       params.Page,
                PageSize:   params.PageSize,
                TotalPages: totalPages,
        }

        s.logger.Printf("Successfully retrieved %d mappings (page %d of %d)", len(mappings), params.Page, totalPages)
        return response, nil</span>
}

// UpdateMapping updates an existing ETC mapping
func (s *ETCMappingService) UpdateMapping(ctx context.Context, id int64, params *UpdateMappingParams) (*models.ETCMapping, error) <span class="cov0" title="0">{
        if id &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid mapping ID: %d", id)
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Updating ETC mapping with ID: %d", id)

        // Start transaction
        txRepo, err := s.mappingRepo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        txRepo.RollbackTx()
                }</span>
        }()

        // Get existing mapping
        <span class="cov0" title="0">mapping, err := txRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                txRepo.RollbackTx()
                return nil, fmt.Errorf("failed to retrieve mapping: %w", err)
        }</span>

        // Update fields
        <span class="cov0" title="0">if params.MappingType != nil </span><span class="cov0" title="0">{
                mapping.MappingType = *params.MappingType
        }</span>
        <span class="cov0" title="0">if params.MappedEntityID != nil </span><span class="cov0" title="0">{
                mapping.MappedEntityID = *params.MappedEntityID
        }</span>
        <span class="cov0" title="0">if params.MappedEntityType != nil </span><span class="cov0" title="0">{
                mapping.MappedEntityType = *params.MappedEntityType
        }</span>
        <span class="cov0" title="0">if params.Confidence != nil </span><span class="cov0" title="0">{
                mapping.Confidence = *params.Confidence
        }</span>
        <span class="cov0" title="0">if params.Status != nil </span><span class="cov0" title="0">{
                mapping.Status = *params.Status
        }</span>
        <span class="cov0" title="0">if params.Metadata != nil </span><span class="cov0" title="0">{
                if err := mapping.SetMetadata(params.Metadata); err != nil </span><span class="cov0" title="0">{
                        txRepo.RollbackTx()
                        s.logger.Printf("Failed to set metadata: %v", err)
                        return nil, fmt.Errorf("failed to set metadata: %w", err)
                }</span>
        }

        // Save the updated mapping
        <span class="cov0" title="0">if err := txRepo.Update(ctx, mapping); err != nil </span><span class="cov0" title="0">{
                txRepo.RollbackTx()
                s.logger.Printf("Failed to update mapping: %v", err)
                return nil, fmt.Errorf("failed to update mapping: %w", err)
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err := txRepo.CommitTx(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Successfully updated ETC mapping with ID: %d", mapping.ID)
        return mapping, nil</span>
}

// DeleteMapping performs soft delete on an ETC mapping
func (s *ETCMappingService) DeleteMapping(ctx context.Context, id int64) error <span class="cov0" title="0">{
        if id &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid mapping ID: %d", id)
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Deleting ETC mapping with ID: %d", id)

        // Start transaction
        txRepo, err := s.mappingRepo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        txRepo.RollbackTx()
                }</span>
        }()

        // Check if mapping exists
        <span class="cov0" title="0">_, err = txRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                txRepo.RollbackTx()
                return fmt.Errorf("failed to retrieve mapping: %w", err)
        }</span>

        // Perform soft delete
        <span class="cov0" title="0">if err := txRepo.Delete(ctx, id); err != nil </span><span class="cov0" title="0">{
                txRepo.RollbackTx()
                s.logger.Printf("Failed to delete mapping: %v", err)
                return fmt.Errorf("failed to delete mapping: %w", err)
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err := txRepo.CommitTx(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Successfully deleted ETC mapping with ID: %d", id)
        return nil</span>
}

// UpdateStatus updates the status of a mapping
func (s *ETCMappingService) UpdateStatus(ctx context.Context, id int64, status string) error <span class="cov0" title="0">{
        if id &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid mapping ID: %d", id)
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Updating status for mapping ID %d to: %s", id, status)

        err := s.mappingRepo.UpdateStatus(ctx, id, status)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to update mapping status: %v", err)
                return fmt.Errorf("failed to update mapping status: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Successfully updated mapping status")
        return nil</span>
}

// HealthCheck performs health check for the service
func (s *ETCMappingService) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        if s.mappingRepo == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mapping repository not initialized")
        }</span>

        // Check repository connectivity
        <span class="cov0" title="0">if err := s.mappingRepo.Ping(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mapping repository ping failed: %w", err)
        }</span>

        <span class="cov0" title="0">if s.recordRepo != nil </span><span class="cov0" title="0">{
                if err := s.recordRepo.Ping(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("record repository ping failed: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package services

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/yhonda-ohishi/etc_meisai/src/models"
        "github.com/yhonda-ohishi/etc_meisai/src/repositories"
)

// ETCMeisaiService handles business logic for ETC record management
type ETCMeisaiService struct {
        repo   repositories.ETCMeisaiRecordRepository
        logger *log.Logger
}

// NewETCMeisaiService creates a new ETC record management service
func NewETCMeisaiService(repo repositories.ETCMeisaiRecordRepository, logger *log.Logger) *ETCMeisaiService <span class="cov8" title="1">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = log.New(log.Writer(), "[ETCMeisaiService] ", log.LstdFlags|log.Lshortfile)
        }</span>

        <span class="cov8" title="1">return &amp;ETCMeisaiService{
                repo:   repo,
                logger: logger,
        }</span>
}

// CreateRecordParams contains parameters for creating an ETC record
type CreateRecordParams struct {
        Date            time.Time `json:"date" validate:"required"`
        Time            string    `json:"time" validate:"required"`
        EntranceIC      string    `json:"entrance_ic" validate:"required"`
        ExitIC          string    `json:"exit_ic" validate:"required"`
        TollAmount      int       `json:"toll_amount" validate:"required,min=0"`
        CarNumber       string    `json:"car_number" validate:"required"`
        ETCCardNumber   string    `json:"etc_card_number" validate:"required"`
        ETCNum          *string   `json:"etc_num,omitempty"`
        DtakoRowID      *int64    `json:"dtako_row_id,omitempty"`
}

// ListRecordsParams contains parameters for listing ETC records
type ListRecordsParams struct {
        Page      int        `json:"page" validate:"min=1"`
        PageSize  int        `json:"page_size" validate:"min=1,max=1000"`
        DateFrom  *time.Time `json:"date_from,omitempty"`
        DateTo    *time.Time `json:"date_to,omitempty"`
        CarNumber *string    `json:"car_number,omitempty"`
        ETCNumber *string    `json:"etc_number,omitempty"`
        ETCNum    *string    `json:"etc_num,omitempty"`
        SortBy    string     `json:"sort_by"`     // date, toll_amount, car_number
        SortOrder string     `json:"sort_order"`  // asc, desc
}

// ListRecordsResponse contains the response for listing ETC records
type ListRecordsResponse struct {
        Records    []*models.ETCMeisaiRecord `json:"records"`
        TotalCount int64                     `json:"total_count"`
        Page       int                       `json:"page"`
        PageSize   int                       `json:"page_size"`
        TotalPages int                       `json:"total_pages"`
}

// CreateRecord creates a new ETC record with hash generation
func (s *ETCMeisaiService) CreateRecord(ctx context.Context, params *CreateRecordParams) (*models.ETCMeisaiRecord, error) <span class="cov8" title="1">{
        s.logger.Printf("Creating ETC record for car: %s, date: %s", params.CarNumber, params.Date.Format("2006-01-02"))

        // Create record model
        record := &amp;models.ETCMeisaiRecord{
                Date:          params.Date,
                Time:          params.Time,
                EntranceIC:    params.EntranceIC,
                ExitIC:        params.ExitIC,
                TollAmount:    params.TollAmount,
                CarNumber:     params.CarNumber,
                ETCCardNumber: params.ETCCardNumber,
                ETCNum:        params.ETCNum,
                DtakoRowID:    params.DtakoRowID,
        }

        // Generate hash for the record
        record.Hash = record.GenerateHash()

        // Validate the record
        if err := record.Validate(); err != nil </span><span class="cov8" title="1">{
                s.logger.Printf("Validation failed for record: %v", err)
                return nil, fmt.Errorf("record validation failed: %w", err)
        }</span>

        // Start transaction
        <span class="cov8" title="1">txRepo, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        txRepo.RollbackTx()
                }</span>
        }()

        // Check for duplicate hash
        <span class="cov8" title="1">isDuplicate, err := txRepo.CheckDuplicateHash(ctx, record.Hash)
        if err != nil </span><span class="cov8" title="1">{
                txRepo.RollbackTx()
                return nil, fmt.Errorf("failed to check for duplicates: %w", err)
        }</span>
        <span class="cov8" title="1">if isDuplicate </span><span class="cov8" title="1">{
                txRepo.RollbackTx()
                return nil, fmt.Errorf("duplicate record with hash: %s", record.Hash)
        }</span>

        // Create the record
        <span class="cov8" title="1">if err := txRepo.Create(ctx, record); err != nil </span><span class="cov8" title="1">{
                txRepo.RollbackTx()
                s.logger.Printf("Failed to create record: %v", err)
                return nil, fmt.Errorf("failed to create record: %w", err)
        }</span>

        // Commit transaction
        <span class="cov8" title="1">if err := txRepo.CommitTx(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov8" title="1">s.logger.Printf("Successfully created ETC record with ID: %d, hash: %s", record.ID, record.Hash)
        return record, nil</span>
}

// GetRecord retrieves an ETC record by ID
func (s *ETCMeisaiService) GetRecord(ctx context.Context, id int64) (*models.ETCMeisaiRecord, error) <span class="cov8" title="1">{
        if id &lt;= 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid record ID: %d", id)
        }</span>

        <span class="cov8" title="1">s.logger.Printf("Retrieving ETC record with ID: %d", id)

        record, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Printf("Failed to retrieve record: %v", err)
                return nil, fmt.Errorf("failed to retrieve record: %w", err)
        }</span>

        <span class="cov8" title="1">return record, nil</span>
}

// ListRecords lists ETC records with filtering and pagination
func (s *ETCMeisaiService) ListRecords(ctx context.Context, params *ListRecordsParams) (*ListRecordsResponse, error) <span class="cov8" title="1">{
        // Set defaults
        if params.Page &lt;= 0 </span><span class="cov8" title="1">{
                params.Page = 1
        }</span>
        <span class="cov8" title="1">if params.PageSize &lt;= 0 </span><span class="cov8" title="1">{
                params.PageSize = 50
        }</span>
        <span class="cov8" title="1">if params.PageSize &gt; 1000 </span><span class="cov8" title="1">{
                params.PageSize = 1000
        }</span>
        <span class="cov8" title="1">if params.SortBy == "" </span><span class="cov8" title="1">{
                params.SortBy = "date"
        }</span>
        <span class="cov8" title="1">if params.SortOrder == "" </span><span class="cov8" title="1">{
                params.SortOrder = "desc"
        }</span>

        <span class="cov8" title="1">s.logger.Printf("Listing ETC records - page: %d, size: %d", params.Page, params.PageSize)

        // Convert to repository params
        repoParams := repositories.ListRecordsParams{
                Page:      params.Page,
                PageSize:  params.PageSize,
                DateFrom:  params.DateFrom,
                DateTo:    params.DateTo,
                CarNumber: params.CarNumber,
                ETCNumber: params.ETCNumber,
                ETCNum:    params.ETCNum,
                SortBy:    params.SortBy,
                SortOrder: params.SortOrder,
        }

        // Get records from repository
        records, totalCount, err := s.repo.List(ctx, repoParams)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Printf("Failed to retrieve records: %v", err)
                return nil, fmt.Errorf("failed to retrieve records: %w", err)
        }</span>

        <span class="cov8" title="1">totalPages := int((totalCount + int64(params.PageSize) - 1) / int64(params.PageSize))

        response := &amp;ListRecordsResponse{
                Records:    records,
                TotalCount: totalCount,
                Page:       params.Page,
                PageSize:   params.PageSize,
                TotalPages: totalPages,
        }

        s.logger.Printf("Successfully retrieved %d records (page %d of %d)", len(records), params.Page, totalPages)
        return response, nil</span>
}

// UpdateRecord updates an existing ETC record
func (s *ETCMeisaiService) UpdateRecord(ctx context.Context, id int64, params *CreateRecordParams) (*models.ETCMeisaiRecord, error) <span class="cov8" title="1">{
        if id &lt;= 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid record ID: %d", id)
        }</span>

        <span class="cov8" title="1">s.logger.Printf("Updating ETC record with ID: %d", id)

        // Start transaction
        txRepo, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        txRepo.RollbackTx()
                }</span>
        }()

        // Get existing record
        <span class="cov8" title="1">record, err := txRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                txRepo.RollbackTx()
                return nil, fmt.Errorf("failed to retrieve record: %w", err)
        }</span>

        // Update fields
        <span class="cov8" title="1">record.Date = params.Date
        record.Time = params.Time
        record.EntranceIC = params.EntranceIC
        record.ExitIC = params.ExitIC
        record.TollAmount = params.TollAmount
        record.CarNumber = params.CarNumber
        record.ETCCardNumber = params.ETCCardNumber
        record.ETCNum = params.ETCNum
        record.DtakoRowID = params.DtakoRowID

        // Regenerate hash with new data
        record.Hash = record.GenerateHash()

        // Validate the updated record
        if err := record.Validate(); err != nil </span><span class="cov8" title="1">{
                txRepo.RollbackTx()
                s.logger.Printf("Validation failed for updated record: %v", err)
                return nil, fmt.Errorf("record validation failed: %w", err)
        }</span>

        // Check for duplicate hash (excluding current record)
        <span class="cov8" title="1">isDuplicate, err := txRepo.CheckDuplicateHash(ctx, record.Hash, record.ID)
        if err != nil </span><span class="cov0" title="0">{
                txRepo.RollbackTx()
                return nil, fmt.Errorf("failed to check for duplicates: %w", err)
        }</span>
        <span class="cov8" title="1">if isDuplicate </span><span class="cov8" title="1">{
                txRepo.RollbackTx()
                return nil, fmt.Errorf("duplicate record with hash: %s", record.Hash)
        }</span>

        // Save the updated record
        <span class="cov8" title="1">if err := txRepo.Update(ctx, record); err != nil </span><span class="cov0" title="0">{
                txRepo.RollbackTx()
                s.logger.Printf("Failed to update record: %v", err)
                return nil, fmt.Errorf("failed to update record: %w", err)
        }</span>

        // Commit transaction
        <span class="cov8" title="1">if err := txRepo.CommitTx(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov8" title="1">s.logger.Printf("Successfully updated ETC record with ID: %d", record.ID)
        return record, nil</span>
}

// DeleteRecord performs soft delete on an ETC record
func (s *ETCMeisaiService) DeleteRecord(ctx context.Context, id int64) error <span class="cov8" title="1">{
        if id &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid record ID: %d", id)
        }</span>

        <span class="cov8" title="1">s.logger.Printf("Deleting ETC record with ID: %d", id)

        // Start transaction
        txRepo, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        txRepo.RollbackTx()
                }</span>
        }()

        // Check if record exists
        <span class="cov8" title="1">_, err = txRepo.GetByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                txRepo.RollbackTx()
                return fmt.Errorf("failed to retrieve record: %w", err)
        }</span>

        // Perform soft delete
        <span class="cov8" title="1">if err := txRepo.Delete(ctx, id); err != nil </span><span class="cov8" title="1">{
                txRepo.RollbackTx()
                s.logger.Printf("Failed to delete record: %v", err)
                return fmt.Errorf("failed to delete record: %w", err)
        }</span>

        // Commit transaction
        <span class="cov8" title="1">if err := txRepo.CommitTx(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov8" title="1">s.logger.Printf("Successfully deleted ETC record with ID: %d", id)
        return nil</span>
}

// GetRecordByHash retrieves an ETC record by its hash
func (s *ETCMeisaiService) GetRecordByHash(ctx context.Context, hash string) (*models.ETCMeisaiRecord, error) <span class="cov8" title="1">{
        if hash == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("hash cannot be empty")
        }</span>

        <span class="cov8" title="1">s.logger.Printf("Retrieving ETC record with hash: %s", hash)

        record, err := s.repo.GetByHash(ctx, hash)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Printf("Failed to retrieve record by hash: %v", err)
                return nil, fmt.Errorf("failed to retrieve record: %w", err)
        }</span>

        <span class="cov8" title="1">return record, nil</span>
}

// ValidateRecord validates an ETC record without saving it
func (s *ETCMeisaiService) ValidateRecord(ctx context.Context, params *CreateRecordParams) error <span class="cov8" title="1">{
        // Create temporary record for validation
        record := &amp;models.ETCMeisaiRecord{
                Date:          params.Date,
                Time:          params.Time,
                EntranceIC:    params.EntranceIC,
                ExitIC:        params.ExitIC,
                TollAmount:    params.TollAmount,
                CarNumber:     params.CarNumber,
                ETCCardNumber: params.ETCCardNumber,
                ETCNum:        params.ETCNum,
                DtakoRowID:    params.DtakoRowID,
        }

        // Validate the record
        return record.Validate()
}</span>

// HealthCheck performs health check for the service
func (s *ETCMeisaiService) HealthCheck(ctx context.Context) error <span class="cov8" title="1">{
        if s.repo == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("repository not initialized")
        }</span>

        // Check repository connectivity
        <span class="cov8" title="1">if err := s.repo.Ping(ctx); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("repository ping failed: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package services

import (
        "context"
        "fmt"
        "time"

        "github.com/yhonda-ohishi/etc_meisai/src/adapters"
        // "github.com/yhonda-ohishi/etc_meisai/src/clients" // Commented out - clients package deleted
        "github.com/yhonda-ohishi/etc_meisai/src/models"
        "github.com/yhonda-ohishi/etc_meisai/src/repositories"
)

// ETCService handles business logic for ETC meisai with integrated repository
type ETCService struct {
        repo         repositories.ETCRepository
        dbClient     interface{} // TODO: Replace with proper type when clients package is restored
        compatAdapter *adapters.ETCMeisaiCompatAdapter
}

// NewETCService creates a new ETC service with integrated repository
func NewETCService(repo repositories.ETCRepository, dbClient interface{}) *ETCService <span class="cov0" title="0">{
        return &amp;ETCService{
                repo:         repo,
                dbClient:     dbClient,
                compatAdapter: adapters.NewETCMeisaiCompatAdapter(),
        }
}</span>

// Create creates a new ETC record
func (s *ETCService) Create(ctx context.Context, etc *models.ETCMeisai) (*models.ETCMeisai, error) <span class="cov0" title="0">{
        if etc == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ETC record cannot be nil")
        }</span>

        // Generate hash if not present
        <span class="cov0" title="0">if etc.Hash == "" </span><span class="cov0" title="0">{
                etc.Hash = etc.GenerateHash()
        }</span>

        // Validate the record
        <span class="cov0" title="0">if err := etc.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("validation failed: %w", err)
        }</span>

        // Create via repository
        <span class="cov0" title="0">if err := s.repo.Create(etc); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create ETC record: %w", err)
        }</span>

        <span class="cov0" title="0">return etc, nil</span>
}

// CreateETCRecord creates a new ETC record with enhanced validation
// This method provides comprehensive validation for test coverage
func (s *ETCService) CreateETCRecord(ctx context.Context, etc *models.ETCMeisai) (*models.ETCMeisai, error) <span class="cov0" title="0">{
        if etc == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ETC record cannot be nil")
        }</span>

        // Enhanced validation for test coverage
        <span class="cov0" title="0">if etc.UseDate.IsZero() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("use date is required")
        }</span>
        <span class="cov0" title="0">if etc.UseTime == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("use time is required")
        }</span>
        <span class="cov0" title="0">if etc.EntryIC == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("entry IC is required")
        }</span>
        <span class="cov0" title="0">if etc.ExitIC == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("exit IC is required")
        }</span>
        <span class="cov0" title="0">if etc.Amount &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("amount must be positive")
        }</span>
        <span class="cov0" title="0">if etc.ETCNumber == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ETC number is required")
        }</span>

        // Generate hash if not present
        <span class="cov0" title="0">if etc.Hash == "" </span><span class="cov0" title="0">{
                etc.Hash = etc.GenerateHash()
        }</span>

        // Call existing Create method
        <span class="cov0" title="0">return s.Create(ctx, etc)</span>
}

// GetByID retrieves an ETC record by ID
func (s *ETCService) GetByID(ctx context.Context, id int64) (*models.ETCMeisai, error) <span class="cov0" title="0">{
        if id &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ID must be positive")
        }</span>

        <span class="cov0" title="0">etc, err := s.repo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get ETC record: %w", err)
        }</span>

        <span class="cov0" title="0">return etc, nil</span>
}

// GetByDateRange retrieves ETC records for a date range
func (s *ETCService) GetByDateRange(ctx context.Context, start, end time.Time) ([]*models.ETCMeisai, error) <span class="cov0" title="0">{
        if start.After(end) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("start date cannot be after end date")
        }</span>

        <span class="cov0" title="0">records, err := s.repo.GetByDateRange(start, end)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get records by date range: %w", err)
        }</span>

        <span class="cov0" title="0">return records, nil</span>
}

// List retrieves ETC records with filtering and pagination
func (s *ETCService) List(ctx context.Context, params *models.ETCListParams) ([]*models.ETCMeisai, int64, error) <span class="cov0" title="0">{
        if params == nil </span><span class="cov0" title="0">{
                params = &amp;models.ETCListParams{Limit: 100, Offset: 0}
        }</span>

        <span class="cov0" title="0">records, total, err := s.repo.List(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to list ETC records: %w", err)
        }</span>

        <span class="cov0" title="0">return records, total, nil</span>
}

// GetETCRecords retrieves ETC records with enhanced filtering and validation
// This method provides comprehensive parameter validation for test coverage
func (s *ETCService) GetETCRecords(ctx context.Context, params *models.ETCListParams) ([]*models.ETCMeisai, int64, error) <span class="cov0" title="0">{
        if params == nil </span><span class="cov0" title="0">{
                params = &amp;models.ETCListParams{Limit: 100, Offset: 0}
        }</span>

        // Enhanced parameter validation for comprehensive coverage
        <span class="cov0" title="0">if params.Limit &lt; 0 </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("limit cannot be negative")
        }</span>
        <span class="cov0" title="0">if params.Offset &lt; 0 </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("offset cannot be negative")
        }</span>
        <span class="cov0" title="0">if params.Limit &gt; 10000 </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("limit cannot exceed 10000")
        }</span>

        <span class="cov0" title="0">records, total, err := s.repo.List(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to get ETC records: %w", err)
        }</span>

        <span class="cov0" title="0">return records, total, nil</span>
}

// ImportCSV imports ETC data from CSV with integrated validation and processing
func (s *ETCService) ImportCSV(ctx context.Context, records []*models.ETCMeisai) (*models.ETCImportResult, error) <span class="cov0" title="0">{
        if records == nil || len(records) == 0 </span><span class="cov0" title="0">{
                return &amp;models.ETCImportResult{
                        Success:      true,
                        RecordCount:  0,
                        ImportedRows: 0,
                        Message:      "No records to import",
                        ImportedAt:   time.Now(),
                }, nil
        }</span>

        <span class="cov0" title="0">startTime := time.Now()
        result := &amp;models.ETCImportResult{
                ImportedAt: startTime,
        }

        // Validate all records first
        validationResults := models.ValidateETCMeisaiBatch(records, &amp;models.BatchValidationOptions{
                StrictMode:     false,
                SkipDuplicates: false,
                MaxErrors:      100,
        })

        var validRecords []*models.ETCMeisai
        var errors []string

        for i, record := range records </span><span class="cov0" title="0">{
                if validationResult, ok := validationResults[i]; ok &amp;&amp; !validationResult.Valid </span><span class="cov0" title="0">{
                        for _, err := range validationResult.Errors </span><span class="cov0" title="0">{
                                errors = append(errors, fmt.Sprintf("Row %d: %s", i+1, err.Message))
                        }</span>
                } else<span class="cov0" title="0"> {
                        validRecords = append(validRecords, record)
                }</span>
        }

        <span class="cov0" title="0">result.RecordCount = len(records)
        result.ErrorMessage = ""
        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                result.Errors = errors
        }</span>

        // Check for duplicates
        <span class="cov0" title="0">duplicates, err := s.repo.CheckDuplicatesByHash(extractHashes(validRecords))
        if err != nil </span><span class="cov0" title="0">{
                result.Success = false
                result.ErrorMessage = fmt.Sprintf("Failed to check duplicates: %v", err)
                return result, nil
        }</span>

        // Filter out duplicates
        <span class="cov0" title="0">var newRecords []*models.ETCMeisai
        duplicateCount := 0
        for _, record := range validRecords </span><span class="cov0" title="0">{
                if duplicates[record.Hash] </span><span class="cov0" title="0">{
                        duplicateCount++
                }</span> else<span class="cov0" title="0"> {
                        newRecords = append(newRecords, record)
                }</span>
        }

        // Bulk insert new records
        <span class="cov0" title="0">if len(newRecords) &gt; 0 </span><span class="cov0" title="0">{
                if err := s.repo.BulkInsert(newRecords); err != nil </span><span class="cov0" title="0">{
                        result.Success = false
                        result.ErrorMessage = fmt.Sprintf("Failed to bulk insert records: %v", err)
                        return result, nil
                }</span>
        }

        // Populate result
        <span class="cov0" title="0">result.Success = true
        result.ImportedRows = len(newRecords)
        result.Duration = time.Since(startTime).Milliseconds()
        result.Message = fmt.Sprintf("Successfully imported %d records (%d duplicates skipped, %d validation errors)",
                len(newRecords), duplicateCount, len(errors))

        return result, nil</span>
}

// Legacy compatibility methods for existing API

// ImportData imports ETC meisai data for a date range (legacy compatibility)
func (s *ETCService) ImportData(req models.ETCImportRequest) (*models.ETCImportResult, error) <span class="cov0" title="0">{
        _, err := time.Parse("2006-01-02", req.FromDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid from_date format: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = time.Parse("2006-01-02", req.ToDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid to_date format: %w", err)
        }</span>

        // For now, return a placeholder response
        <span class="cov0" title="0">result := &amp;models.ETCImportResult{
                Success:      true,
                ImportedRows: 0,
                Message:      fmt.Sprintf("Import request received for %s to %s", req.FromDate, req.ToDate),
                ImportedAt:   time.Now(),
        }

        return result, nil</span>
}

// GetMeisaiByDateRange retrieves ETC meisai for a date range (legacy compatibility)
func (s *ETCService) GetMeisaiByDateRange(fromDate, toDate string) ([]models.ETCMeisai, error) <span class="cov0" title="0">{
        from, err := time.Parse("2006-01-02", fromDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid from_date format: %w", err)
        }</span>

        <span class="cov0" title="0">to, err := time.Parse("2006-01-02", toDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid to_date format: %w", err)
        }</span>

        <span class="cov0" title="0">ctx := context.Background()
        records, err := s.GetByDateRange(ctx, from, to)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert to legacy format
        <span class="cov0" title="0">var legacyRecords []models.ETCMeisai
        for _, record := range records </span><span class="cov0" title="0">{
                if record != nil </span><span class="cov0" title="0">{
                        legacyRecords = append(legacyRecords, *record)
                }</span>
        }

        <span class="cov0" title="0">return legacyRecords, nil</span>
}

// Helper functions

// extractHashes extracts hashes from a slice of ETC records
func extractHashes(records []*models.ETCMeisai) []string <span class="cov0" title="0">{
        hashes := make([]string, len(records))
        for i, record := range records </span><span class="cov0" title="0">{
                if record.Hash == "" </span><span class="cov0" title="0">{
                        record.Hash = record.GenerateHash()
                }</span>
                <span class="cov0" title="0">hashes[i] = record.Hash</span>
        }
        <span class="cov0" title="0">return hashes</span>
}

// GetSummary retrieves summary statistics for a date range
func (s *ETCService) GetSummary(ctx context.Context, fromDate, toDate string) (*models.ETCSummary, error) <span class="cov0" title="0">{
        from, err := time.Parse("2006-01-02", fromDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid from_date format: %w", err)
        }</span>

        <span class="cov0" title="0">to, err := time.Parse("2006-01-02", toDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid to_date format: %w", err)
        }</span>

        <span class="cov0" title="0">summary, err := s.repo.GetSummaryByDateRange(from, to)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get summary: %w", err)
        }</span>

        <span class="cov0" title="0">return summary, nil</span>
}

// HealthCheck performs a health check on the service and its dependencies
func (s *ETCService) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        // Check if repository is initialized
        if s.repo == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("repository not initialized")
        }</span>

        // Check repository by doing a simple count operation
        <span class="cov0" title="0">_, err := s.repo.CountByDateRange(time.Now().AddDate(0, 0, -1), time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("repository health check failed: %w", err)
        }</span>

        // Check db_service client if available
        // TODO: Restore when clients package is available
        // if s.dbClient != nil {
        //        if err := s.dbClient.HealthCheck(ctx); err != nil {
        //                return fmt.Errorf("db_service health check failed: %w", err)
        //        }
        // }

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file5" style="display: none">package services

import (
        "context"
        "encoding/csv"
        "fmt"
        "io"
        "log"
        "strconv"
        "strings"
        "time"

        "gorm.io/gorm"

        "github.com/yhonda-ohishi/etc_meisai/src/models"
)

// ImportService handles CSV import operations for ETC records
type ImportService struct {
        db     *gorm.DB
        logger *log.Logger
}

// NewImportService creates a new import service
func NewImportService(db *gorm.DB, logger *log.Logger) *ImportService <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = log.New(log.Writer(), "[ImportService] ", log.LstdFlags|log.Lshortfile)
        }</span>

        <span class="cov0" title="0">return &amp;ImportService{
                db:     db,
                logger: logger,
        }</span>
}

// ImportCSVParams contains parameters for CSV import
type ImportCSVParams struct {
        AccountType string `json:"account_type" validate:"required"`
        AccountID   string `json:"account_id" validate:"required"`
        FileName    string `json:"file_name" validate:"required"`
        FileSize    int64  `json:"file_size" validate:"required,min=1"`
        CreatedBy   string `json:"created_by,omitempty"`
}

// ImportCSVStreamParams contains parameters for streaming CSV import
type ImportCSVStreamParams struct {
        SessionID string   `json:"session_id" validate:"required"`
        Chunks    []string `json:"chunks" validate:"required"`
}

// ImportCSVResult contains the result of CSV import
type ImportCSVResult struct {
        Session       *models.ImportSession     `json:"session"`
        Records       []*models.ETCMeisaiRecord `json:"records"`
        SuccessCount  int                       `json:"success_count"`
        ErrorCount    int                       `json:"error_count"`
        DuplicateCount int                      `json:"duplicate_count"`
        Errors        []models.ImportError      `json:"errors"`
}

// ListImportSessionsParams contains parameters for listing import sessions
type ListImportSessionsParams struct {
        Page        int     `json:"page" validate:"min=1"`
        PageSize    int     `json:"page_size" validate:"min=1,max=1000"`
        AccountType *string `json:"account_type,omitempty"`
        AccountID   *string `json:"account_id,omitempty"`
        Status      *string `json:"status,omitempty"`
        CreatedBy   *string `json:"created_by,omitempty"`
        SortBy      string  `json:"sort_by"`     // created_at, started_at, file_name
        SortOrder   string  `json:"sort_order"`  // asc, desc
}

// ListImportSessionsResponse contains the response for listing import sessions
type ListImportSessionsResponse struct {
        Sessions   []*models.ImportSession `json:"sessions"`
        TotalCount int64                   `json:"total_count"`
        Page       int                     `json:"page"`
        PageSize   int                     `json:"page_size"`
        TotalPages int                     `json:"total_pages"`
}

// CSVRow represents a single row from the CSV file
type CSVRow struct {
        Date          string `json:"date"`
        Time          string `json:"time"`
        EntranceIC    string `json:"entrance_ic"`
        ExitIC        string `json:"exit_ic"`
        TollAmount    string `json:"toll_amount"`
        CarNumber     string `json:"car_number"`
        ETCCardNumber string `json:"etc_card_number"`
        ETCNum        string `json:"etc_num,omitempty"`
}

// DuplicateResult contains information about duplicate records
type DuplicateResult struct {
        Hash           string                 `json:"hash"`
        ExistingRecord *models.ETCMeisaiRecord `json:"existing_record"`
        NewRecord      *models.ETCMeisaiRecord `json:"new_record"`
        Action         string                  `json:"action"` // skip, update, create_new
}

// ImportCSV processes CSV import and creates records
func (s *ImportService) ImportCSV(ctx context.Context, params *ImportCSVParams, data io.Reader) (*ImportCSVResult, error) <span class="cov0" title="0">{
        s.logger.Printf("Starting CSV import for account: %s (%s), file: %s", params.AccountID, params.AccountType, params.FileName)

        // Start transaction
        tx := s.db.WithContext(ctx).Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start transaction: %w", tx.Error)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        // Create import session
        <span class="cov0" title="0">session := &amp;models.ImportSession{
                AccountType: params.AccountType,
                AccountID:   params.AccountID,
                FileName:    params.FileName,
                FileSize:    params.FileSize,
                Status:      string(models.ImportStatusPending),
                CreatedBy:   params.CreatedBy,
        }

        if err := tx.Create(session).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                s.logger.Printf("Failed to create import session: %v", err)
                return nil, fmt.Errorf("failed to create import session: %w", err)
        }</span>

        // Start processing
        <span class="cov0" title="0">if err := session.StartProcessing(); err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, fmt.Errorf("failed to start processing: %w", err)
        }</span>

        // Parse CSV data
        <span class="cov0" title="0">records, errors, err := s.parseCSVData(data)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                s.logger.Printf("Failed to parse CSV data: %v", err)
                return nil, fmt.Errorf("failed to parse CSV data: %w", err)
        }</span>

        <span class="cov0" title="0">session.TotalRows = len(records) + len(errors)

        // Process each record
        var successRecords []*models.ETCMeisaiRecord
        var duplicateCount int

        for i, record := range records </span><span class="cov0" title="0">{
                // Check for duplicates
                var existingRecord models.ETCMeisaiRecord
                err := tx.Where("hash = ?", record.Hash).First(&amp;existingRecord).Error
                if err == nil </span><span class="cov0" title="0">{
                        // Duplicate found
                        duplicateCount++
                        s.logger.Printf("Duplicate record found with hash: %s", record.Hash)
                        continue</span>
                } else<span class="cov0" title="0"> if err != gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        // Database error
                        tx.Rollback()
                        return nil, fmt.Errorf("failed to check for duplicates: %w", err)
                }</span>

                // Create the record
                <span class="cov0" title="0">if err := tx.Create(record).Error; err != nil </span><span class="cov0" title="0">{
                        s.logger.Printf("Failed to create record %d: %v", i+1, err)

                        // Add error to session
                        session.AddError(i+1, "creation_error", err.Error(), "")
                        session.ErrorRows++
                }</span> else<span class="cov0" title="0"> {
                        successRecords = append(successRecords, record)
                        session.SuccessRows++
                }</span>
                <span class="cov0" title="0">session.ProcessedRows++</span>
        }

        // Add parsing errors to session
        <span class="cov0" title="0">for _, importErr := range errors </span><span class="cov0" title="0">{
                session.AddError(importErr.RowNumber, importErr.ErrorType, importErr.ErrorMessage, importErr.RawData)
                session.ErrorRows++
        }</span>

        <span class="cov0" title="0">session.DuplicateRows = duplicateCount

        // Complete the session
        if session.ErrorRows == 0 </span><span class="cov0" title="0">{
                if err := session.Complete(); err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return nil, fmt.Errorf("failed to complete session: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                // Set as completed with errors
                session.Status = string(models.ImportStatusCompleted)
                now := time.Now()
                session.CompletedAt = &amp;now
        }</span>

        // Save session updates
        <span class="cov0" title="0">if err := tx.Save(session).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, fmt.Errorf("failed to save session: %w", err)
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err := tx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">result := &amp;ImportCSVResult{
                Session:        session,
                Records:        successRecords,
                SuccessCount:   session.SuccessRows,
                ErrorCount:     session.ErrorRows,
                DuplicateCount: session.DuplicateRows,
                Errors:         errors,
        }

        s.logger.Printf("CSV import completed - Success: %d, Errors: %d, Duplicates: %d",
                session.SuccessRows, session.ErrorRows, session.DuplicateRows)

        return result, nil</span>
}

// ImportCSVStream handles streaming import of CSV data in chunks
func (s *ImportService) ImportCSVStream(ctx context.Context, params *ImportCSVStreamParams) (*ImportCSVResult, error) <span class="cov0" title="0">{
        s.logger.Printf("Starting streaming CSV import for session: %s", params.SessionID)

        // Get existing session
        session, err := s.GetImportSession(ctx, params.SessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get import session: %w", err)
        }</span>

        <span class="cov0" title="0">if !session.IsPending() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("session is not in pending status: %s", session.Status)
        }</span>

        // Combine chunks into single data stream
        <span class="cov0" title="0">csvData := strings.Join(params.Chunks, "")
        dataReader := strings.NewReader(csvData)

        // Update file size
        session.FileSize = int64(len(csvData))

        // Process the CSV data
        importParams := &amp;ImportCSVParams{
                AccountType: session.AccountType,
                AccountID:   session.AccountID,
                FileName:    session.FileName,
                FileSize:    session.FileSize,
                CreatedBy:   session.CreatedBy,
        }

        // Delete the temporary session since ImportCSV will create a new one
        if err := s.db.WithContext(ctx).Delete(session).Error; err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to delete temporary session: %v", err)
        }</span>

        <span class="cov0" title="0">return s.ImportCSV(ctx, importParams, dataReader)</span>
}

// GetImportSession retrieves an import session by ID
func (s *ImportService) GetImportSession(ctx context.Context, sessionID string) (*models.ImportSession, error) <span class="cov0" title="0">{
        if sessionID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("session ID cannot be empty")
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Retrieving import session: %s", sessionID)

        var session models.ImportSession
        err := s.db.WithContext(ctx).First(&amp;session, "id = ?", sessionID).Error
        if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("import session not found: %s", sessionID)
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to retrieve import session: %v", err)
                return nil, fmt.Errorf("failed to retrieve import session: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;session, nil</span>
}

// ListImportSessions lists import sessions with filtering and pagination
func (s *ImportService) ListImportSessions(ctx context.Context, params *ListImportSessionsParams) (*ListImportSessionsResponse, error) <span class="cov0" title="0">{
        // Set defaults
        if params.Page &lt;= 0 </span><span class="cov0" title="0">{
                params.Page = 1
        }</span>
        <span class="cov0" title="0">if params.PageSize &lt;= 0 </span><span class="cov0" title="0">{
                params.PageSize = 50
        }</span>
        <span class="cov0" title="0">if params.PageSize &gt; 1000 </span><span class="cov0" title="0">{
                params.PageSize = 1000
        }</span>
        <span class="cov0" title="0">if params.SortBy == "" </span><span class="cov0" title="0">{
                params.SortBy = "created_at"
        }</span>
        <span class="cov0" title="0">if params.SortOrder == "" </span><span class="cov0" title="0">{
                params.SortOrder = "desc"
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Listing import sessions - page: %d, size: %d", params.Page, params.PageSize)

        // Build query
        query := s.db.WithContext(ctx).Model(&amp;models.ImportSession{})

        // Apply filters
        if params.AccountType != nil &amp;&amp; *params.AccountType != "" </span><span class="cov0" title="0">{
                query = query.Where("account_type = ?", *params.AccountType)
        }</span>
        <span class="cov0" title="0">if params.AccountID != nil &amp;&amp; *params.AccountID != "" </span><span class="cov0" title="0">{
                query = query.Where("account_id LIKE ?", "%"+*params.AccountID+"%")
        }</span>
        <span class="cov0" title="0">if params.Status != nil &amp;&amp; *params.Status != "" </span><span class="cov0" title="0">{
                query = query.Where("status = ?", *params.Status)
        }</span>
        <span class="cov0" title="0">if params.CreatedBy != nil &amp;&amp; *params.CreatedBy != "" </span><span class="cov0" title="0">{
                query = query.Where("created_by LIKE ?", "%"+*params.CreatedBy+"%")
        }</span>

        // Get total count
        <span class="cov0" title="0">var totalCount int64
        if err := query.Count(&amp;totalCount).Error; err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to count import sessions: %v", err)
                return nil, fmt.Errorf("failed to count import sessions: %w", err)
        }</span>

        // Apply sorting and pagination
        <span class="cov0" title="0">orderClause := fmt.Sprintf("%s %s", params.SortBy, params.SortOrder)
        offset := (params.Page - 1) * params.PageSize

        var sessions []*models.ImportSession
        err := query.Order(orderClause).Offset(offset).Limit(params.PageSize).Find(&amp;sessions).Error
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to retrieve import sessions: %v", err)
                return nil, fmt.Errorf("failed to retrieve import sessions: %w", err)
        }</span>

        <span class="cov0" title="0">totalPages := int((totalCount + int64(params.PageSize) - 1) / int64(params.PageSize))

        response := &amp;ListImportSessionsResponse{
                Sessions:   sessions,
                TotalCount: totalCount,
                Page:       params.Page,
                PageSize:   params.PageSize,
                TotalPages: totalPages,
        }

        s.logger.Printf("Successfully retrieved %d import sessions (page %d of %d)", len(sessions), params.Page, totalPages)
        return response, nil</span>
}

// ProcessCSV processes bulk CSV data with large dataset support
// This method provides enhanced bulk processing for test coverage
func (s *ImportService) ProcessCSV(ctx context.Context, rows []*CSVRow, options *BulkProcessOptions) (*BulkProcessResult, error) <span class="cov0" title="0">{
        if rows == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("CSV rows cannot be nil")
        }</span>

        <span class="cov0" title="0">if options == nil </span><span class="cov0" title="0">{
                options = &amp;BulkProcessOptions{
                        BatchSize:    1000,
                        MaxConcurrency: 5,
                        SkipErrors:   false,
                }
        }</span>

        // Validate batch size
        <span class="cov0" title="0">if options.BatchSize &lt;= 0 || options.BatchSize &gt; 10000 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("batch size must be between 1 and 10000")
        }</span>
        <span class="cov0" title="0">if options.MaxConcurrency &lt;= 0 || options.MaxConcurrency &gt; 20 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("max concurrency must be between 1 and 20")
        }</span>

        <span class="cov0" title="0">result := &amp;BulkProcessResult{
                TotalRows:     len(rows),
                SuccessCount:  0,
                ErrorCount:    0,
                ProcessedAt:   time.Now(),
                Errors:        make([]string, 0),
        }

        // Process in batches
        for i := 0; i &lt; len(rows); i += options.BatchSize </span><span class="cov0" title="0">{
                end := i + options.BatchSize
                if end &gt; len(rows) </span><span class="cov0" title="0">{
                        end = len(rows)
                }</span>

                <span class="cov0" title="0">batch := rows[i:end]
                batchResult, err := s.processBatch(ctx, batch, options)
                if err != nil </span><span class="cov0" title="0">{
                        if !options.SkipErrors </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("batch processing failed: %w", err)
                        }</span>
                        <span class="cov0" title="0">result.ErrorCount += len(batch)
                        result.Errors = append(result.Errors, fmt.Sprintf("Batch %d-%d failed: %v", i, end-1, err))</span>
                } else<span class="cov0" title="0"> {
                        result.SuccessCount += batchResult.SuccessCount
                        result.ErrorCount += batchResult.ErrorCount
                        result.Errors = append(result.Errors, batchResult.Errors...)
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// processBatch processes a batch of CSV rows
func (s *ImportService) processBatch(ctx context.Context, batch []*CSVRow, options *BulkProcessOptions) (*BulkProcessResult, error) <span class="cov0" title="0">{
        result := &amp;BulkProcessResult{
                TotalRows:    len(batch),
                SuccessCount: 0,
                ErrorCount:   0,
                Errors:       make([]string, 0),
        }

        for _, row := range batch </span><span class="cov0" title="0">{
                _, err := s.ProcessCSVRow(ctx, row)
                if err != nil </span><span class="cov0" title="0">{
                        result.ErrorCount++
                        if !options.SkipErrors </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">result.Errors = append(result.Errors, err.Error())</span>
                } else<span class="cov0" title="0"> {
                        result.SuccessCount++
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// BulkProcessOptions configures bulk processing behavior
type BulkProcessOptions struct {
        BatchSize      int  // Number of rows per batch
        MaxConcurrency int  // Maximum concurrent batches
        SkipErrors     bool // Continue processing on errors
}

// BulkProcessResult contains bulk processing results
type BulkProcessResult struct {
        TotalRows     int       // Total rows processed
        SuccessCount  int       // Successfully processed rows
        ErrorCount    int       // Failed rows
        ProcessedAt   time.Time // Processing timestamp
        Errors        []string  // Error messages
}

// ProcessCSVRow processes a single CSV row
func (s *ImportService) ProcessCSVRow(ctx context.Context, row *CSVRow) (*models.ETCMeisaiRecord, error) <span class="cov0" title="0">{
        // Parse date
        date, err := time.Parse("2006-01-02", row.Date)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid date format: %s", row.Date)
        }</span>

        // Parse toll amount
        <span class="cov0" title="0">tollAmount, err := strconv.Atoi(row.TollAmount)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid toll amount: %s", row.TollAmount)
        }</span>

        // Create record
        <span class="cov0" title="0">record := &amp;models.ETCMeisaiRecord{
                Date:          date,
                Time:          row.Time,
                EntranceIC:    row.EntranceIC,
                ExitIC:        row.ExitIC,
                TollAmount:    tollAmount,
                CarNumber:     row.CarNumber,
                ETCCardNumber: row.ETCCardNumber,
        }

        // Set ETC number if provided
        if row.ETCNum != "" </span><span class="cov0" title="0">{
                record.ETCNum = &amp;row.ETCNum
        }</span>

        // Validate and generate hash
        <span class="cov0" title="0">if err := record.BeforeCreate(s.db); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("record validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return record, nil</span>
}

// HandleDuplicates detects and handles duplicate records
func (s *ImportService) HandleDuplicates(ctx context.Context, records []*models.ETCMeisaiRecord) ([]*DuplicateResult, error) <span class="cov0" title="0">{
        s.logger.Printf("Checking for duplicates in %d records", len(records))

        var results []*DuplicateResult

        // Extract hashes from records
        hashes := make([]string, len(records))
        for i, record := range records </span><span class="cov0" title="0">{
                hashes[i] = record.Hash
        }</span>

        // Check for existing records with these hashes
        <span class="cov0" title="0">var existingRecords []*models.ETCMeisaiRecord
        err := s.db.WithContext(ctx).Where("hash IN ?", hashes).Find(&amp;existingRecords).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check for duplicates: %w", err)
        }</span>

        // Create a map of existing records by hash
        <span class="cov0" title="0">existingMap := make(map[string]*models.ETCMeisaiRecord)
        for _, existing := range existingRecords </span><span class="cov0" title="0">{
                existingMap[existing.Hash] = existing
        }</span>

        // Check each record for duplicates
        <span class="cov0" title="0">for _, record := range records </span><span class="cov0" title="0">{
                if existing, found := existingMap[record.Hash]; found </span><span class="cov0" title="0">{
                        result := &amp;DuplicateResult{
                                Hash:           record.Hash,
                                ExistingRecord: existing,
                                NewRecord:      record,
                                Action:         "skip", // Default action for duplicates
                        }
                        results = append(results, result)
                }</span>
        }

        <span class="cov0" title="0">s.logger.Printf("Found %d duplicate records", len(results))
        return results, nil</span>
}

// parseCSVData parses CSV data and returns records and errors
func (s *ImportService) parseCSVData(data io.Reader) ([]*models.ETCMeisaiRecord, []models.ImportError, error) <span class="cov0" title="0">{
        reader := csv.NewReader(data)
        reader.FieldsPerRecord = -1 // Allow variable number of fields

        var records []*models.ETCMeisaiRecord
        var errors []models.ImportError
        rowNumber := 0

        for </span><span class="cov0" title="0">{
                rowNumber++
                row, err := reader.Read()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, models.ImportError{
                                RowNumber:    rowNumber,
                                ErrorType:    "parse_error",
                                ErrorMessage: fmt.Sprintf("Failed to parse CSV row: %v", err),
                                RawData:      strings.Join(row, ","),
                        })
                        continue</span>
                }

                // Skip header row
                <span class="cov0" title="0">if rowNumber == 1 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Ensure minimum number of fields
                <span class="cov0" title="0">if len(row) &lt; 7 </span><span class="cov0" title="0">{
                        errors = append(errors, models.ImportError{
                                RowNumber:    rowNumber,
                                ErrorType:    "insufficient_fields",
                                ErrorMessage: fmt.Sprintf("Row has %d fields, expected at least 7", len(row)),
                                RawData:      strings.Join(row, ","),
                        })
                        continue</span>
                }

                // Create CSV row structure
                <span class="cov0" title="0">csvRow := &amp;CSVRow{
                        Date:          strings.TrimSpace(row[0]),
                        Time:          strings.TrimSpace(row[1]),
                        EntranceIC:    strings.TrimSpace(row[2]),
                        ExitIC:        strings.TrimSpace(row[3]),
                        TollAmount:    strings.TrimSpace(row[4]),
                        CarNumber:     strings.TrimSpace(row[5]),
                        ETCCardNumber: strings.TrimSpace(row[6]),
                }

                // Optional ETC number field
                if len(row) &gt; 7 </span><span class="cov0" title="0">{
                        csvRow.ETCNum = strings.TrimSpace(row[7])
                }</span>

                // Process the row
                <span class="cov0" title="0">record, err := s.ProcessCSVRow(context.Background(), csvRow)
                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, models.ImportError{
                                RowNumber:    rowNumber,
                                ErrorType:    "validation_error",
                                ErrorMessage: err.Error(),
                                RawData:      strings.Join(row, ","),
                        })
                        continue</span>
                }

                <span class="cov0" title="0">records = append(records, record)</span>
        }

        <span class="cov0" title="0">s.logger.Printf("Parsed %d records with %d errors from CSV", len(records), len(errors))
        return records, errors, nil</span>
}

// CancelImportSession cancels an ongoing import session
func (s *ImportService) CancelImportSession(ctx context.Context, sessionID string) error <span class="cov0" title="0">{
        s.logger.Printf("Cancelling import session: %s", sessionID)

        // Start transaction
        tx := s.db.WithContext(ctx).Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start transaction: %w", tx.Error)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        // Get session
        <span class="cov0" title="0">var session models.ImportSession
        err := tx.First(&amp;session, "id = ?", sessionID).Error
        if err == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("import session not found: %s", sessionID)
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("failed to retrieve import session: %w", err)
        }</span>

        // Cancel the session
        <span class="cov0" title="0">if err := session.Cancel(); err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("failed to cancel session: %w", err)
        }</span>

        // Save session
        <span class="cov0" title="0">if err := tx.Save(&amp;session).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("failed to save cancelled session: %w", err)
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err := tx.Commit().Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Printf("Successfully cancelled import session: %s", sessionID)
        return nil</span>
}

// HealthCheck performs health check for the service
func (s *ImportService) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        if s.db == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database not initialized")
        }</span>

        // Check database connectivity
        <span class="cov0" title="0">sqlDB, err := s.db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get database connection: %w", err)
        }</span>

        <span class="cov0" title="0">if err := sqlDB.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("database ping failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">package services

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        // "github.com/yhonda-ohishi/etc_meisai/src/clients" // Commented out - clients package deleted
        "github.com/yhonda-ohishi/etc_meisai/src/models"
        "github.com/yhonda-ohishi/etc_meisai/src/parser"
        // "github.com/yhonda-ohishi/etc_meisai/src/pb" // Commented out - not used when clients package is deleted
        "github.com/yhonda-ohishi/etc_meisai/src/repositories"
)

// ImportServiceLegacy handles CSV import operations (legacy gRPC version)
type ImportServiceLegacy struct {
        dbClient    interface{} // TODO: Replace with proper type when clients package is restored
        etcRepo     repositories.ETCRepository
        mappingRepo repositories.MappingRepository
        parser      *parser.ETCCSVParser
}

// NewImportServiceLegacy creates a new legacy import service
func NewImportServiceLegacy(dbClient interface{}, etcRepo repositories.ETCRepository, mappingRepo repositories.MappingRepository) *ImportServiceLegacy <span class="cov0" title="0">{
        return &amp;ImportServiceLegacy{
                dbClient:    dbClient,
                etcRepo:     etcRepo,
                mappingRepo: mappingRepo,
                parser:      parser.NewETCCSVParser(),
        }
}</span>

// ProcessCSVFile processes a CSV file and imports the data
func (s *ImportServiceLegacy) ProcessCSVFile(ctx context.Context, filePath string, accountID string, importType string) (*models.ETCImportBatch, error) <span class="cov0" title="0">{
        // TODO: Restore when clients package is available
        // Read the CSV file
        // data, err := os.ReadFile(filePath)
        // if err != nil {
        //        return nil, fmt.Errorf("failed to read CSV file: %w", err)
        // }
        //
        // Create import batch via gRPC
        // batchReq := &amp;pb.CreateImportBatchRequest{
        //        FileName:    filepath.Base(filePath),
        //        FileSize:    int64(len(data)),
        //        AccountId:   accountID,
        //        ImportType:  importType,
        //        Status:      "processing",
        //        TotalRows:   0,
        //        ProcessedRows: 0,
        // }
        //
        // batchResp, err := s.dbClient.CreateImportBatch(ctx, batchReq)
        // if err != nil {
        //        return nil, fmt.Errorf("failed to create import batch: %w", err)
        // }
        return nil, fmt.Errorf("CreateImportBatch not available - clients package deleted")

        // TODO: Restore when clients package is available
        // Process CSV data via gRPC
        // processReq := &amp;pb.ProcessCSVDataRequest{
        //        BatchId:    batchResp.Id,
        //        CsvContent: string(data),
        //        AccountId:  accountID,
        // }
        //
        // processResp, err := s.dbClient.ProcessCSVData(ctx, processReq)
        // if err != nil {
        //        return nil, fmt.Errorf("failed to process CSV data: %w", err)
        // }
        //
        // // Convert response to model
        // batch := &amp;models.ETCImportBatch{
        //        ID:            batchResp.Id,
        //        FileName:      batchResp.FileName,
        //        FileSize:      batchResp.FileSize,
        //        AccountID:     batchResp.AccountId,
        //        ImportType:    batchResp.ImportType,
        //        Status:        processResp.Status,
        //        TotalRows:     processResp.TotalRows,
        //        ProcessedRows: processResp.ProcessedRows,
        //        SuccessCount:  processResp.SuccessCount,
        //        ErrorCount:    processResp.ErrorCount,
        //        CreatedAt:     batchResp.CreatedAt.AsTime(),
        //        UpdatedAt:     processResp.UpdatedAt.AsTime(),
        // }
        //
        // if batchResp.CompletedAt != nil {
        //        completedAt := batchResp.CompletedAt.AsTime()
        //        batch.CompletedAt = &amp;completedAt
        // }
        //
        // return batch, nil
}</span>

// ParseAndValidateCSV parses and validates CSV content without importing
func (s *ImportServiceLegacy) ParseAndValidateCSV(ctx context.Context, content string, accountID string) (*parser.ParseResult, error) <span class="cov0" title="0">{
        // Parse CSV content
        result, err := s.parser.Parse(strings.NewReader(content))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse CSV: %w", err)
        }</span>

        // Validate each record
        <span class="cov0" title="0">for _, record := range result.Records </span><span class="cov0" title="0">{
                // Generate hash for duplicate detection
                hash := s.generateRecordHash(record)
                record.Hash = hash

                // Check for duplicates via repository
                existing, err := s.etcRepo.GetByHash(hash)
                if err == nil &amp;&amp; existing != nil </span><span class="cov0" title="0">{
                        result.DuplicateCount++
                }</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

// ImportParsedRecords imports pre-parsed records
func (s *ImportServiceLegacy) ImportParsedRecords(ctx context.Context, records []*models.ETCMeisai, batchID int64) error <span class="cov0" title="0">{
        // Bulk create via repository
        if err := s.etcRepo.BulkInsert(records); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to bulk create records: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetImportProgress gets the progress of an import batch
func (s *ImportServiceLegacy) GetImportProgress(ctx context.Context, batchID int64) (*models.ImportProgress, error) <span class="cov0" title="0">{
        // TODO: Restore when clients package is available
        // req := &amp;pb.GetImportProgressRequest{
        //        BatchId: batchID,
        // }
        //
        // resp, err := s.dbClient.GetImportProgress(ctx, req)
        // if err != nil {
        //        return nil, fmt.Errorf("failed to get import progress: %w", err)
        // }
        return nil, fmt.Errorf("GetImportProgress not available - clients package deleted")

        // TODO: Restore when clients package is available
        // return &amp;models.ImportProgress{
        //        BatchID:       resp.BatchId,
        //        Status:        resp.Status,
        //        TotalRows:     resp.TotalRows,
        //        ProcessedRows: resp.ProcessedRows,
        //        SuccessCount:  resp.SuccessCount,
        //        ErrorCount:    resp.ErrorCount,
        //        Percentage:    resp.Percentage,
        //        Message:       resp.Message,
        //        UpdatedAt:     resp.UpdatedAt.AsTime(),
        // }, nil
}</span>

// generateRecordHash generates a SHA256 hash for duplicate detection
func (s *ImportServiceLegacy) generateRecordHash(record *models.ETCMeisai) string <span class="cov0" title="0">{
        // Create a unique string from key fields
        hashInput := fmt.Sprintf("%s|%s|%s|%s|%s|%s|%d",
                record.ETCNumber,
                record.UseDate.Format("2006-01-02"),
                record.UseTime,
                record.EntryIC,
                record.ExitIC,
                record.CarNumber,
                record.Amount,
        )

        hash := sha256.Sum256([]byte(hashInput))
        return hex.EncodeToString(hash[:])
}</span>

// ValidateImportFile validates an import file before processing
func (s *ImportServiceLegacy) ValidateImportFile(filePath string) error <span class="cov0" title="0">{
        // Check file exists
        info, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("file not found: %w", err)
        }</span>

        // Check file size (max 100MB)
        <span class="cov0" title="0">if info.Size() &gt; 100*1024*1024 </span><span class="cov0" title="0">{
                return fmt.Errorf("file too large: %d bytes (max 100MB)", info.Size())
        }</span>

        // Check file extension
        <span class="cov0" title="0">ext := strings.ToLower(filepath.Ext(filePath))
        if ext != ".csv" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid file type: %s (expected .csv)", ext)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CancelImport cancels an ongoing import
func (s *ImportServiceLegacy) CancelImport(ctx context.Context, batchID int64) error <span class="cov0" title="0">{
        // Update batch status via gRPC
        // This would require adding a CancelImport RPC to the proto definition
        // For now, we'll return an error indicating it's not implemented
        return fmt.Errorf("cancel import not yet implemented in gRPC service")
}</span>

// GetImportHistory retrieves import history for an account
func (s *ImportServiceLegacy) GetImportHistory(ctx context.Context, accountID string, limit int) ([]*models.ETCImportBatch, error) <span class="cov0" title="0">{
        // This would require adding a GetImportHistory RPC to the proto definition
        // For now, return empty list
        return []*models.ETCImportBatch{}, nil
}</span>

// RetryImport retries a failed import batch
func (s *ImportServiceLegacy) RetryImport(ctx context.Context, batchID int64) (*models.ETCImportBatch, error) <span class="cov0" title="0">{
        // Get the original batch details
        _, err := s.GetImportProgress(ctx, batchID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get batch details: %w", err)
        }</span>

        // Create a new batch for retry
        // This would require storing the original CSV content or file path
        <span class="cov0" title="0">return nil, fmt.Errorf("retry import requires stored CSV content: not yet implemented")</span>
}

// HealthCheck performs a health check on the import service
func (s *ImportServiceLegacy) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        // Check gRPC client connectivity
        if s.dbClient == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("db client not initialized")
        }</span>

        // Try to get progress for a non-existent batch to test connectivity
        <span class="cov0" title="0">_, err := s.GetImportProgress(ctx, -1)
        if err != nil &amp;&amp; !strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                return fmt.Errorf("import service health check failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file7" style="display: none">package services

import (
        "context"
        "fmt"
        "sync"
        "time"
)

// JobStatus represents the status of a job
type JobStatus string

const (
        JobStatusPending   JobStatus = "pending"
        JobStatusRunning   JobStatus = "running"
        JobStatusCompleted JobStatus = "completed"
        JobStatusFailed    JobStatus = "failed"
        JobStatusCanceled  JobStatus = "canceled"
)

// Job represents an async job
type Job struct {
        ID          string
        Type        string
        Status      JobStatus
        Progress    int
        Total       int
        Result      interface{}
        Error       error
        CreatedAt   time.Time
        StartedAt   *time.Time
        CompletedAt *time.Time
        Context     context.Context
        Cancel      context.CancelFunc
}

// JobService manages async jobs
type JobService struct {
        jobs       map[string]*Job
        mu         sync.RWMutex
        maxWorkers int
        queue      chan *Job
        wg         sync.WaitGroup
}

// NewJobService creates a new job service
func NewJobService(maxWorkers int) *JobService <span class="cov0" title="0">{
        if maxWorkers &lt;= 0 </span><span class="cov0" title="0">{
                maxWorkers = 5
        }</span>

        <span class="cov0" title="0">js := &amp;JobService{
                jobs:       make(map[string]*Job),
                maxWorkers: maxWorkers,
                queue:      make(chan *Job, 100),
        }

        // Start workers
        for i := 0; i &lt; maxWorkers; i++ </span><span class="cov0" title="0">{
                go js.worker()
        }</span>

        <span class="cov0" title="0">return js</span>
}

// CreateJob creates a new job
func (s *JobService) CreateJob(jobType string) *Job <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        job := &amp;Job{
                ID:        fmt.Sprintf("%s_%d", jobType, time.Now().UnixNano()),
                Type:      jobType,
                Status:    JobStatusPending,
                Progress:  0,
                Total:     100,
                CreatedAt: time.Now(),
                Context:   ctx,
                Cancel:    cancel,
        }

        s.mu.Lock()
        s.jobs[job.ID] = job
        s.mu.Unlock()

        return job
}</span>

// SubmitJob submits a job for execution
func (s *JobService) SubmitJob(job *Job, fn func(*Job) error) <span class="cov0" title="0">{
        s.wg.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer s.wg.Done()

                // Add to queue
                s.queue &lt;- job

                // Wait for execution
                &lt;-job.Context.Done()
        }</span>()

        // Store the execution function
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                // Wait for worker to pick up
                for </span><span class="cov0" title="0">{
                        s.mu.RLock()
                        if job.Status == JobStatusRunning </span><span class="cov0" title="0">{
                                s.mu.RUnlock()
                                break</span>
                        }
                        <span class="cov0" title="0">s.mu.RUnlock()
                        time.Sleep(10 * time.Millisecond)</span>
                }

                // Execute job
                <span class="cov0" title="0">err := fn(job)

                // Update job status
                s.mu.Lock()
                if err != nil </span><span class="cov0" title="0">{
                        job.Status = JobStatusFailed
                        job.Error = err
                }</span> else<span class="cov0" title="0"> {
                        job.Status = JobStatusCompleted
                        job.Progress = job.Total
                }</span>
                <span class="cov0" title="0">now := time.Now()
                job.CompletedAt = &amp;now
                s.mu.Unlock()

                // Signal completion
                job.Cancel()</span>
        }()
}

// worker processes jobs from the queue
func (s *JobService) worker() <span class="cov0" title="0">{
        for job := range s.queue </span><span class="cov0" title="0">{
                s.mu.Lock()
                job.Status = JobStatusRunning
                now := time.Now()
                job.StartedAt = &amp;now
                s.mu.Unlock()

                // Job will be executed by the goroutine in SubmitJob
                // Worker just marks it as running
        }</span>
}

// GetJob retrieves a job by ID
func (s *JobService) GetJob(jobID string) (*Job, error) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        job, exists := s.jobs[jobID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("job not found: %s", jobID)
        }</span>

        <span class="cov0" title="0">return job, nil</span>
}

// UpdateProgress updates job progress
func (s *JobService) UpdateProgress(jobID string, progress int) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        job, exists := s.jobs[jobID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("job not found: %s", jobID)
        }</span>

        <span class="cov0" title="0">job.Progress = progress
        return nil</span>
}

// CancelJob cancels a running job
func (s *JobService) CancelJob(jobID string) error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        job, exists := s.jobs[jobID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("job not found: %s", jobID)
        }</span>

        <span class="cov0" title="0">if job.Status == JobStatusRunning || job.Status == JobStatusPending </span><span class="cov0" title="0">{
                job.Status = JobStatusCanceled
                job.Cancel()
                now := time.Now()
                job.CompletedAt = &amp;now
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetAllJobs returns all jobs
func (s *JobService) GetAllJobs() []*Job <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        jobs := make([]*Job, 0, len(s.jobs))
        for _, job := range s.jobs </span><span class="cov0" title="0">{
                jobs = append(jobs, job)
        }</span>

        <span class="cov0" title="0">return jobs</span>
}

// GetJobsByStatus returns jobs filtered by status
func (s *JobService) GetJobsByStatus(status JobStatus) []*Job <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        var jobs []*Job
        for _, job := range s.jobs </span><span class="cov0" title="0">{
                if job.Status == status </span><span class="cov0" title="0">{
                        jobs = append(jobs, job)
                }</span>
        }

        <span class="cov0" title="0">return jobs</span>
}

// CleanupOldJobs removes completed jobs older than specified duration
func (s *JobService) CleanupOldJobs(maxAge time.Duration) int <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        cutoff := time.Now().Add(-maxAge)
        removed := 0

        for id, job := range s.jobs </span><span class="cov0" title="0">{
                if job.Status == JobStatusCompleted || job.Status == JobStatusFailed || job.Status == JobStatusCanceled </span><span class="cov0" title="0">{
                        if job.CompletedAt != nil &amp;&amp; job.CompletedAt.Before(cutoff) </span><span class="cov0" title="0">{
                                delete(s.jobs, id)
                                removed++
                        }</span>
                }
        }

        <span class="cov0" title="0">return removed</span>
}

// GetStats returns job statistics
func (s *JobService) GetStats() map[string]interface{} <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        stats := map[string]int{
                "total":     len(s.jobs),
                "pending":   0,
                "running":   0,
                "completed": 0,
                "failed":    0,
                "canceled":  0,
        }

        for _, job := range s.jobs </span><span class="cov0" title="0">{
                switch job.Status </span>{
                case JobStatusPending:<span class="cov0" title="0">
                        stats["pending"]++</span>
                case JobStatusRunning:<span class="cov0" title="0">
                        stats["running"]++</span>
                case JobStatusCompleted:<span class="cov0" title="0">
                        stats["completed"]++</span>
                case JobStatusFailed:<span class="cov0" title="0">
                        stats["failed"]++</span>
                case JobStatusCanceled:<span class="cov0" title="0">
                        stats["canceled"]++</span>
                }
        }

        <span class="cov0" title="0">return map[string]interface{}{
                "stats":      stats,
                "maxWorkers": s.maxWorkers,
                "queueSize":  len(s.queue),
        }</span>
}

// Shutdown gracefully shuts down the job service
func (s *JobService) Shutdown() <span class="cov0" title="0">{
        // Cancel all pending/running jobs
        s.mu.Lock()
        for _, job := range s.jobs </span><span class="cov0" title="0">{
                if job.Status == JobStatusPending || job.Status == JobStatusRunning </span><span class="cov0" title="0">{
                        job.Cancel()
                }</span>
        }
        <span class="cov0" title="0">s.mu.Unlock()

        // Close queue
        close(s.queue)

        // Wait for workers to finish
        s.wg.Wait()</span>
}</pre>
		
		<pre class="file" id="file8" style="display: none">package services

import (
        "encoding/json"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "sync"
        "time"
)

// LogLevel represents the severity of a log entry
type LogLevel string

const (
        LogLevelDebug LogLevel = "DEBUG"
        LogLevelInfo  LogLevel = "INFO"
        LogLevelWarn  LogLevel = "WARN"
        LogLevelError LogLevel = "ERROR"
        LogLevelFatal LogLevel = "FATAL"
)

// LogEntry represents a structured log entry
type LogEntry struct {
        Timestamp   time.Time              `json:"timestamp"`
        Level       LogLevel               `json:"level"`
        Message     string                 `json:"message"`
        Service     string                 `json:"service"`
        Method      string                 `json:"method,omitempty"`
        RequestID   string                 `json:"request_id,omitempty"`
        UserID      string                 `json:"user_id,omitempty"`
        Duration    *time.Duration         `json:"duration_ms,omitempty"`
        Error       string                 `json:"error,omitempty"`
        Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

// LoggingService provides structured logging
type LoggingService struct {
        logger      *log.Logger
        level       LogLevel
        serviceName string
        logFile     *os.File
        mu          sync.Mutex
        metrics     *LogMetrics
}

// LogMetrics tracks logging metrics
type LogMetrics struct {
        TotalLogs    int64
        ErrorCount   int64
        WarnCount    int64
        InfoCount    int64
        DebugCount   int64
        LastLogTime  time.Time
        mu           sync.RWMutex
}

// NewLoggingService creates a new logging service
func NewLoggingService(serviceName string, logLevel LogLevel) (*LoggingService, error) <span class="cov0" title="0">{
        // Create logs directory
        logDir := "./logs"
        if err := os.MkdirAll(logDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create log directory: %w", err)
        }</span>

        // Create log file with date
        <span class="cov0" title="0">logFileName := fmt.Sprintf("%s_%s.log", serviceName, time.Now().Format("2006-01-02"))
        logPath := filepath.Join(logDir, logFileName)

        logFile, err := os.OpenFile(logPath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open log file: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;LoggingService{
                logger:      log.New(logFile, "", 0),
                level:       logLevel,
                serviceName: serviceName,
                logFile:     logFile,
                metrics:     &amp;LogMetrics{},
        }, nil</span>
}

// Debug logs a debug message
func (s *LoggingService) Debug(message string, metadata map[string]interface{}) <span class="cov0" title="0">{
        if s.shouldLog(LogLevelDebug) </span><span class="cov0" title="0">{
                s.log(LogLevelDebug, message, nil, metadata)
                s.updateMetrics(LogLevelDebug)
        }</span>
}

// Info logs an info message
func (s *LoggingService) Info(message string, metadata map[string]interface{}) <span class="cov0" title="0">{
        if s.shouldLog(LogLevelInfo) </span><span class="cov0" title="0">{
                s.log(LogLevelInfo, message, nil, metadata)
                s.updateMetrics(LogLevelInfo)
        }</span>
}

// Warn logs a warning message
func (s *LoggingService) Warn(message string, metadata map[string]interface{}) <span class="cov0" title="0">{
        if s.shouldLog(LogLevelWarn) </span><span class="cov0" title="0">{
                s.log(LogLevelWarn, message, nil, metadata)
                s.updateMetrics(LogLevelWarn)
        }</span>
}

// Error logs an error message
func (s *LoggingService) Error(message string, err error, metadata map[string]interface{}) <span class="cov0" title="0">{
        if s.shouldLog(LogLevelError) </span><span class="cov0" title="0">{
                s.log(LogLevelError, message, err, metadata)
                s.updateMetrics(LogLevelError)
        }</span>
}

// Fatal logs a fatal error and exits
func (s *LoggingService) Fatal(message string, err error, metadata map[string]interface{}) <span class="cov0" title="0">{
        s.log(LogLevelFatal, message, err, metadata)
        s.updateMetrics(LogLevelFatal)
        s.Close()
        os.Exit(1)
}</span>

// LogOperation logs an operation with duration
func (s *LoggingService) LogOperation(operation string, startTime time.Time, err error, metadata map[string]interface{}) <span class="cov0" title="0">{
        duration := time.Since(startTime)

        entry := LogEntry{
                Timestamp:   time.Now(),
                Service:     s.serviceName,
                Method:      operation,
                Duration:    &amp;duration,
                Metadata:    metadata,
        }

        if err != nil </span><span class="cov0" title="0">{
                entry.Level = LogLevelError
                entry.Message = fmt.Sprintf("Operation failed: %s", operation)
                entry.Error = err.Error()
                s.updateMetrics(LogLevelError)
        }</span> else<span class="cov0" title="0"> {
                entry.Level = LogLevelInfo
                entry.Message = fmt.Sprintf("Operation completed: %s", operation)
                s.updateMetrics(LogLevelInfo)
        }</span>

        <span class="cov0" title="0">s.writeEntry(entry)</span>
}

// LogHTTPRequest logs an HTTP request
func (s *LoggingService) LogHTTPRequest(method, path string, statusCode int, duration time.Duration, metadata map[string]interface{}) <span class="cov0" title="0">{
        level := LogLevelInfo
        if statusCode &gt;= 500 </span><span class="cov0" title="0">{
                level = LogLevelError
        }</span> else<span class="cov0" title="0"> if statusCode &gt;= 400 </span><span class="cov0" title="0">{
                level = LogLevelWarn
        }</span>

        <span class="cov0" title="0">if metadata == nil </span><span class="cov0" title="0">{
                metadata = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">metadata["method"] = method
        metadata["path"] = path
        metadata["status_code"] = statusCode

        entry := LogEntry{
                Timestamp: time.Now(),
                Level:     level,
                Service:   s.serviceName,
                Message:   fmt.Sprintf("HTTP %s %s - %d", method, path, statusCode),
                Duration:  &amp;duration,
                Metadata:  metadata,
        }

        s.writeEntry(entry)
        s.updateMetrics(level)</span>
}

// log creates and writes a log entry
func (s *LoggingService) log(level LogLevel, message string, err error, metadata map[string]interface{}) <span class="cov0" title="0">{
        entry := LogEntry{
                Timestamp: time.Now(),
                Level:     level,
                Service:   s.serviceName,
                Message:   message,
                Metadata:  metadata,
        }

        if err != nil </span><span class="cov0" title="0">{
                entry.Error = err.Error()
        }</span>

        <span class="cov0" title="0">s.writeEntry(entry)</span>
}

// writeEntry writes a log entry to file
func (s *LoggingService) writeEntry(entry LogEntry) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        jsonData, err := json.Marshal(entry)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to plain text logging
                s.logger.Printf("[%s] %s: %s\n", entry.Level, entry.Service, entry.Message)
                return
        }</span>

        <span class="cov0" title="0">s.logger.Println(string(jsonData))</span>
}

// shouldLog checks if a message should be logged based on level
func (s *LoggingService) shouldLog(level LogLevel) bool <span class="cov0" title="0">{
        levelMap := map[LogLevel]int{
                LogLevelDebug: 0,
                LogLevelInfo:  1,
                LogLevelWarn:  2,
                LogLevelError: 3,
                LogLevelFatal: 4,
        }

        return levelMap[level] &gt;= levelMap[s.level]
}</span>

// updateMetrics updates logging metrics
func (s *LoggingService) updateMetrics(level LogLevel) <span class="cov0" title="0">{
        s.metrics.mu.Lock()
        defer s.metrics.mu.Unlock()

        s.metrics.TotalLogs++
        s.metrics.LastLogTime = time.Now()

        switch level </span>{
        case LogLevelDebug:<span class="cov0" title="0">
                s.metrics.DebugCount++</span>
        case LogLevelInfo:<span class="cov0" title="0">
                s.metrics.InfoCount++</span>
        case LogLevelWarn:<span class="cov0" title="0">
                s.metrics.WarnCount++</span>
        case LogLevelError, LogLevelFatal:<span class="cov0" title="0">
                s.metrics.ErrorCount++</span>
        }
}

// GetMetrics returns logging metrics
func (s *LoggingService) GetMetrics() LogMetrics <span class="cov0" title="0">{
        s.metrics.mu.RLock()
        defer s.metrics.mu.RUnlock()

        return *s.metrics
}</span>

// SetLevel changes the logging level
func (s *LoggingService) SetLevel(level LogLevel) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.level = level
}</span>

// RotateLog rotates the log file
func (s *LoggingService) RotateLog() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Close current file
        if s.logFile != nil </span><span class="cov0" title="0">{
                s.logFile.Close()
        }</span>

        // Create new log file
        <span class="cov0" title="0">logDir := "./logs"
        logFileName := fmt.Sprintf("%s_%s.log", s.serviceName, time.Now().Format("2006-01-02_15-04-05"))
        logPath := filepath.Join(logDir, logFileName)

        logFile, err := os.OpenFile(logPath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create new log file: %w", err)
        }</span>

        <span class="cov0" title="0">s.logFile = logFile
        s.logger = log.New(logFile, "", 0)

        return nil</span>
}

// Close closes the logging service
func (s *LoggingService) Close() error <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.logFile != nil </span><span class="cov0" title="0">{
                return s.logFile.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreateRequestLogger creates a logger with request context
func (s *LoggingService) CreateRequestLogger(requestID, userID string) *RequestLogger <span class="cov0" title="0">{
        return &amp;RequestLogger{
                service:   s,
                requestID: requestID,
                userID:    userID,
                startTime: time.Now(),
        }
}</span>

// RequestLogger provides request-scoped logging
type RequestLogger struct {
        service   *LoggingService
        requestID string
        userID    string
        startTime time.Time
}

// Info logs info with request context
func (r *RequestLogger) Info(message string, metadata map[string]interface{}) <span class="cov0" title="0">{
        if metadata == nil </span><span class="cov0" title="0">{
                metadata = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">metadata["request_id"] = r.requestID
        metadata["user_id"] = r.userID
        r.service.Info(message, metadata)</span>
}

// Error logs error with request context
func (r *RequestLogger) Error(message string, err error, metadata map[string]interface{}) <span class="cov0" title="0">{
        if metadata == nil </span><span class="cov0" title="0">{
                metadata = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">metadata["request_id"] = r.requestID
        metadata["user_id"] = r.userID
        r.service.Error(message, err, metadata)</span>
}

// Complete logs request completion
func (r *RequestLogger) Complete() <span class="cov0" title="0">{
        metadata := map[string]interface{}{
                "request_id": r.requestID,
                "user_id":    r.userID,
        }
        r.service.LogOperation("request", r.startTime, nil, metadata)
}</pre>
		
		<pre class="file" id="file9" style="display: none">package services

import (
        "context"
        "fmt"
        "time"

        "github.com/yhonda-ohishi/etc_meisai/src/models"
        "github.com/yhonda-ohishi/etc_meisai/src/repositories"
)

// MappingService handles ETC-DTako mapping operations
type MappingService struct {
        mappingRepo repositories.MappingRepository
        etcRepo     repositories.ETCRepository
}

// NewMappingService creates a new mapping service
func NewMappingService(mappingRepo repositories.MappingRepository, etcRepo repositories.ETCRepository) *MappingService <span class="cov0" title="0">{
        return &amp;MappingService{
                mappingRepo: mappingRepo,
                etcRepo:     etcRepo,
        }
}</span>

// CreateMapping creates a new mapping between ETC and DTako records
func (s *MappingService) CreateMapping(ctx context.Context, mapping *models.ETCMeisaiMapping) error <span class="cov0" title="0">{
        // Validate ETC Meisai exists
        _, err := s.etcRepo.GetByID(mapping.ETCMeisaiID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ETC Meisai record not found: %w", err)
        }</span>

        // Check for existing mapping
        <span class="cov0" title="0">existing, err := s.mappingRepo.GetByETCMeisaiID(mapping.ETCMeisaiID)
        if err == nil &amp;&amp; len(existing) &gt; 0 </span><span class="cov0" title="0">{
                // If mapping exists, update it instead
                existing[0].DTakoRowID = mapping.DTakoRowID
                existing[0].MappingType = mapping.MappingType
                existing[0].Confidence = mapping.Confidence
                existing[0].Notes = mapping.Notes
                return s.mappingRepo.Update(existing[0])
        }</span>

        // Create new mapping
        <span class="cov0" title="0">mapping.CreatedAt = time.Now()
        mapping.UpdatedAt = time.Now()

        return s.mappingRepo.Create(mapping)</span>
}

// GetMappingByID retrieves a mapping by its ID
func (s *MappingService) GetMappingByID(ctx context.Context, id int64) (*models.ETCMeisaiMapping, error) <span class="cov0" title="0">{
        return s.mappingRepo.GetByID(id)
}</span>

// GetMappingsByETCMeisaiID retrieves all mappings for an ETC Meisai record
func (s *MappingService) GetMappingsByETCMeisaiID(ctx context.Context, etcMeisaiID int64) ([]*models.ETCMeisaiMapping, error) <span class="cov0" title="0">{
        return s.mappingRepo.GetByETCMeisaiID(etcMeisaiID)
}</span>

// GetMappingByDTakoRowID retrieves a mapping by DTako row ID
func (s *MappingService) GetMappingByDTakoRowID(ctx context.Context, dtakoRowID string) (*models.ETCMeisaiMapping, error) <span class="cov0" title="0">{
        return s.mappingRepo.GetByDTakoRowID(dtakoRowID)
}</span>

// ListMappings lists mappings with pagination and filters
func (s *MappingService) ListMappings(ctx context.Context, params *models.MappingListParams) ([]*models.ETCMeisaiMapping, int64, error) <span class="cov0" title="0">{
        // Set defaults
        if params == nil </span><span class="cov0" title="0">{
                params = &amp;models.MappingListParams{
                        Limit:  100,
                        Offset: 0,
                }
        }</span>
        <span class="cov0" title="0">if params.Limit &lt;= 0 </span><span class="cov0" title="0">{
                params.Limit = 100
        }</span>
        <span class="cov0" title="0">if params.Limit &gt; 1000 </span><span class="cov0" title="0">{
                params.Limit = 1000
        }</span>

        <span class="cov0" title="0">mappings, total, err := s.mappingRepo.List(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // Ensure non-nil slice
        <span class="cov0" title="0">if mappings == nil </span><span class="cov0" title="0">{
                mappings = []*models.ETCMeisaiMapping{}
        }</span>

        <span class="cov0" title="0">return mappings, total, nil</span>
}

// UpdateMapping updates an existing mapping
func (s *MappingService) UpdateMapping(ctx context.Context, id int64, updates map[string]interface{}) error <span class="cov0" title="0">{
        // Get existing mapping
        mapping, err := s.mappingRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mapping not found: %w", err)
        }</span>

        // Apply updates
        <span class="cov0" title="0">if mappingType, ok := updates["mapping_type"].(string); ok </span><span class="cov0" title="0">{
                mapping.MappingType = mappingType
        }</span>
        <span class="cov0" title="0">if confidence, ok := updates["confidence"].(float32); ok </span><span class="cov0" title="0">{
                mapping.Confidence = confidence
        }</span>
        <span class="cov0" title="0">if notes, ok := updates["notes"].(string); ok </span><span class="cov0" title="0">{
                mapping.Notes = notes
        }</span>

        <span class="cov0" title="0">mapping.UpdatedAt = time.Now()

        return s.mappingRepo.Update(mapping)</span>
}

// DeleteMapping deletes a mapping
func (s *MappingService) DeleteMapping(ctx context.Context, id int64) error <span class="cov0" title="0">{
        return s.mappingRepo.Delete(id)
}</span>

// DeleteMappingsByETCMeisaiID deletes all mappings for an ETC Meisai record
func (s *MappingService) DeleteMappingsByETCMeisaiID(ctx context.Context, etcMeisaiID int64) error <span class="cov0" title="0">{
        return s.mappingRepo.DeleteByETCMeisaiID(etcMeisaiID)
}</span>

// AutoMatch finds potential matches for unmapped ETC records
func (s *MappingService) AutoMatch(ctx context.Context, startDate, endDate time.Time, threshold float32) ([]*models.AutoMatchResult, error) <span class="cov0" title="0">{
        // Get unmapped ETC records
        unmapped, err := s.etcRepo.GetByDateRange(startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get unmapped records: %w", err)
        }</span>

        <span class="cov0" title="0">results := make([]*models.AutoMatchResult, 0)

        for _, etcRecord := range unmapped </span><span class="cov0" title="0">{
                // Check if already mapped
                existing, err := s.mappingRepo.GetByETCMeisaiID(etcRecord.ID)
                if err == nil &amp;&amp; len(existing) &gt; 0 </span><span class="cov0" title="0">{
                        continue</span> // Already mapped
                }

                // Find potential matches
                <span class="cov0" title="0">matches, err := s.mappingRepo.FindPotentialMatches(etcRecord.ID, threshold)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but continue with other records
                        results = append(results, &amp;models.AutoMatchResult{
                                ETCMeisaiID: etcRecord.ID,
                                Error:       err.Error(),
                        })
                        continue</span>
                }

                <span class="cov0" title="0">if len(matches) &gt; 0 </span><span class="cov0" title="0">{
                        results = append(results, &amp;models.AutoMatchResult{
                                ETCMeisaiID:      etcRecord.ID,
                                PotentialMatches: matches,
                                BestMatch:        matches[0], // Assuming sorted by confidence
                        })
                }</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// BulkCreateMappings creates multiple mappings at once
func (s *MappingService) BulkCreateMappings(ctx context.Context, mappings []*models.ETCMeisaiMapping) error <span class="cov0" title="0">{
        // Validate all ETC Meisai records exist
        for _, mapping := range mappings </span><span class="cov0" title="0">{
                _, err := s.etcRepo.GetByID(mapping.ETCMeisaiID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("ETC Meisai record %d not found: %w", mapping.ETCMeisaiID, err)
                }</span>
        }

        // Set timestamps
        <span class="cov0" title="0">now := time.Now()
        for _, mapping := range mappings </span><span class="cov0" title="0">{
                mapping.CreatedAt = now
                mapping.UpdatedAt = now
        }</span>

        <span class="cov0" title="0">return s.mappingRepo.BulkCreateMappings(mappings)</span>
}

// UpdateConfidenceScore updates the confidence score of a mapping
func (s *MappingService) UpdateConfidenceScore(ctx context.Context, id int64, confidence float32) error <span class="cov0" title="0">{
        // Validate confidence range
        if confidence &lt; 0 || confidence &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("confidence must be between 0 and 1")
        }</span>

        <span class="cov0" title="0">return s.mappingRepo.UpdateConfidenceScore(id, confidence)</span>
}

// GetMappingStats returns statistics about mappings
func (s *MappingService) GetMappingStats(ctx context.Context, startDate, endDate time.Time) (*models.MappingStats, error) <span class="cov0" title="0">{
        // Get all mappings
        params := &amp;models.MappingListParams{
                Limit:  10000,
                Offset: 0,
        }

        mappings, total, err := s.mappingRepo.List(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get mappings: %w", err)
        }</span>

        <span class="cov0" title="0">stats := &amp;models.MappingStats{
                TotalMappings: total,
        }

        var totalConfidence float32
        for _, mapping := range mappings </span><span class="cov0" title="0">{
                if mapping.MappingType == "auto" </span><span class="cov0" title="0">{
                        stats.AutoMappings++
                }</span> else<span class="cov0" title="0"> {
                        stats.ManualMappings++
                }</span>

                <span class="cov0" title="0">if mapping.Confidence &gt;= 0.8 </span><span class="cov0" title="0">{
                        stats.HighConfidence++
                }</span> else<span class="cov0" title="0"> {
                        stats.LowConfidence++
                }</span>

                <span class="cov0" title="0">totalConfidence += mapping.Confidence</span>
        }

        <span class="cov0" title="0">if len(mappings) &gt; 0 </span><span class="cov0" title="0">{
                stats.AverageConfidence = totalConfidence / float32(len(mappings))
        }</span>

        // Count unmapped records
        <span class="cov0" title="0">etcCount, err := s.etcRepo.CountByDateRange(startDate, endDate)
        if err == nil </span><span class="cov0" title="0">{
                stats.UnmappedRecords = etcCount - total
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

// HealthCheck performs a health check on the mapping service
func (s *MappingService) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        // Try to list one mapping to verify connectivity
        params := &amp;models.MappingListParams{
                Limit:  1,
                Offset: 0,
        }

        _, _, err := s.mappingRepo.List(params)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mapping service health check failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file10" style="display: none">package services

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/yhonda-ohishi/etc_meisai/src/repositories"
)

// StatisticsFilter re-exported from original service
type StatisticsFilter struct {
        DateFrom      *time.Time `json:"date_from,omitempty"`
        DateTo        *time.Time `json:"date_to,omitempty"`
        CarNumbers    []string   `json:"car_numbers,omitempty"`
        ETCNumbers    []string   `json:"etc_numbers,omitempty"`
        ETCNums       []string   `json:"etc_nums,omitempty"`
        EntranceICs   []string   `json:"entrance_ics,omitempty"`
        ExitICs       []string   `json:"exit_ics,omitempty"`
        MinTollAmount *int       `json:"min_toll_amount,omitempty"`
        MaxTollAmount *int       `json:"max_toll_amount,omitempty"`
}

// GeneralStatistics contains general statistics
type GeneralStatistics struct {
        DateRange         string  `json:"date_range"`
        TotalRecords      int64   `json:"total_records"`
        TotalAmount       int64   `json:"total_amount"`
        AverageAmount     float64 `json:"average_amount"`
        UniqueVehicles    int64   `json:"unique_vehicles"`
        UniqueCards       int64   `json:"unique_cards"`
        UniqueEntranceICs int64   `json:"unique_entrance_ics"`
        UniqueExitICs     int64   `json:"unique_exit_ics"`
        TopRoutes         []RouteStatistic    `json:"top_routes"`
        TopVehicles       []VehicleStatistic  `json:"top_vehicles"`
        TopCards          []CardStatistic     `json:"top_cards"`
        HourlyDistribution []HourlyStatistic  `json:"hourly_distribution"`
}

// RouteStatistic contains route usage statistics
type RouteStatistic struct {
        EntranceIC  string  `json:"entrance_ic"`
        ExitIC      string  `json:"exit_ic"`
        Count       int64   `json:"count"`
        TotalAmount int64   `json:"total_amount"`
        AvgAmount   float64 `json:"avg_amount"`
}

// VehicleStatistic contains vehicle usage statistics
type VehicleStatistic struct {
        CarNumber   string  `json:"car_number"`
        Count       int64   `json:"count"`
        TotalAmount int64   `json:"total_amount"`
        AvgAmount   float64 `json:"avg_amount"`
}

// CardStatistic contains ETC card usage statistics
type CardStatistic struct {
        ETCCardNumber string  `json:"etc_card_number"`
        Count         int64   `json:"count"`
        TotalAmount   int64   `json:"total_amount"`
        AvgAmount     float64 `json:"avg_amount"`
}

// HourlyStatistic contains hourly usage statistics
type HourlyStatistic struct {
        Hour        int     `json:"hour"`
        HourLabel   string  `json:"hour_label"`
        Count       int64   `json:"count"`
        TotalAmount int64   `json:"total_amount"`
        AvgAmount   float64 `json:"avg_amount"`
}

// DailyStatistic for service layer
type DailyStatistic struct {
        Date        string  `json:"date"`
        Count       int64   `json:"count"`
        TotalAmount int64   `json:"total_amount"`
        AvgAmount   float64 `json:"avg_amount"`
}

// MonthlyStatistic for service layer
type MonthlyStatistic struct {
        Year        int     `json:"year"`
        Month       int     `json:"month"`
        MonthName   string  `json:"month_name"`
        Count       int64   `json:"count"`
        TotalAmount int64   `json:"total_amount"`
        AvgAmount   float64 `json:"avg_amount"`
}

// Response types
type DailyStatisticsResponse struct {
        DateRange  string           `json:"date_range"`
        Statistics []DailyStatistic `json:"statistics"`
}

type MonthlyStatisticsResponse struct {
        DateRange  string             `json:"date_range"`
        Statistics []MonthlyStatistic `json:"statistics"`
}

type VehicleStatisticsResponse struct {
        DateRange string             `json:"date_range"`
        Vehicles  []VehicleStatistic `json:"vehicles"`
}

type MappingStatisticsResponse struct {
        DateRange             string  `json:"date_range"`
        TotalRecords          int64   `json:"total_records"`
        MappedRecords         int64   `json:"mapped_records"`
        UnmappedRecords       int64   `json:"unmapped_records"`
        MappingRate           float64 `json:"mapping_rate"`
        MappingRatePercentage string  `json:"mapping_rate_percentage"`
}

// StatisticsService handles analytics and statistics using repository pattern
type StatisticsService struct {
        statsRepo repositories.StatisticsRepository
        logger    *log.Logger
}

// NewStatisticsService creates a new statistics service with repository pattern
func NewStatisticsService(statsRepo repositories.StatisticsRepository, logger *log.Logger) *StatisticsService <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                logger = log.New(log.Writer(), "[StatisticsService] ", log.LstdFlags|log.Lshortfile)
        }</span>

        <span class="cov0" title="0">return &amp;StatisticsService{
                statsRepo: statsRepo,
                logger:    logger,
        }</span>
}

// GetGeneralStatistics retrieves general statistics based on filter
func (s *StatisticsService) GetGeneralStatistics(ctx context.Context, filter *StatisticsFilter) (*GeneralStatistics, error) <span class="cov0" title="0">{
        s.logger.Printf("Generating general statistics")

        // Convert service filter to repository filter
        repoFilter := s.toRepoFilter(filter)

        // Get basic counts
        totalRecords, err := s.statsRepo.CountRecords(ctx, repoFilter)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to count records: %v", err)
                return nil, fmt.Errorf("failed to count records: %w", err)
        }</span>

        <span class="cov0" title="0">totalAmount, err := s.statsRepo.SumTollAmount(ctx, repoFilter)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to sum toll amount: %v", err)
                return nil, fmt.Errorf("failed to sum toll amount: %w", err)
        }</span>

        <span class="cov0" title="0">avgAmount, err := s.statsRepo.AverageTollAmount(ctx, repoFilter)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to calculate average toll amount: %v", err)
                return nil, fmt.Errorf("failed to calculate average toll amount: %w", err)
        }</span>

        <span class="cov0" title="0">uniqueVehicles, err := s.statsRepo.CountUniqueVehicles(ctx, repoFilter)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to count unique vehicles: %v", err)
                return nil, fmt.Errorf("failed to count unique vehicles: %w", err)
        }</span>

        <span class="cov0" title="0">uniqueCards, err := s.statsRepo.CountUniqueCards(ctx, repoFilter)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to count unique cards: %v", err)
                return nil, fmt.Errorf("failed to count unique cards: %w", err)
        }</span>

        <span class="cov0" title="0">uniqueEntranceICs, err := s.statsRepo.CountUniqueEntranceICs(ctx, repoFilter)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to count unique entrance ICs: %v", err)
                return nil, fmt.Errorf("failed to count unique entrance ICs: %w", err)
        }</span>

        <span class="cov0" title="0">uniqueExitICs, err := s.statsRepo.CountUniqueExitICs(ctx, repoFilter)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to count unique exit ICs: %v", err)
                return nil, fmt.Errorf("failed to count unique exit ICs: %w", err)
        }</span>

        // Get top statistics
        <span class="cov0" title="0">topRoutes, err := s.statsRepo.GetTopRoutes(ctx, repoFilter, 10)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to get top routes: %v", err)
                return nil, fmt.Errorf("failed to get top routes: %w", err)
        }</span>

        <span class="cov0" title="0">topVehicles, err := s.statsRepo.GetTopVehicles(ctx, repoFilter, 10)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to get top vehicles: %v", err)
                return nil, fmt.Errorf("failed to get top vehicles: %w", err)
        }</span>

        <span class="cov0" title="0">topCards, err := s.statsRepo.GetTopCards(ctx, repoFilter, 10)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to get top cards: %v", err)
                return nil, fmt.Errorf("failed to get top cards: %w", err)
        }</span>

        <span class="cov0" title="0">hourlyDist, err := s.statsRepo.GetHourlyDistribution(ctx, repoFilter)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to get hourly distribution: %v", err)
                return nil, fmt.Errorf("failed to get hourly distribution: %w", err)
        }</span>

        // Format date range
        <span class="cov0" title="0">dateRange := s.formatDateRange(filter)

        // Convert repository types to service types
        stats := &amp;GeneralStatistics{
                DateRange:          dateRange,
                TotalRecords:       totalRecords,
                TotalAmount:        totalAmount,
                AverageAmount:      avgAmount,
                UniqueVehicles:     uniqueVehicles,
                UniqueCards:        uniqueCards,
                UniqueEntranceICs:  uniqueEntranceICs,
                UniqueExitICs:      uniqueExitICs,
                TopRoutes:          s.convertRouteStats(topRoutes),
                TopVehicles:        s.convertVehicleStats(topVehicles),
                TopCards:           s.convertCardStats(topCards),
                HourlyDistribution: s.convertHourlyStats(hourlyDist),
        }

        s.logger.Printf("Successfully generated general statistics")
        return stats, nil</span>
}

// GetDailyStatistics retrieves daily statistics
func (s *StatisticsService) GetDailyStatistics(ctx context.Context, filter *StatisticsFilter) (*DailyStatisticsResponse, error) <span class="cov0" title="0">{
        s.logger.Printf("Generating daily statistics")

        repoFilter := s.toRepoFilter(filter)
        dailyDist, err := s.statsRepo.GetDailyDistribution(ctx, repoFilter)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to get daily distribution: %v", err)
                return nil, fmt.Errorf("failed to get daily distribution: %w", err)
        }</span>

        // Convert to service response type
        <span class="cov0" title="0">var stats []DailyStatistic
        for _, d := range dailyDist </span><span class="cov0" title="0">{
                stats = append(stats, DailyStatistic{
                        Date:        d.Date.Format("2006-01-02"),
                        Count:       d.Count,
                        TotalAmount: d.TotalAmount,
                        AvgAmount:   d.AvgAmount,
                })
        }</span>

        <span class="cov0" title="0">response := &amp;DailyStatisticsResponse{
                DateRange:  s.formatDateRange(filter),
                Statistics: stats,
        }

        s.logger.Printf("Successfully generated daily statistics")
        return response, nil</span>
}

// GetMonthlyStatistics retrieves monthly statistics
func (s *StatisticsService) GetMonthlyStatistics(ctx context.Context, filter *StatisticsFilter) (*MonthlyStatisticsResponse, error) <span class="cov0" title="0">{
        s.logger.Printf("Generating monthly statistics")

        repoFilter := s.toRepoFilter(filter)
        monthlyDist, err := s.statsRepo.GetMonthlyDistribution(ctx, repoFilter)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to get monthly distribution: %v", err)
                return nil, fmt.Errorf("failed to get monthly distribution: %w", err)
        }</span>

        // Convert to service response type
        <span class="cov0" title="0">var stats []MonthlyStatistic
        for _, m := range monthlyDist </span><span class="cov0" title="0">{
                stats = append(stats, MonthlyStatistic{
                        Year:        m.Year,
                        Month:       m.Month,
                        MonthName:   time.Month(m.Month).String(),
                        Count:       m.Count,
                        TotalAmount: m.TotalAmount,
                        AvgAmount:   m.AvgAmount,
                })
        }</span>

        <span class="cov0" title="0">response := &amp;MonthlyStatisticsResponse{
                DateRange:  s.formatDateRange(filter),
                Statistics: stats,
        }

        s.logger.Printf("Successfully generated monthly statistics")
        return response, nil</span>
}

// GetVehicleStatistics retrieves statistics for specific vehicles
func (s *StatisticsService) GetVehicleStatistics(ctx context.Context, carNumbers []string, filter *StatisticsFilter) (*VehicleStatisticsResponse, error) <span class="cov0" title="0">{
        s.logger.Printf("Generating vehicle statistics for %d vehicles", len(carNumbers))

        // Add car numbers to filter
        if filter == nil </span><span class="cov0" title="0">{
                filter = &amp;StatisticsFilter{}
        }</span>
        <span class="cov0" title="0">filter.CarNumbers = carNumbers

        repoFilter := s.toRepoFilter(filter)
        vehicleStats, err := s.statsRepo.GetTopVehicles(ctx, repoFilter, len(carNumbers))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to get vehicle statistics: %v", err)
                return nil, fmt.Errorf("failed to get vehicle statistics: %w", err)
        }</span>

        <span class="cov0" title="0">response := &amp;VehicleStatisticsResponse{
                DateRange: s.formatDateRange(filter),
                Vehicles:  s.convertVehicleStats(vehicleStats),
        }

        s.logger.Printf("Successfully generated vehicle statistics")
        return response, nil</span>
}

// GetMappingStatistics retrieves mapping statistics
func (s *StatisticsService) GetMappingStatistics(ctx context.Context, filter *StatisticsFilter) (*MappingStatisticsResponse, error) <span class="cov0" title="0">{
        s.logger.Printf("Generating mapping statistics")

        repoFilter := s.toRepoFilter(filter)
        mappingStats, err := s.statsRepo.GetMappingStatistics(ctx, repoFilter)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Printf("Failed to get mapping statistics: %v", err)
                return nil, fmt.Errorf("failed to get mapping statistics: %w", err)
        }</span>

        <span class="cov0" title="0">response := &amp;MappingStatisticsResponse{
                DateRange:       s.formatDateRange(filter),
                TotalRecords:    mappingStats.TotalRecords,
                MappedRecords:   mappingStats.MappedRecords,
                UnmappedRecords: mappingStats.UnmappedRecords,
                MappingRate:     mappingStats.MappingRate,
                MappingRatePercentage: fmt.Sprintf("%.2f%%", mappingStats.MappingRate*100),
        }

        s.logger.Printf("Successfully generated mapping statistics")
        return response, nil</span>
}

// HealthCheck performs health check for the service
func (s *StatisticsService) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        if s.statsRepo == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("statistics repository not initialized")
        }</span>

        <span class="cov0" title="0">if err := s.statsRepo.Ping(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("statistics repository ping failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Helper methods

func (s *StatisticsService) toRepoFilter(filter *StatisticsFilter) repositories.StatisticsFilter <span class="cov0" title="0">{
        if filter == nil </span><span class="cov0" title="0">{
                return repositories.StatisticsFilter{}
        }</span>

        <span class="cov0" title="0">return repositories.StatisticsFilter{
                DateFrom:      filter.DateFrom,
                DateTo:        filter.DateTo,
                CarNumbers:    filter.CarNumbers,
                ETCNumbers:    filter.ETCNumbers,
                ETCNums:       filter.ETCNums,
                EntranceICs:   filter.EntranceICs,
                ExitICs:       filter.ExitICs,
                MinTollAmount: filter.MinTollAmount,
                MaxTollAmount: filter.MaxTollAmount,
        }</span>
}

func (s *StatisticsService) formatDateRange(filter *StatisticsFilter) string <span class="cov0" title="0">{
        if filter == nil || (filter.DateFrom == nil &amp;&amp; filter.DateTo == nil) </span><span class="cov0" title="0">{
                return "All Time"
        }</span>

        <span class="cov0" title="0">var from, to string
        if filter.DateFrom != nil </span><span class="cov0" title="0">{
                from = filter.DateFrom.Format("2006-01-02")
        }</span> else<span class="cov0" title="0"> {
                from = "Beginning"
        }</span>

        <span class="cov0" title="0">if filter.DateTo != nil </span><span class="cov0" title="0">{
                to = filter.DateTo.Format("2006-01-02")
        }</span> else<span class="cov0" title="0"> {
                to = "Present"
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%s to %s", from, to)</span>
}

func (s *StatisticsService) convertRouteStats(routes []repositories.RouteStatistic) []RouteStatistic <span class="cov0" title="0">{
        var result []RouteStatistic
        for _, r := range routes </span><span class="cov0" title="0">{
                result = append(result, RouteStatistic{
                        EntranceIC:  r.EntranceIC,
                        ExitIC:      r.ExitIC,
                        Count:       r.Count,
                        TotalAmount: r.TotalAmount,
                        AvgAmount:   r.AvgAmount,
                })
        }</span>
        <span class="cov0" title="0">return result</span>
}

func (s *StatisticsService) convertVehicleStats(vehicles []repositories.VehicleStatistic) []VehicleStatistic <span class="cov0" title="0">{
        var result []VehicleStatistic
        for _, v := range vehicles </span><span class="cov0" title="0">{
                result = append(result, VehicleStatistic{
                        CarNumber:   v.CarNumber,
                        Count:       v.Count,
                        TotalAmount: v.TotalAmount,
                        AvgAmount:   v.AvgAmount,
                })
        }</span>
        <span class="cov0" title="0">return result</span>
}

func (s *StatisticsService) convertCardStats(cards []repositories.CardStatistic) []CardStatistic <span class="cov0" title="0">{
        var result []CardStatistic
        for _, c := range cards </span><span class="cov0" title="0">{
                result = append(result, CardStatistic{
                        ETCCardNumber: c.ETCCardNumber,
                        Count:         c.Count,
                        TotalAmount:   c.TotalAmount,
                        AvgAmount:     c.AvgAmount,
                })
        }</span>
        <span class="cov0" title="0">return result</span>
}

func (s *StatisticsService) convertHourlyStats(hourly []repositories.HourlyStatistic) []HourlyStatistic <span class="cov0" title="0">{
        var result []HourlyStatistic
        for _, h := range hourly </span><span class="cov0" title="0">{
                result = append(result, HourlyStatistic{
                        Hour:        h.Hour,
                        HourLabel:   fmt.Sprintf("%02d:00", h.Hour),
                        Count:       h.Count,
                        TotalAmount: h.TotalAmount,
                        AvgAmount:   h.AvgAmount,
                })
        }</span>
        <span class="cov0" title="0">return result</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
