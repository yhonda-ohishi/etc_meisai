
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/yhonda-ohishi/etc_meisai/src/config/accounts.go (90.8%)</option>
				
				<option value="file1">github.com/yhonda-ohishi/etc_meisai/src/config/accounts_array.go (26.8%)</option>
				
				<option value="file2">github.com/yhonda-ohishi/etc_meisai/src/config/settings.go (100.0%)</option>
				
				<option value="file3">github.com/yhonda-ohishi/etc_meisai/src/config/simple_accounts.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "os"
        "strings"
)

// AccountType represents the type of ETC account
type AccountType string

const (
        AccountTypeCorporate AccountType = "corporate"
        AccountTypePersonal  AccountType = "personal"
)

// ETCAccount represents a single ETC account
type ETCAccount struct {
        Name         string      `json:"name"`          // Account name for identification
        UserID       string      `json:"user_id"`       // Login user ID
        Password     string      `json:"password"`      // Login password
        PasswordCorp string      `json:"password_corp"` // Corporate password (if applicable)
        Type         AccountType `json:"type"`          // Account type (corporate/personal)
        CardNumbers  []string    `json:"card_numbers"`  // Associated card numbers
        Active       bool        `json:"active"`        // Whether this account is active
}

// AccountsConfig holds all ETC accounts configuration
type AccountsConfig struct {
        Accounts []ETCAccount `json:"accounts"`
}

// LoadAccountsFromEnv loads accounts from environment variables
func LoadAccountsFromEnv() (*AccountsConfig, error) <span class="cov8" title="1">{
        config := &amp;AccountsConfig{
                Accounts: []ETCAccount{},
        }

        // Load corporate accounts (ETC_CORP_USER_1, ETC_CORP_PASS_1, ETC_CORP_PASS2_1, etc.)
        for i := 1; i &lt;= 10; i++ </span><span class="cov8" title="1">{
                userKey := fmt.Sprintf("ETC_CORP_USER_%d", i)
                passKey := fmt.Sprintf("ETC_CORP_PASS_%d", i)
                pass2Key := fmt.Sprintf("ETC_CORP_PASS2_%d", i)
                nameKey := fmt.Sprintf("ETC_CORP_NAME_%d", i)
                cardsKey := fmt.Sprintf("ETC_CORP_CARDS_%d", i)

                userID := os.Getenv(userKey)
                if userID == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">account := ETCAccount{
                        Name:         os.Getenv(nameKey),
                        UserID:       userID,
                        Password:     os.Getenv(passKey),
                        PasswordCorp: os.Getenv(pass2Key),
                        Type:         AccountTypeCorporate,
                        Active:       true,
                }

                if account.Name == "" </span><span class="cov8" title="1">{
                        account.Name = fmt.Sprintf("Corporate Account %d", i)
                }</span>

                // Parse card numbers
                <span class="cov8" title="1">cards := os.Getenv(cardsKey)
                if cards != "" </span><span class="cov8" title="1">{
                        account.CardNumbers = strings.Split(cards, ",")
                        for j := range account.CardNumbers </span><span class="cov8" title="1">{
                                account.CardNumbers[j] = strings.TrimSpace(account.CardNumbers[j])
                        }</span>
                }

                <span class="cov8" title="1">config.Accounts = append(config.Accounts, account)</span>
        }

        // Load personal accounts (ETC_PERSONAL_USER_1, ETC_PERSONAL_PASS_1, etc.)
        <span class="cov8" title="1">for i := 1; i &lt;= 10; i++ </span><span class="cov8" title="1">{
                userKey := fmt.Sprintf("ETC_PERSONAL_USER_%d", i)
                passKey := fmt.Sprintf("ETC_PERSONAL_PASS_%d", i)
                nameKey := fmt.Sprintf("ETC_PERSONAL_NAME_%d", i)
                cardsKey := fmt.Sprintf("ETC_PERSONAL_CARDS_%d", i)

                userID := os.Getenv(userKey)
                if userID == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">account := ETCAccount{
                        Name:     os.Getenv(nameKey),
                        UserID:   userID,
                        Password: os.Getenv(passKey),
                        Type:     AccountTypePersonal,
                        Active:   true,
                }

                if account.Name == "" </span><span class="cov8" title="1">{
                        account.Name = fmt.Sprintf("Personal Account %d", i)
                }</span>

                // Parse card numbers
                <span class="cov8" title="1">cards := os.Getenv(cardsKey)
                if cards != "" </span><span class="cov8" title="1">{
                        account.CardNumbers = strings.Split(cards, ",")
                        for j := range account.CardNumbers </span><span class="cov8" title="1">{
                                account.CardNumbers[j] = strings.TrimSpace(account.CardNumbers[j])
                        }</span>
                }

                <span class="cov8" title="1">config.Accounts = append(config.Accounts, account)</span>
        }

        // Also check for simple single account (backward compatibility)
        <span class="cov8" title="1">if len(config.Accounts) == 0 </span><span class="cov8" title="1">{
                if userID := os.Getenv("ETC_USER_ID"); userID != "" </span><span class="cov8" title="1">{
                        account := ETCAccount{
                                Name:     "Default Account",
                                UserID:   userID,
                                Password: os.Getenv("ETC_PASSWORD"),
                                Type:     AccountTypePersonal,
                                Active:   true,
                        }
                        config.Accounts = append(config.Accounts, account)
                }</span>
        }

        <span class="cov8" title="1">return config, nil</span>
}

// LoadAccountsFromFile loads accounts from a JSON file
func LoadAccountsFromFile(filepath string) (*AccountsConfig, error) <span class="cov8" title="1">{
        file, err := os.Open(filepath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to open accounts file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        var config AccountsConfig
        decoder := json.NewDecoder(file)
        if err := decoder.Decode(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode accounts file: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

// GetActiveAccounts returns only active accounts
func (c *AccountsConfig) GetActiveAccounts() []ETCAccount <span class="cov8" title="1">{
        active := []ETCAccount{}
        for _, account := range c.Accounts </span><span class="cov8" title="1">{
                if account.Active </span><span class="cov8" title="1">{
                        active = append(active, account)
                }</span>
        }
        <span class="cov8" title="1">return active</span>
}

// GetCorporateAccounts returns only corporate accounts
func (c *AccountsConfig) GetCorporateAccounts() []ETCAccount <span class="cov8" title="1">{
        corp := []ETCAccount{}
        for _, account := range c.Accounts </span><span class="cov8" title="1">{
                if account.Type == AccountTypeCorporate &amp;&amp; account.Active </span><span class="cov8" title="1">{
                        corp = append(corp, account)
                }</span>
        }
        <span class="cov8" title="1">return corp</span>
}

// GetPersonalAccounts returns only personal accounts
func (c *AccountsConfig) GetPersonalAccounts() []ETCAccount <span class="cov8" title="1">{
        personal := []ETCAccount{}
        for _, account := range c.Accounts </span><span class="cov8" title="1">{
                if account.Type == AccountTypePersonal &amp;&amp; account.Active </span><span class="cov8" title="1">{
                        personal = append(personal, account)
                }</span>
        }
        <span class="cov8" title="1">return personal</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "os"
        "strings"
)

// LoadAccountsFromArrayEnv loads accounts from array-style environment variables
func LoadAccountsFromArrayEnv() (*AccountsConfig, error) <span class="cov8" title="1">{
        config := &amp;AccountsConfig{
                Accounts: []ETCAccount{},
        }

        // Load corporate accounts from JSON array
        // ETC_CORP_ACCOUNTS='[{"name":"Company A","user_id":"user1","password":"pass1","password_corp":"corp1","cards":["1234","5678"]}]'
        if corpJSON := os.Getenv("ETC_CORP_ACCOUNTS"); corpJSON != "" </span><span class="cov8" title="1">{
                var corpAccounts []ETCAccount
                if err := json.Unmarshal([]byte(corpJSON), &amp;corpAccounts); err != nil </span><span class="cov8" title="1">{
                        // Try parsing as comma-separated format for simpler input
                        corpAccounts = parseSimpleFormat(corpJSON, AccountTypeCorporate)
                }</span>

                // Set type for all corporate accounts
                <span class="cov8" title="1">for i := range corpAccounts </span><span class="cov8" title="1">{
                        corpAccounts[i].Type = AccountTypeCorporate
                        corpAccounts[i].Active = true
                }</span>
                <span class="cov8" title="1">config.Accounts = append(config.Accounts, corpAccounts...)</span>
        }

        // Load personal accounts from JSON array
        // ETC_PERSONAL_ACCOUNTS='[{"name":"Personal 1","user_id":"user1","password":"pass1","cards":["1234"]}]'
        <span class="cov8" title="1">if personalJSON := os.Getenv("ETC_PERSONAL_ACCOUNTS"); personalJSON != "" </span><span class="cov8" title="1">{
                var personalAccounts []ETCAccount
                if err := json.Unmarshal([]byte(personalJSON), &amp;personalAccounts); err != nil </span><span class="cov8" title="1">{
                        // Try parsing as comma-separated format
                        personalAccounts = parseSimpleFormat(personalJSON, AccountTypePersonal)
                }</span>

                // Set type for all personal accounts
                <span class="cov8" title="1">for i := range personalAccounts </span><span class="cov8" title="1">{
                        personalAccounts[i].Type = AccountTypePersonal
                        personalAccounts[i].Active = true
                }</span>
                <span class="cov8" title="1">config.Accounts = append(config.Accounts, personalAccounts...)</span>
        }

        // Alternative: Load from simple delimited format
        // ETC_ACCOUNTS="corp,Company A,user1,pass1,corp1,1234-5678|personal,Personal 1,user2,pass2,,9876-5432"
        <span class="cov8" title="1">if simpleAccounts := os.Getenv("ETC_ACCOUNTS"); simpleAccounts != "" </span><span class="cov0" title="0">{
                accounts := parseDelimitedAccounts(simpleAccounts)
                config.Accounts = append(config.Accounts, accounts...)
        }</span>

        // Alternative: Load from separate arrays
        // ETC_ACCOUNT_TYPES="corporate,personal,corporate"
        // ETC_ACCOUNT_NAMES="Company A,Personal 1,Company B"
        // ETC_ACCOUNT_USERS="user1,user2,user3"
        // ETC_ACCOUNT_PASSWORDS="pass1,pass2,pass3"
        // ETC_ACCOUNT_CORP_PASSWORDS="corp1,,corp3"
        // ETC_ACCOUNT_CARDS="1234-5678;2345-6789,9876-5432,3456-7890"
        <span class="cov8" title="1">if types := os.Getenv("ETC_ACCOUNT_TYPES"); types != "" </span><span class="cov0" title="0">{
                accounts := parseArrayEnvVars()
                config.Accounts = append(config.Accounts, accounts...)
        }</span>

        // Fallback to numbered env vars if no array format found
        <span class="cov8" title="1">if len(config.Accounts) == 0 </span><span class="cov8" title="1">{
                return LoadAccountsFromEnv()
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}

// parseSimpleFormat parses a simple comma-separated format
// Format: "name:user:pass[:corp_pass]:card1,card2;name2:user2:pass2..."
func parseSimpleFormat(input string, accountType AccountType) []ETCAccount <span class="cov8" title="1">{
        var accounts []ETCAccount

        // Split by semicolon for multiple accounts
        accountStrings := strings.Split(input, ";")

        for _, accStr := range accountStrings </span><span class="cov8" title="1">{
                parts := strings.Split(accStr, ":")
                if len(parts) &lt; 3 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">account := ETCAccount{
                        Name:     strings.TrimSpace(parts[0]),
                        UserID:   strings.TrimSpace(parts[1]),
                        Password: strings.TrimSpace(parts[2]),
                        Type:     accountType,
                        Active:   true,
                }

                // Corporate password (optional)
                if len(parts) &gt; 3 &amp;&amp; accountType == AccountTypeCorporate </span><span class="cov8" title="1">{
                        account.PasswordCorp = strings.TrimSpace(parts[3])
                }</span>

                // Cards (optional)
                <span class="cov8" title="1">startIdx := 3
                if accountType == AccountTypeCorporate </span><span class="cov8" title="1">{
                        startIdx = 4
                }</span>

                <span class="cov8" title="1">if len(parts) &gt; startIdx </span><span class="cov0" title="0">{
                        cards := strings.Split(parts[startIdx], ",")
                        for _, card := range cards </span><span class="cov0" title="0">{
                                card = strings.TrimSpace(card)
                                if card != "" </span><span class="cov0" title="0">{
                                        account.CardNumbers = append(account.CardNumbers, card)
                                }</span>
                        }
                }

                <span class="cov8" title="1">accounts = append(accounts, account)</span>
        }

        <span class="cov8" title="1">return accounts</span>
}

// parseDelimitedAccounts parses pipe-delimited account format
// Format: "type,name,user,pass,corp_pass,cards|type,name,user,pass,corp_pass,cards"
func parseDelimitedAccounts(input string) []ETCAccount <span class="cov0" title="0">{
        var accounts []ETCAccount

        // Split by pipe for multiple accounts
        accountStrings := strings.Split(input, "|")

        for _, accStr := range accountStrings </span><span class="cov0" title="0">{
                parts := strings.Split(accStr, ",")
                if len(parts) &lt; 4 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">accountType := AccountTypePersonal
                if strings.ToLower(strings.TrimSpace(parts[0])) == "corporate" ||
                   strings.ToLower(strings.TrimSpace(parts[0])) == "corp" </span><span class="cov0" title="0">{
                        accountType = AccountTypeCorporate
                }</span>

                <span class="cov0" title="0">account := ETCAccount{
                        Name:     strings.TrimSpace(parts[1]),
                        UserID:   strings.TrimSpace(parts[2]),
                        Password: strings.TrimSpace(parts[3]),
                        Type:     accountType,
                        Active:   true,
                }

                // Corporate password
                if len(parts) &gt; 4 &amp;&amp; parts[4] != "" </span><span class="cov0" title="0">{
                        account.PasswordCorp = strings.TrimSpace(parts[4])
                }</span>

                // Cards (semicolon separated)
                <span class="cov0" title="0">if len(parts) &gt; 5 &amp;&amp; parts[5] != "" </span><span class="cov0" title="0">{
                        cards := strings.Split(parts[5], ";")
                        for _, card := range cards </span><span class="cov0" title="0">{
                                card = strings.TrimSpace(card)
                                if card != "" </span><span class="cov0" title="0">{
                                        account.CardNumbers = append(account.CardNumbers, card)
                                }</span>
                        }
                }

                <span class="cov0" title="0">accounts = append(accounts, account)</span>
        }

        <span class="cov0" title="0">return accounts</span>
}

// parseArrayEnvVars parses parallel array environment variables
func parseArrayEnvVars() []ETCAccount <span class="cov0" title="0">{
        var accounts []ETCAccount

        types := strings.Split(os.Getenv("ETC_ACCOUNT_TYPES"), ",")
        names := strings.Split(os.Getenv("ETC_ACCOUNT_NAMES"), ",")
        users := strings.Split(os.Getenv("ETC_ACCOUNT_USERS"), ",")
        passwords := strings.Split(os.Getenv("ETC_ACCOUNT_PASSWORDS"), ",")
        corpPasswords := strings.Split(os.Getenv("ETC_ACCOUNT_CORP_PASSWORDS"), ",")
        cardsArray := strings.Split(os.Getenv("ETC_ACCOUNT_CARDS"), ",")

        // Find the maximum length
        maxLen := len(types)
        if len(users) &gt; maxLen </span><span class="cov0" title="0">{
                maxLen = len(users)
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; maxLen; i++ </span><span class="cov0" title="0">{
                account := ETCAccount{
                        Active: true,
                }

                // Type
                if i &lt; len(types) </span><span class="cov0" title="0">{
                        typeStr := strings.ToLower(strings.TrimSpace(types[i]))
                        if typeStr == "corporate" || typeStr == "corp" </span><span class="cov0" title="0">{
                                account.Type = AccountTypeCorporate
                        }</span> else<span class="cov0" title="0"> {
                                account.Type = AccountTypePersonal
                        }</span>
                }

                // Name
                <span class="cov0" title="0">if i &lt; len(names) </span><span class="cov0" title="0">{
                        account.Name = strings.TrimSpace(names[i])
                }</span> else<span class="cov0" title="0"> {
                        account.Name = fmt.Sprintf("Account %d", i+1)
                }</span>

                // User ID
                <span class="cov0" title="0">if i &lt; len(users) </span><span class="cov0" title="0">{
                        account.UserID = strings.TrimSpace(users[i])
                }</span> else<span class="cov0" title="0"> {
                        continue</span> // Skip if no user ID
                }

                // Password
                <span class="cov0" title="0">if i &lt; len(passwords) </span><span class="cov0" title="0">{
                        account.Password = strings.TrimSpace(passwords[i])
                }</span>

                // Corporate password
                <span class="cov0" title="0">if i &lt; len(corpPasswords) &amp;&amp; corpPasswords[i] != "" </span><span class="cov0" title="0">{
                        account.PasswordCorp = strings.TrimSpace(corpPasswords[i])
                }</span>

                // Cards (semicolon separated within each account)
                <span class="cov0" title="0">if i &lt; len(cardsArray) &amp;&amp; cardsArray[i] != "" </span><span class="cov0" title="0">{
                        cards := strings.Split(cardsArray[i], ";")
                        for _, card := range cards </span><span class="cov0" title="0">{
                                card = strings.TrimSpace(card)
                                if card != "" </span><span class="cov0" title="0">{
                                        account.CardNumbers = append(account.CardNumbers, card)
                                }</span>
                        }
                }

                <span class="cov0" title="0">accounts = append(accounts, account)</span>
        }

        <span class="cov0" title="0">return accounts</span>
}

// SaveAccountsToJSON saves accounts configuration to a JSON file
func SaveAccountsToJSON(accounts []ETCAccount, filepath string) error <span class="cov0" title="0">{
        data, err := json.MarshalIndent(accounts, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal accounts: %w", err)
        }</span>

        <span class="cov0" title="0">return os.WriteFile(filepath, data, 0644)</span>
}

// GenerateEnvExample generates example environment variable settings
func GenerateEnvExample() string <span class="cov0" title="0">{
        var sb strings.Builder

        sb.WriteString("# ===== Multiple Account Configuration =====\n\n")

        sb.WriteString("# Option 1: JSON Array Format\n")
        sb.WriteString(`ETC_CORP_ACCOUNTS='[{"name":"Company A","user_id":"corp1","password":"pass1","password_corp":"corp_pass1","cards":["1234-5678","2345-6789"]},{"name":"Company B","user_id":"corp2","password":"pass2","password_corp":"corp_pass2","cards":["3456-7890"]}]'`)
        sb.WriteString("\n")
        sb.WriteString(`ETC_PERSONAL_ACCOUNTS='[{"name":"Personal 1","user_id":"user1","password":"pass1","cards":["9876-5432"]},{"name":"Personal 2","user_id":"user2","password":"pass2"}]'`)
        sb.WriteString("\n\n")

        sb.WriteString("# Option 2: Simple Delimited Format\n")
        sb.WriteString(`# Format: type,name,user,pass,corp_pass,cards|type,name,user,pass,corp_pass,cards`)
        sb.WriteString("\n")
        sb.WriteString(`ETC_ACCOUNTS="corp,Company A,corp1,pass1,corp_pass1,1234-5678;2345-6789|personal,Personal 1,user1,pass1,,9876-5432|corp,Company B,corp2,pass2,corp_pass2,3456-7890"`)
        sb.WriteString("\n\n")

        sb.WriteString("# Option 3: Parallel Arrays Format\n")
        sb.WriteString(`ETC_ACCOUNT_TYPES="corporate,personal,corporate"`)
        sb.WriteString("\n")
        sb.WriteString(`ETC_ACCOUNT_NAMES="Company A,Personal 1,Company B"`)
        sb.WriteString("\n")
        sb.WriteString(`ETC_ACCOUNT_USERS="corp1,user1,corp2"`)
        sb.WriteString("\n")
        sb.WriteString(`ETC_ACCOUNT_PASSWORDS="pass1,pass1,pass2"`)
        sb.WriteString("\n")
        sb.WriteString(`ETC_ACCOUNT_CORP_PASSWORDS="corp_pass1,,corp_pass2"`)
        sb.WriteString("\n")
        sb.WriteString(`ETC_ACCOUNT_CARDS="1234-5678;2345-6789,9876-5432,3456-7890"`)
        sb.WriteString("\n\n")

        sb.WriteString("# Option 4: Simple Colon Format (for single type)\n")
        sb.WriteString(`# Format: name:user:pass[:corp_pass]:card1,card2;name2:user2:pass2...`)
        sb.WriteString("\n")
        sb.WriteString(`ETC_CORP_ACCOUNTS="Company A:corp1:pass1:corp_pass1:1234-5678,2345-6789;Company B:corp2:pass2:corp_pass2:3456-7890"`)
        sb.WriteString("\n")
        sb.WriteString(`ETC_PERSONAL_ACCOUNTS="Personal 1:user1:pass1:9876-5432;Personal 2:user2:pass2"`)
        sb.WriteString("\n")

        return sb.String()
}</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"
)

// Settings holds all application configuration
type Settings struct {
        Database DatabaseSettings `json:"database"`
        Server   ServerSettings   `json:"server"`
        GRPC     GRPCSettings     `json:"grpc"`
        Scraping ScrapingSettings `json:"scraping"`
        Import   ImportSettings   `json:"import"`
        Logging  LoggingSettings  `json:"logging"`
}

// DatabaseSettings holds database configuration
type DatabaseSettings struct {
        Driver      string `json:"driver"`
        Host        string `json:"host"`
        Port        int    `json:"port"`
        Database    string `json:"database"`
        Username    string `json:"username"`
        Password    string `json:"password"`
        MaxConn     int    `json:"max_connections"`
        MaxIdleConn int    `json:"max_idle_connections"`
        ConnTimeout int    `json:"connection_timeout"`
        Path        string `json:"path"` // For SQLite databases
}

// GRPCSettings holds gRPC client configuration
type GRPCSettings struct {
        DBServiceAddress string        `json:"db_service_address"`
        Timeout          time.Duration `json:"timeout"`
        MaxRetries       int           `json:"max_retries"`
        RetryDelay       time.Duration `json:"retry_delay"`
        EnableTLS        bool          `json:"enable_tls"`
        CertFile         string        `json:"cert_file"`
        KeyFile          string        `json:"key_file"`
        CAFile           string        `json:"ca_file"`
}

// ServerSettings holds server configuration
type ServerSettings struct {
        Host         string `json:"host"`
        Port         int    `json:"port"`
        ReadTimeout  int    `json:"read_timeout"`
        WriteTimeout int    `json:"write_timeout"`
        MaxBodySize  int64  `json:"max_body_size"`
}

// ScrapingSettings holds scraping configuration
type ScrapingSettings struct {
        MaxWorkers      int           `json:"max_workers"`
        RetryCount      int           `json:"retry_count"`
        RetryDelay      time.Duration `json:"retry_delay"`
        RequestTimeout  time.Duration `json:"request_timeout"`
        HeadlessBrowser bool          `json:"headless_browser"`
}

// ImportSettings holds import configuration
type ImportSettings struct {
        BatchSize        int    `json:"batch_size"`
        MaxFileSize      int64  `json:"max_file_size"`
        TempDir          string `json:"temp_directory"`
        AllowedFormats   []string `json:"allowed_formats"`
        DuplicateCheck   bool   `json:"duplicate_check"`
}

// LoggingSettings holds logging configuration
type LoggingSettings struct {
        Level          string `json:"level"`
        OutputPath     string `json:"output_path"`
        MaxSize        int    `json:"max_size_mb"`
        MaxBackups     int    `json:"max_backups"`
        MaxAge         int    `json:"max_age_days"`
        EnableConsole  bool   `json:"enable_console"`
        EnableJSON     bool   `json:"enable_json"`
}

// NewSettings creates settings with defaults
func NewSettings() *Settings <span class="cov8" title="1">{
        return &amp;Settings{
                Database: DatabaseSettings{
                        Driver:      "gorm",
                        Host:        "localhost",
                        Port:        3306,
                        MaxConn:     25,
                        MaxIdleConn: 5,
                        ConnTimeout: 30,
                        Path:        "./data/etc_meisai.db", // Default SQLite path
                },
                Server: ServerSettings{
                        Host:         "0.0.0.0",
                        Port:         8080,
                        ReadTimeout:  30,
                        WriteTimeout: 30,
                        MaxBodySize:  32 &lt;&lt; 20, // 32MB
                },
                GRPC: GRPCSettings{
                        DBServiceAddress: "localhost:50051",
                        Timeout:          30 * time.Second,
                        MaxRetries:       3,
                        RetryDelay:       1 * time.Second,
                        EnableTLS:        false,
                },
                Scraping: ScrapingSettings{
                        MaxWorkers:      5,
                        RetryCount:      3,
                        RetryDelay:      5 * time.Second,
                        RequestTimeout:  30 * time.Second,
                        HeadlessBrowser: true,
                },
                Import: ImportSettings{
                        BatchSize:      1000,
                        MaxFileSize:    100 &lt;&lt; 20, // 100MB
                        TempDir:        "./temp",
                        AllowedFormats: []string{".csv", ".xlsx"},
                        DuplicateCheck: true,
                },
                Logging: LoggingSettings{
                        Level:         "info",
                        OutputPath:    "./logs",
                        MaxSize:       100,
                        MaxBackups:    7,
                        MaxAge:        30,
                        EnableConsole: true,
                        EnableJSON:    true,
                },
        }
}</span>

// LoadFromEnv loads settings from environment variables
func LoadFromEnv() *Settings <span class="cov8" title="1">{
        settings := NewSettings()

        // Database settings
        if v := os.Getenv("DB_DRIVER"); v != "" </span><span class="cov8" title="1">{
                settings.Database.Driver = v
        }</span>
        <span class="cov8" title="1">if v := os.Getenv("DB_HOST"); v != "" </span><span class="cov8" title="1">{
                settings.Database.Host = v
        }</span>
        <span class="cov8" title="1">if v := os.Getenv("DB_PORT"); v != "" </span><span class="cov8" title="1">{
                if port, err := strconv.Atoi(v); err == nil </span><span class="cov8" title="1">{
                        settings.Database.Port = port
                }</span>
        }
        <span class="cov8" title="1">if v := os.Getenv("DB_NAME"); v != "" </span><span class="cov8" title="1">{
                settings.Database.Database = v
        }</span>
        <span class="cov8" title="1">if v := os.Getenv("DB_USER"); v != "" </span><span class="cov8" title="1">{
                settings.Database.Username = v
        }</span>
        <span class="cov8" title="1">if v := os.Getenv("DB_PASSWORD"); v != "" </span><span class="cov8" title="1">{
                settings.Database.Password = v
        }</span>
        <span class="cov8" title="1">if v := os.Getenv("DB_PATH"); v != "" </span><span class="cov8" title="1">{
                settings.Database.Path = v
        }</span>

        // gRPC settings
        <span class="cov8" title="1">if v := os.Getenv("GRPC_DB_SERVICE_ADDRESS"); v != "" </span><span class="cov8" title="1">{
                settings.GRPC.DBServiceAddress = v
        }</span>
        <span class="cov8" title="1">if v := os.Getenv("GRPC_TIMEOUT"); v != "" </span><span class="cov8" title="1">{
                if timeout, err := time.ParseDuration(v); err == nil </span><span class="cov8" title="1">{
                        settings.GRPC.Timeout = timeout
                }</span>
        }
        <span class="cov8" title="1">if v := os.Getenv("GRPC_MAX_RETRIES"); v != "" </span><span class="cov8" title="1">{
                if retries, err := strconv.Atoi(v); err == nil </span><span class="cov8" title="1">{
                        settings.GRPC.MaxRetries = retries
                }</span>
        }
        <span class="cov8" title="1">if v := os.Getenv("GRPC_ENABLE_TLS"); v != "" </span><span class="cov8" title="1">{
                settings.GRPC.EnableTLS = strings.ToLower(v) == "true"
        }</span>
        <span class="cov8" title="1">if v := os.Getenv("GRPC_CERT_FILE"); v != "" </span><span class="cov8" title="1">{
                settings.GRPC.CertFile = v
        }</span>
        <span class="cov8" title="1">if v := os.Getenv("GRPC_KEY_FILE"); v != "" </span><span class="cov8" title="1">{
                settings.GRPC.KeyFile = v
        }</span>
        <span class="cov8" title="1">if v := os.Getenv("GRPC_CA_FILE"); v != "" </span><span class="cov8" title="1">{
                settings.GRPC.CAFile = v
        }</span>

        // Server settings
        <span class="cov8" title="1">if v := os.Getenv("SERVER_HOST"); v != "" </span><span class="cov8" title="1">{
                settings.Server.Host = v
        }</span>
        <span class="cov8" title="1">if v := os.Getenv("SERVER_PORT"); v != "" </span><span class="cov8" title="1">{
                if port, err := strconv.Atoi(v); err == nil </span><span class="cov8" title="1">{
                        settings.Server.Port = port
                }</span>
        }

        // Scraping settings
        <span class="cov8" title="1">if v := os.Getenv("SCRAPING_MAX_WORKERS"); v != "" </span><span class="cov8" title="1">{
                if workers, err := strconv.Atoi(v); err == nil </span><span class="cov8" title="1">{
                        settings.Scraping.MaxWorkers = workers
                }</span>
        }
        <span class="cov8" title="1">if v := os.Getenv("SCRAPING_HEADLESS"); v != "" </span><span class="cov8" title="1">{
                settings.Scraping.HeadlessBrowser = strings.ToLower(v) == "true"
        }</span>

        // Import settings
        <span class="cov8" title="1">if v := os.Getenv("IMPORT_BATCH_SIZE"); v != "" </span><span class="cov8" title="1">{
                if size, err := strconv.Atoi(v); err == nil </span><span class="cov8" title="1">{
                        settings.Import.BatchSize = size
                }</span>
        }
        <span class="cov8" title="1">if v := os.Getenv("IMPORT_TEMP_DIR"); v != "" </span><span class="cov8" title="1">{
                settings.Import.TempDir = v
        }</span>

        // Logging settings
        <span class="cov8" title="1">if v := os.Getenv("LOG_LEVEL"); v != "" </span><span class="cov8" title="1">{
                settings.Logging.Level = v
        }</span>
        <span class="cov8" title="1">if v := os.Getenv("LOG_PATH"); v != "" </span><span class="cov8" title="1">{
                settings.Logging.OutputPath = v
        }</span>
        <span class="cov8" title="1">if v := os.Getenv("LOG_JSON"); v != "" </span><span class="cov8" title="1">{
                settings.Logging.EnableJSON = strings.ToLower(v) == "true"
        }</span>

        <span class="cov8" title="1">return settings</span>
}

// LoadFromFile loads settings from a JSON file
func LoadFromFile(path string) (*Settings, error) <span class="cov8" title="1">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to open config file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        settings := NewSettings()
        decoder := json.NewDecoder(file)
        if err := decoder.Decode(settings); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to decode config file: %w", err)
        }</span>

        <span class="cov8" title="1">return settings, nil</span>
}

// Validate validates all settings
func (s *Settings) Validate() error <span class="cov8" title="1">{
        // Database validation
        if s.Database.Driver == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("database driver is required")
        }</span>
        <span class="cov8" title="1">if s.Database.Host == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("database host is required")
        }</span>
        <span class="cov8" title="1">if s.Database.Port &lt;= 0 || s.Database.Port &gt; 65535 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid database port: %d", s.Database.Port)
        }</span>

        // Server validation
        <span class="cov8" title="1">if s.Server.Port &lt;= 0 || s.Server.Port &gt; 65535 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid server port: %d", s.Server.Port)
        }</span>
        <span class="cov8" title="1">if s.Server.ReadTimeout &lt;= 0 </span><span class="cov8" title="1">{
                s.Server.ReadTimeout = 30
        }</span>
        <span class="cov8" title="1">if s.Server.WriteTimeout &lt;= 0 </span><span class="cov8" title="1">{
                s.Server.WriteTimeout = 30
        }</span>

        // gRPC validation
        <span class="cov8" title="1">if s.GRPC.DBServiceAddress == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("gRPC db_service address is required")
        }</span>
        <span class="cov8" title="1">if s.GRPC.Timeout &lt;= 0 </span><span class="cov8" title="1">{
                s.GRPC.Timeout = 30 * time.Second
        }</span>
        <span class="cov8" title="1">if s.GRPC.MaxRetries &lt; 0 </span><span class="cov8" title="1">{
                s.GRPC.MaxRetries = 0
        }</span>
        <span class="cov8" title="1">if s.GRPC.RetryDelay &lt;= 0 </span><span class="cov8" title="1">{
                s.GRPC.RetryDelay = 1 * time.Second
        }</span>

        // TLS validation
        <span class="cov8" title="1">if s.GRPC.EnableTLS </span><span class="cov8" title="1">{
                if s.GRPC.CertFile == "" || s.GRPC.KeyFile == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("TLS cert_file and key_file are required when TLS is enabled")
                }</span>
        }

        // Scraping validation
        <span class="cov8" title="1">if s.Scraping.MaxWorkers &lt;= 0 </span><span class="cov8" title="1">{
                s.Scraping.MaxWorkers = 1
        }</span>
        <span class="cov8" title="1">if s.Scraping.RetryCount &lt; 0 </span><span class="cov8" title="1">{
                s.Scraping.RetryCount = 0
        }</span>

        // Import validation
        <span class="cov8" title="1">if s.Import.BatchSize &lt;= 0 </span><span class="cov8" title="1">{
                s.Import.BatchSize = 100
        }</span>
        <span class="cov8" title="1">if s.Import.MaxFileSize &lt;= 0 </span><span class="cov8" title="1">{
                s.Import.MaxFileSize = 10 &lt;&lt; 20 // 10MB default
        }</span>
        <span class="cov8" title="1">if s.Import.TempDir == "" </span><span class="cov8" title="1">{
                s.Import.TempDir = "./temp"
        }</span>

        // Logging validation
        <span class="cov8" title="1">validLevels := []string{"debug", "info", "warn", "error", "fatal"}
        levelValid := false
        for _, level := range validLevels </span><span class="cov8" title="1">{
                if strings.ToLower(s.Logging.Level) == level </span><span class="cov8" title="1">{
                        levelValid = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !levelValid </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid log level: %s", s.Logging.Level)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetDSN returns database connection string
func (s *DatabaseSettings) GetDSN() string <span class="cov8" title="1">{
        switch s.Driver </span>{
        case "mysql":<span class="cov8" title="1">
                return fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&amp;parseTime=true&amp;loc=Local",
                        s.Username, s.Password, s.Host, s.Port, s.Database)</span>
        case "postgres":<span class="cov8" title="1">
                return fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
                        s.Host, s.Port, s.Username, s.Password, s.Database)</span>
        default:<span class="cov8" title="1">
                return ""</span>
        }
}

// GetServerAddress returns the server address
func (s *ServerSettings) GetServerAddress() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%d", s.Host, s.Port)
}</span>

// GetDBServiceAddress returns the gRPC db_service address
func (g *GRPCSettings) GetDBServiceAddress() string <span class="cov8" title="1">{
        return g.DBServiceAddress
}</span>

// IsSecure returns true if TLS is enabled
func (g *GRPCSettings) IsSecure() bool <span class="cov8" title="1">{
        return g.EnableTLS
}</span>

// GetConnectionTimeout returns the connection timeout
func (g *GRPCSettings) GetConnectionTimeout() time.Duration <span class="cov8" title="1">{
        return g.Timeout
}</span>

// GlobalSettings holds the global application settings
var GlobalSettings *Settings

// InitSettings initializes global settings
func InitSettings() error <span class="cov8" title="1">{
        // Try to load from file first
        if _, err := os.Stat("config.json"); err == nil </span><span class="cov8" title="1">{
                settings, err := LoadFromFile("config.json")
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to load config file: %w", err)
                }</span>
                <span class="cov8" title="1">GlobalSettings = settings</span>
        } else<span class="cov8" title="1"> {
                // Load from environment variables
                GlobalSettings = LoadFromEnv()
        }</span>

        // Validate settings
        <span class="cov8" title="1">if err := GlobalSettings.Validate(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid settings: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "os"
        "strings"
)

// SimpleAccount represents a simple user:password pair
type SimpleAccount struct {
        UserID   string
        Password string
}

// LoadCorporateAccountsFromEnv loads corporate accounts from environment variable array
func LoadCorporateAccountsFromEnv() ([]SimpleAccount, error) <span class="cov0" title="0">{
        // Get the environment variable
        accountsEnv := os.Getenv("ETC_CORP_ACCOUNTS")
        if accountsEnv == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ETC_CORP_ACCOUNTS not set")
        }</span>

        // Parse as JSON array
        <span class="cov0" title="0">var accountStrings []string
        if err := json.Unmarshal([]byte(accountsEnv), &amp;accountStrings); err != nil </span><span class="cov0" title="0">{
                // If JSON parsing fails, try simple comma-separated format
                // Format: user1:pass1,user2:pass2,user3:pass3
                accountStrings = strings.Split(accountsEnv, ",")
        }</span>

        <span class="cov0" title="0">var accounts []SimpleAccount
        for _, accStr := range accountStrings </span><span class="cov0" title="0">{
                // Trim whitespace
                accStr = strings.TrimSpace(accStr)
                if accStr == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Split by colon
                <span class="cov0" title="0">parts := strings.Split(accStr, ":")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid account format: %s (expected user:password)", accStr)
                }</span>

                <span class="cov0" title="0">account := SimpleAccount{
                        UserID:   strings.TrimSpace(parts[0]),
                        Password: strings.TrimSpace(parts[1]),
                }

                accounts = append(accounts, account)</span>
        }

        <span class="cov0" title="0">if len(accounts) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no valid accounts found")
        }</span>

        <span class="cov0" title="0">return accounts, nil</span>
}

// LoadPersonalAccountsFromEnv loads personal accounts from environment variable array
func LoadPersonalAccountsFromEnv() ([]SimpleAccount, error) <span class="cov0" title="0">{
        // Get the environment variable
        accountsEnv := os.Getenv("ETC_PERSONAL_ACCOUNTS")
        if accountsEnv == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ETC_PERSONAL_ACCOUNTS not set")
        }</span>

        // Parse as JSON array
        <span class="cov0" title="0">var accountStrings []string
        if err := json.Unmarshal([]byte(accountsEnv), &amp;accountStrings); err != nil </span><span class="cov0" title="0">{
                // If JSON parsing fails, try simple comma-separated format
                accountStrings = strings.Split(accountsEnv, ",")
        }</span>

        <span class="cov0" title="0">var accounts []SimpleAccount
        for _, accStr := range accountStrings </span><span class="cov0" title="0">{
                accStr = strings.TrimSpace(accStr)
                if accStr == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.Split(accStr, ":")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid account format: %s", accStr)
                }</span>

                <span class="cov0" title="0">account := SimpleAccount{
                        UserID:   strings.TrimSpace(parts[0]),
                        Password: strings.TrimSpace(parts[1]),
                }

                accounts = append(accounts, account)</span>
        }

        <span class="cov0" title="0">return accounts, nil</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
