# 実装計画: Specifyコマンド実行機能

**ブランチ**: `001-specify-is-running` | **日付**: 2025-09-18 | **仕様書**: [spec.md](./spec.md)
**入力**: `/specs/001-specify-is-running/spec.md` の機能仕様書

## 実行フロー (/planコマンドスコープ)
```
1. 入力パスから機能仕様を読み込む
   → 見つからない場合: ERROR "仕様がありません {path}"
2. 技術コンテキストを記入 (明確化必要項目をスキャン)
   → コンテキストからプロジェクトタイプを検出 (web=frontend+backend, mobile=app+api)
   → プロジェクトタイプに基づいて構造決定を設定
3. 憲法ドキュメントの内容に基づいて憲法チェックセクションを記入
4. 下記の憲法チェックセクションを評価
   → 違反がある場合: 複雑性追跡に記録
   → 正当化できない場合: ERROR "まずアプローチを簡素化してください"
   → 進捗追跡を更新: 初期憲法チェック
5. フェーズ0を実行 → research.md
   → 明確化必要項目が残っている場合: ERROR "未知を解決してください"
6. フェーズ1を実行 → contracts, data-model.md, quickstart.md, エージェント固有テンプレート
7. 憲法チェックセクションを再評価
   → 新しい違反がある場合: 設計をリファクタリング、フェーズ1に戻る
   → 進捗追跡を更新: 設計後の憲法チェック
8. フェーズ2を計画 → タスク生成アプローチを記述 (tasks.mdは作成しない)
9. 停止 - /tasksコマンドの準備完了
```

**重要**: /planコマンドはステップ7で停止します。フェーズ2-4は他のコマンドで実行されます:
- フェーズ2: /tasksコマンドがtasks.mdを作成
- フェーズ3-4: 実装実行 (手動またはツール経由)

## 概要
「specify」コマンドツールを実装し、仕様書の処理と実行を行います。提供されたコンテキスト「plan is running…」から、これは仕様駆動開発ワークフローの一部で、specifyコマンドが機能仕様の計画または処理を開始するものと推測されます。

## 技術コンテキスト
**言語/バージョン**: Go 1.21+ (リポジトリコンテキストに基づく)
**主要依存関係**: 標準ライブラリ、自動化用のbashスクリプト
**ストレージ**: ファイルベース (マークダウン仕様書、テンプレート)
**テスティング**: go test (標準Goテストフレームワーク)
**対象プラットフォーム**: クロスプラットフォームCLIツール (Linux/macOS/Windows)
**プロジェクトタイプ**: single - 仕様処理用CLIツール
**パフォーマンス目標**: コマンド実行時のレスポンスが1秒未満
**制約**: 既存の仕様ワークフローとの統合、複数の仕様フォーマット対応
**スケール/スコープ**: 開発ワークフロー自動化用のコマンドラインツール
**引数からの追加コンテキスト**: "plan is running…" - specifyコマンドが計画フェーズをトリガーする

## 憲法チェック
*ゲート: フェーズ0リサーチ前に合格必須。フェーズ1設計後に再チェック。*

憲法テンプレート構造に基づき、一般的なベストプラクティスを適用:
- [ ] **ライブラリファースト設計**: 再利用可能なライブラリとしてコア機能を実装
- [ ] **CLIインターフェース**: テキストベースの入出力プロトコル
- [ ] **テストファースト開発**: 失敗するテストを最初に作成するTDDアプローチ
- [ ] **統合テスティング**: すべてのインターフェースに対する契約テスト
- [ ] **可観測性**: 構造化ログと明確なエラーメッセージ
- [ ] **シンプリシティ**: シンプルに始め、過度なエンジニアリングを避ける

## プロジェクト構造

### ドキュメント (この機能)
```
specs/001-specify-is-running/
├── plan.md              # このファイル (/planコマンド出力)
├── plan-ja.md           # 日本語版計画書
├── research.md          # フェーズ0出力 (/planコマンド)
├── data-model.md        # フェーズ1出力 (/planコマンド)
├── quickstart.md        # フェーズ1出力 (/planコマンド)
├── contracts/           # フェーズ1出力 (/planコマンド)
└── tasks.md             # フェーズ2出力 (/tasksコマンド - /planでは作成しない)
```

### ソースコード (リポジトリルート)
```
# オプション1: シングルプロジェクト (デフォルト)
src/
├── models/
├── services/
├── cli/
└── lib/

tests/
├── contract/
├── integration/
└── unit/
```

**構造決定**: オプション1 (シングルプロジェクト) - ライブラリコンポーネント付きCLIツール

## フェーズ0: アウトライン＆リサーチ
1. **技術コンテキストから未知を抽出**:
   - 各明確化必要項目 → リサーチタスク
   - 各依存関係 → ベストプラクティスタスク
   - 各統合 → パターンタスク

2. **リサーチエージェントの生成とディスパッチ**:
   ```
   技術コンテキストの各未知について:
     タスク: "{feature context}のための{unknown}をリサーチ"
   各技術選択について:
     タスク: "{domain}における{tech}のベストプラクティスを見つける"
   ```

3. **`research.md`に調査結果を統合** (フォーマット使用):
   - 決定: [選択されたもの]
   - 根拠: [選択理由]
   - 検討された代替案: [評価された他のもの]

**出力**: すべての明確化必要項目が解決されたresearch.md

## フェーズ1: 設計＆契約
*前提条件: research.md完了*

1. **機能仕様からエンティティを抽出** → `data-model.md`:
   - エンティティ名、フィールド、関係
   - 要件からの検証ルール
   - 該当する場合は状態遷移

2. **機能要件からAPI契約を生成**:
   - 各ユーザーアクション → エンドポイント
   - 標準REST/GraphQLパターンを使用
   - `/contracts/`にOpenAPI/GraphQLスキーマを出力

3. **契約から契約テストを生成**:
   - エンドポイントごとに1つのテストファイル
   - リクエスト/レスポンススキーマをアサート
   - テストは失敗する必要がある (まだ実装なし)

4. **ユーザーストーリーからテストシナリオを抽出**:
   - 各ストーリー → 統合テストシナリオ
   - クイックスタートテスト = ストーリー検証ステップ

5. **エージェントファイルを段階的に更新** (O(1)操作):
   - AIアシスタント用に`.specify/scripts/bash/update-agent-context.sh claude`を実行
   - 存在する場合: 現在の計画から新しい技術のみを追加
   - マーカー間の手動追加を保持
   - 最近の変更を更新 (最後の3つを保持)
   - トークン効率のため150行以下に保つ
   - リポジトリルートに出力

**出力**: data-model.md、/contracts/*、失敗するテスト、quickstart.md、エージェント固有ファイル

## フェーズ2: タスク計画アプローチ
*このセクションは/tasksコマンドが行うことを説明 - /plan中には実行しない*

**タスク生成戦略**:
- `.specify/templates/tasks-template.md`をベースとして読み込む
- フェーズ1設計ドキュメント（契約、データモデル、クイックスタート）からタスクを生成
- 各契約 → 契約テストタスク [P]
- 各エンティティ → モデル作成タスク [P]
- 各ユーザーストーリー → 統合テストタスク
- テストを合格させる実装タスク

**順序戦略**:
- TDD順序: 実装前にテスト
- 依存関係順序: モデル → サービス → UI
- 並列実行可能なものに[P]マーク (独立したファイル)

**推定出力**: tasks.mdに25-30個の番号付き、順序付きタスク

**重要**: このフェーズは/tasksコマンドで実行され、/planでは実行されません

## フェーズ3+: 将来の実装
*これらのフェーズは/planコマンドの範囲外です*

**フェーズ3**: タスク実行 (/tasksコマンドがtasks.mdを作成)
**フェーズ4**: 実装 (憲法原則に従ってtasks.mdを実行)
**フェーズ5**: 検証 (テスト実行、quickstart.md実行、パフォーマンス検証)

## 複雑性追跡
*憲法チェックに正当化が必要な違反がある場合のみ記入*

| 違反 | 必要な理由 | より簡単な代替案が拒否された理由 |
|------|-----------|----------------------------------|
| [例: 4番目のプロジェクト] | [現在のニーズ] | [3プロジェクトでは不十分な理由] |
| [例: リポジトリパターン] | [特定の問題] | [直接DBアクセスでは不十分な理由] |

## 進捗追跡
*このチェックリストは実行フロー中に更新されます*

**フェーズステータス**:
- [ ] フェーズ0: リサーチ完了 (/planコマンド)
- [ ] フェーズ1: 設計完了 (/planコマンド)
- [ ] フェーズ2: タスク計画完了 (/planコマンド - アプローチの説明のみ)
- [ ] フェーズ3: タスク生成 (/tasksコマンド)
- [ ] フェーズ4: 実装完了
- [ ] フェーズ5: 検証合格

**ゲートステータス**:
- [ ] 初期憲法チェック: 合格
- [ ] 設計後の憲法チェック: 合格
- [ ] すべての明確化必要項目解決
- [ ] 複雑性偏差の文書化

---
*憲法v2.1.1に基づく - `/memory/constitution.md`を参照*