
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>models: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/yhonda-ohishi/etc_meisai/src/models/etc_import_batch.go (100.0%)</option>
				
				<option value="file1">github.com/yhonda-ohishi/etc_meisai/src/models/etc_mapping.go (98.0%)</option>
				
				<option value="file2">github.com/yhonda-ohishi/etc_meisai/src/models/etc_meisai.go (100.0%)</option>
				
				<option value="file3">github.com/yhonda-ohishi/etc_meisai/src/models/etc_meisai_mapping.go (100.0%)</option>
				
				<option value="file4">github.com/yhonda-ohishi/etc_meisai/src/models/etc_meisai_record.go (87.9%)</option>
				
				<option value="file5">github.com/yhonda-ohishi/etc_meisai/src/models/import_session.go (89.9%)</option>
				
				<option value="file6">github.com/yhonda-ohishi/etc_meisai/src/models/validation.go (83.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package models

import (
        "fmt"
        "time"
)

// ETCImportBatch represents a batch import operation
type ETCImportBatch struct {
        ID              int64      `json:"id"`
        BatchHash       string     `json:"batch_hash"`
        FileName        string     `json:"file_name"`
        FileSize        int64      `json:"file_size"`
        AccountID       string     `json:"account_id,omitempty"`
        ImportType      string     `json:"import_type,omitempty"`
        TotalRows       int64      `json:"total_rows"`
        ProcessedRows   int64      `json:"processed_rows"`
        SuccessCount    int64      `json:"success_count"`
        TotalRecords    int32      `json:"total_records"`
        ProcessedCount  int32      `json:"processed_count"`
        CreatedCount    int32      `json:"created_count"`
        DuplicateCount  int32      `json:"duplicate_count"`
        ErrorCount      int64      `json:"error_count"`
        Status          string     `json:"status"` // pending, processing, completed, failed
        StartTime       *time.Time `json:"start_time,omitempty"`
        CompleteTime    *time.Time `json:"complete_time,omitempty"`
        CompletedAt     *time.Time `json:"completed_at,omitempty"`
        ErrorMessage    string     `json:"error_message,omitempty"`
        CreatedAt       time.Time  `json:"created_at"`
        UpdatedAt       time.Time  `json:"updated_at"`
        CreatedBy       string     `json:"created_by,omitempty"`

        // リレーション
        ImportRecords []ETCImportRecord `json:"import_records,omitempty"`
        ImportErrors  []ETCImportError  `json:"import_errors,omitempty"`
}

// BeforeCreate prepares the batch record before creation
func (b *ETCImportBatch) BeforeCreate() error <span class="cov8" title="1">{
        if err := b.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// BeforeUpdate prepares the batch record before updating
func (b *ETCImportBatch) BeforeUpdate() error <span class="cov8" title="1">{
        if err := b.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Validate checks the batch record for business rule compliance
func (b *ETCImportBatch) Validate() error <span class="cov8" title="1">{
        if b.FileName == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("FileName is required")
        }</span>

        <span class="cov8" title="1">if b.TotalRecords &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("TotalRecords cannot be negative")
        }</span>

        <span class="cov8" title="1">validStatuses := map[string]bool{
                "pending":    true,
                "processing": true,
                "completed":  true,
                "failed":     true,
                "cancelled":  true,
        }

        if !validStatuses[b.Status] </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid Status: %s", b.Status)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetProgress returns the progress percentage of the batch
func (b *ETCImportBatch) GetProgress() float32 <span class="cov8" title="1">{
        if b.TotalRecords == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return float32(b.ProcessedCount) / float32(b.TotalRecords) * 100</span>
}

// IsCompleted returns true if the batch is completed
func (b *ETCImportBatch) IsCompleted() bool <span class="cov8" title="1">{
        return b.Status == "completed" || b.Status == "failed" || b.Status == "cancelled"
}</span>

// GetDuration returns the duration of the batch processing
func (b *ETCImportBatch) GetDuration() *time.Duration <span class="cov8" title="1">{
        if b.StartTime == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">endTime := time.Now()
        if b.CompleteTime != nil </span><span class="cov8" title="1">{
                endTime = *b.CompleteTime
        }</span>

        <span class="cov8" title="1">duration := endTime.Sub(*b.StartTime)
        return &amp;duration</span>
}

// ETCImportRecord represents an individual record in an import batch
type ETCImportRecord struct {
        ID          int64     `json:"id"`
        BatchID     int64     `json:"batch_id"`
        ETCMeisaiID *int64    `json:"etc_meisai_id,omitempty"`
        RecordHash  string    `json:"record_hash"`
        Status      string    `json:"status"` // created, duplicate, error
        ErrorMessage string   `json:"error_message,omitempty"`
        CreatedAt   time.Time `json:"created_at"`

        // リレーション
        Batch     *ETCImportBatch `json:"batch,omitempty"`
        ETCMeisai *ETCMeisai      `json:"etc_meisai,omitempty"`
}

// ETCImportError represents an error that occurred during import
type ETCImportError struct {
        ID           int64     `json:"id"`
        BatchID      int64     `json:"batch_id"`
        RowNumber    int32     `json:"row_number"`
        ErrorType    string    `json:"error_type"`
        ErrorMessage string    `json:"error_message"`
        RawData      string    `json:"raw_data,omitempty"`
        CreatedAt    time.Time `json:"created_at"`

        // リレーション
        Batch *ETCImportBatch `json:"batch,omitempty"`
}

// ImportProgressResponse represents the response for import progress
type ImportProgressResponse struct {
        Batch             *ETCImportBatch `json:"batch"`
        ProgressPercentage float32         `json:"progress_percentage"`
        CurrentStatus     string          `json:"current_status"`
        RecentErrors      []string        `json:"recent_errors,omitempty"`
        EstimatedTimeLeft *time.Duration  `json:"estimated_time_left,omitempty"`
}

// ImportSummary provides a summary of the import operation
type ImportSummary struct {
        BatchID         int64         `json:"batch_id"`
        FileName        string        `json:"file_name"`
        TotalRecords    int32         `json:"total_records"`
        ProcessedCount  int32         `json:"processed_count"`
        CreatedCount    int32         `json:"created_count"`
        DuplicateCount  int32         `json:"duplicate_count"`
        ErrorCount      int32         `json:"error_count"`
        Status          string        `json:"status"`
        Duration        *time.Duration `json:"duration,omitempty"`
        ThroughputRPS   float32       `json:"throughput_rps,omitempty"` // Records per second
}</pre>
		
		<pre class="file" id="file1" style="display: none">package models

import (
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "gorm.io/datatypes"
        "gorm.io/gorm"
)

// MappingStatus represents the status of a mapping
type MappingStatus string

const (
        MappingStatusActive   MappingStatus = "active"
        MappingStatusInactive MappingStatus = "inactive"
        MappingStatusPending  MappingStatus = "pending"
        MappingStatusRejected MappingStatus = "rejected"
)

// MappingType represents the type of mapping
type MappingType string

const (
        MappingTypeDtako   MappingType = "dtako"
        MappingTypeExpense MappingType = "expense"
        MappingTypeInvoice MappingType = "invoice"
)

// MappedEntityType represents the type of mapped entity
type MappedEntityType string

const (
        EntityTypeDtakoRecord   MappedEntityType = "dtako_record"
        EntityTypeExpenseRecord MappedEntityType = "expense_record"
        EntityTypeInvoiceRecord MappedEntityType = "invoice_record"
)

// ETCMapping represents the mapping between ETC records and other entities
type ETCMapping struct {
        ID               int64            `gorm:"primaryKey;autoIncrement" json:"id"`
        ETCRecordID      int64            `gorm:"not null;index" json:"etc_record_id"`
        ETCRecord        ETCMeisaiRecord  `gorm:"foreignKey:ETCRecordID" json:"etc_record,omitempty"`
        MappingType      string           `gorm:"size:50;not null;index" json:"mapping_type"`
        MappedEntityID   int64            `gorm:"not null;index" json:"mapped_entity_id"`
        MappedEntityType string           `gorm:"size:50;not null;index" json:"mapped_entity_type"`
        Confidence       float32          `gorm:"default:1.0" json:"confidence"`
        Status           string           `gorm:"size:20;default:'active';index" json:"status"`
        Metadata         datatypes.JSON   `gorm:"type:json" json:"metadata,omitempty"`
        CreatedBy        string           `gorm:"size:100" json:"created_by,omitempty"`
        CreatedAt        time.Time        `gorm:"autoCreateTime" json:"created_at"`
        UpdatedAt        time.Time        `gorm:"autoUpdateTime" json:"updated_at"`
}

// TableName returns the table name for GORM
func (ETCMapping) TableName() string <span class="cov8" title="1">{
        return "etc_mappings"
}</span>

// BeforeCreate hook to validate data before creating
func (m *ETCMapping) BeforeCreate(tx *gorm.DB) error <span class="cov8" title="1">{
        // Set timestamps manually if not using GORM auto-timestamps
        now := time.Now()
        if m.CreatedAt.IsZero() </span><span class="cov8" title="1">{
                m.CreatedAt = now
        }</span>
        <span class="cov8" title="1">if m.UpdatedAt.IsZero() </span><span class="cov8" title="1">{
                m.UpdatedAt = now
        }</span>

        // Set default status if not provided
        <span class="cov8" title="1">if m.Status == "" </span><span class="cov8" title="1">{
                m.Status = string(MappingStatusActive)
        }</span>

        <span class="cov8" title="1">return m.validate()</span>
}

// BeforeSave hook to validate data before saving
func (m *ETCMapping) BeforeSave(tx *gorm.DB) error <span class="cov8" title="1">{
        // Update timestamp manually if not using GORM auto-timestamps
        m.UpdatedAt = time.Now()

        return m.validate()
}</span>

// validate performs comprehensive validation of the mapping
func (m *ETCMapping) validate() error <span class="cov8" title="1">{
        // Validate ETC record ID
        if m.ETCRecordID &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("ETC record ID must be positive")
        }</span>

        // Validate mapping type
        <span class="cov8" title="1">if err := m.validateMappingType(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Validate mapped entity ID
        <span class="cov8" title="1">if m.MappedEntityID &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("mapped entity ID must be positive")
        }</span>

        // Validate mapped entity type
        <span class="cov8" title="1">if err := m.validateMappedEntityType(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Validate confidence
        <span class="cov8" title="1">if m.Confidence &lt; 0.0 || m.Confidence &gt; 1.0 </span><span class="cov8" title="1">{
                return fmt.Errorf("confidence must be between 0.0 and 1.0")
        }</span>

        // Validate status
        <span class="cov8" title="1">if err := m.validateStatus(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate created_by if provided
        <span class="cov8" title="1">if m.CreatedBy != "" &amp;&amp; len(m.CreatedBy) &gt; 100 </span><span class="cov8" title="1">{
                return fmt.Errorf("created_by field too long (max 100 characters)")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateMappingType validates the mapping type
func (m *ETCMapping) validateMappingType() error <span class="cov8" title="1">{
        validTypes := []string{
                string(MappingTypeDtako),
                string(MappingTypeExpense),
                string(MappingTypeInvoice),
        }

        mappingType := strings.ToLower(strings.TrimSpace(m.MappingType))
        if mappingType == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("mapping type cannot be empty")
        }</span>

        <span class="cov8" title="1">for _, validType := range validTypes </span><span class="cov8" title="1">{
                if mappingType == validType </span><span class="cov8" title="1">{
                        m.MappingType = mappingType // Normalize to lowercase
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return fmt.Errorf("invalid mapping type: %s (must be one of: %s)",
                m.MappingType, strings.Join(validTypes, ", "))</span>
}

// validateMappedEntityType validates the mapped entity type
func (m *ETCMapping) validateMappedEntityType() error <span class="cov8" title="1">{
        validTypes := []string{
                string(EntityTypeDtakoRecord),
                string(EntityTypeExpenseRecord),
                string(EntityTypeInvoiceRecord),
        }

        entityType := strings.ToLower(strings.TrimSpace(m.MappedEntityType))
        if entityType == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("mapped entity type cannot be empty")
        }</span>

        <span class="cov8" title="1">for _, validType := range validTypes </span><span class="cov8" title="1">{
                if entityType == validType </span><span class="cov8" title="1">{
                        m.MappedEntityType = entityType // Normalize to lowercase
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return fmt.Errorf("invalid mapped entity type: %s (must be one of: %s)",
                m.MappedEntityType, strings.Join(validTypes, ", "))</span>
}

// validateStatus validates the mapping status
func (m *ETCMapping) validateStatus() error <span class="cov8" title="1">{
        validStatuses := []string{
                string(MappingStatusActive),
                string(MappingStatusInactive),
                string(MappingStatusPending),
                string(MappingStatusRejected),
        }

        status := strings.ToLower(strings.TrimSpace(m.Status))
        if status == "" </span><span class="cov8" title="1">{
                m.Status = string(MappingStatusActive) // Default to active
                return nil
        }</span>

        <span class="cov8" title="1">for _, validStatus := range validStatuses </span><span class="cov8" title="1">{
                if status == validStatus </span><span class="cov8" title="1">{
                        m.Status = status // Normalize to lowercase
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return fmt.Errorf("invalid status: %s (must be one of: %s)",
                m.Status, strings.Join(validStatuses, ", "))</span>
}

// IsActive returns true if the mapping is active
func (m *ETCMapping) IsActive() bool <span class="cov8" title="1">{
        return m.Status == string(MappingStatusActive)
}</span>

// IsPending returns true if the mapping is pending approval
func (m *ETCMapping) IsPending() bool <span class="cov8" title="1">{
        return m.Status == string(MappingStatusPending)
}</span>

// CanTransitionTo checks if the mapping can transition to the given status
func (m *ETCMapping) CanTransitionTo(newStatus string) bool <span class="cov8" title="1">{
        currentStatus := MappingStatus(m.Status)
        targetStatus := MappingStatus(newStatus)

        switch currentStatus </span>{
        case MappingStatusPending:<span class="cov8" title="1">
                return targetStatus == MappingStatusActive || targetStatus == MappingStatusRejected</span>
        case MappingStatusActive:<span class="cov8" title="1">
                return targetStatus == MappingStatusInactive</span>
        case MappingStatusInactive:<span class="cov8" title="1">
                return targetStatus == MappingStatusActive</span>
        case MappingStatusRejected:<span class="cov8" title="1">
                return targetStatus == MappingStatusPending</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// Activate sets the mapping status to active if allowed
func (m *ETCMapping) Activate() error <span class="cov8" title="1">{
        if !m.CanTransitionTo(string(MappingStatusActive)) </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot activate mapping from status: %s", m.Status)
        }</span>
        <span class="cov8" title="1">m.Status = string(MappingStatusActive)
        return nil</span>
}

// Deactivate sets the mapping status to inactive if allowed
func (m *ETCMapping) Deactivate() error <span class="cov8" title="1">{
        if !m.CanTransitionTo(string(MappingStatusInactive)) </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot deactivate mapping from status: %s", m.Status)
        }</span>
        <span class="cov8" title="1">m.Status = string(MappingStatusInactive)
        return nil</span>
}

// Approve sets the mapping status to active from pending
func (m *ETCMapping) Approve() error <span class="cov8" title="1">{
        if m.Status != string(MappingStatusPending) </span><span class="cov8" title="1">{
                return fmt.Errorf("can only approve pending mappings, current status: %s", m.Status)
        }</span>
        <span class="cov8" title="1">m.Status = string(MappingStatusActive)
        return nil</span>
}

// Reject sets the mapping status to rejected from pending
func (m *ETCMapping) Reject() error <span class="cov8" title="1">{
        if m.Status != string(MappingStatusPending) </span><span class="cov8" title="1">{
                return fmt.Errorf("can only reject pending mappings, current status: %s", m.Status)
        }</span>
        <span class="cov8" title="1">m.Status = string(MappingStatusRejected)
        return nil</span>
}

// SetMetadata sets the metadata field with validation
func (m *ETCMapping) SetMetadata(metadata map[string]interface{}) error <span class="cov8" title="1">{
        if metadata == nil </span><span class="cov8" title="1">{
                m.Metadata = nil
                return nil
        }</span>

        // Convert to JSON
        <span class="cov8" title="1">jsonData, err := json.Marshal(metadata)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal metadata: %w", err)
        }</span>

        // Check size (limit to reasonable size)
        <span class="cov8" title="1">if len(jsonData) &gt; 65535 </span><span class="cov8" title="1">{ // 64KB limit
                return fmt.Errorf("metadata too large (max 64KB)")
        }</span>

        <span class="cov8" title="1">m.Metadata = datatypes.JSON(jsonData)
        return nil</span>
}

// GetMetadata returns the metadata as a map
func (m *ETCMapping) GetMetadata() (map[string]interface{}, error) <span class="cov8" title="1">{
        if m.Metadata == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">var metadata map[string]interface{}
        if err := json.Unmarshal([]byte(m.Metadata), &amp;metadata); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to unmarshal metadata: %w", err)
        }</span>

        <span class="cov8" title="1">return metadata, nil</span>
}

// GetConfidencePercentage returns confidence as a percentage
func (m *ETCMapping) GetConfidencePercentage() float64 <span class="cov8" title="1">{
        return float64(m.Confidence * 100)
}</span>

// IsHighConfidence returns true if confidence is above 0.8
func (m *ETCMapping) IsHighConfidence() bool <span class="cov8" title="1">{
        return m.Confidence &gt;= 0.8
}</span>

// IsLowConfidence returns true if confidence is below 0.5
func (m *ETCMapping) IsLowConfidence() bool <span class="cov8" title="1">{
        return m.Confidence &lt; 0.5
}</pre>
		
		<pre class="file" id="file2" style="display: none">package models

import (
        "crypto/sha256"
        "fmt"
        "time"
)

// ETCMeisai represents the main ETC transaction record
type ETCMeisai struct {
        // Primary Key
        ID int64 `json:"id"`

        // 利用情報
        UseDate time.Time `json:"use_date"`
        UseTime string    `json:"use_time"`

        // 料金所情報
        EntryIC string `json:"entry_ic"`
        ExitIC  string `json:"exit_ic"`

        // 金額情報
        Amount int32 `json:"amount"`

        // 車両情報
        CarNumber string `json:"car_number"`

        // ETC情報
        ETCNumber string `json:"etc_number"`

        // データ整合性
        Hash string `json:"hash"`

        // タイムスタンプ
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`

        // リレーション
        Mappings []ETCMeisaiMapping `json:"mappings,omitempty"`
}

// BeforeCreate prepares the record before creation
func (e *ETCMeisai) BeforeCreate() error <span class="cov8" title="1">{
        // Set timestamps
        now := time.Now()
        if e.CreatedAt.IsZero() </span><span class="cov8" title="1">{
                e.CreatedAt = now
        }</span>
        <span class="cov8" title="1">if e.UpdatedAt.IsZero() </span><span class="cov8" title="1">{
                e.UpdatedAt = now
        }</span>

        // Generate hash if not provided
        <span class="cov8" title="1">if e.Hash == "" </span><span class="cov8" title="1">{
                e.Hash = e.GenerateHash()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// BeforeUpdate prepares the record before updating
func (e *ETCMeisai) BeforeUpdate() error <span class="cov8" title="1">{
        // Update timestamp
        e.UpdatedAt = time.Now()

        // Re-generate hash on update
        e.Hash = e.GenerateHash()

        return nil
}</span>

// GenerateHash creates a unique hash for the ETC record
func (e *ETCMeisai) GenerateHash() string <span class="cov8" title="1">{
        data := fmt.Sprintf("%s|%s|%s|%s|%d|%s|%s",
                e.UseDate.Format("2006-01-02"),
                e.UseTime,
                e.EntryIC,
                e.ExitIC,
                e.Amount,
                e.CarNumber,
                e.ETCNumber,
        )

        hash := sha256.Sum256([]byte(data))
        return fmt.Sprintf("%x", hash)
}</span>

// Validate checks the ETC record for business rule compliance
func (e *ETCMeisai) Validate() error <span class="cov8" title="1">{
        if e.UseDate.IsZero() </span><span class="cov8" title="1">{
                return fmt.Errorf("UseDate is required")
        }</span>

        <span class="cov8" title="1">if e.UseTime == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("UseTime is required")
        }</span>

        <span class="cov8" title="1">if e.EntryIC == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("EntryIC is required")
        }</span>

        <span class="cov8" title="1">if e.ExitIC == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("ExitIC is required")
        }</span>

        <span class="cov8" title="1">if e.Amount &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("Amount cannot be negative")
        }</span>

        <span class="cov8" title="1">if e.CarNumber == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("CarNumber is required")
        }</span>

        <span class="cov8" title="1">if e.ETCNumber == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("ETCNumber is required")
        }</span>

        <span class="cov8" title="1">if len(e.ETCNumber) &gt; 20 </span><span class="cov8" title="1">{
                return fmt.Errorf("ETCNumber too long")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ETCListParams defines parameters for querying ETC records
type ETCListParams struct {
        Limit     int        `json:"limit"`
        Offset    int        `json:"offset"`
        StartDate *time.Time `json:"start_date,omitempty"`
        EndDate   *time.Time `json:"end_date,omitempty"`
        FromDate  *time.Time `json:"from_date,omitempty"` // Alias for StartDate
        ToDate    *time.Time `json:"to_date,omitempty"`   // Alias for EndDate
        ETCNumber string     `json:"etc_number,omitempty"`
        CarNumber string     `json:"car_number,omitempty"`
        EntryIC   string     `json:"entry_ic,omitempty"`
        ExitIC    string     `json:"exit_ic,omitempty"`
        SortBy    string     `json:"sort_by,omitempty"`
        OrderBy   string     `json:"order_by,omitempty"`   // Alias for SortBy
        SortOrder string     `json:"sort_order,omitempty"`
}

// SetDefaults sets default values for list parameters
func (p *ETCListParams) SetDefaults() <span class="cov8" title="1">{
        if p.Limit &lt;= 0 || p.Limit &gt; 1000 </span><span class="cov8" title="1">{
                if p.Limit &gt; 1000 </span><span class="cov8" title="1">{
                        p.Limit = 1000
                }</span> else<span class="cov8" title="1"> {
                        p.Limit = 100
                }</span>
        }
        <span class="cov8" title="1">if p.Offset &lt; 0 </span><span class="cov8" title="1">{
                p.Offset = 0
        }</span>
}

// ETCSummary provides aggregated statistics for ETC records
type ETCSummary struct {
        TotalAmount int64     `json:"total_amount"`
        TotalCount  int64     `json:"total_count"`
        StartDate   time.Time `json:"start_date"`
        EndDate     time.Time `json:"end_date"`
        ByETCNumber map[string]*ETCNumberSummary  `json:"by_etc_number"`
        ByMonth     map[string]*ETCMonthlySummary `json:"by_month"`
}

// ETCNumberSummary provides summary statistics per ETC number
type ETCNumberSummary struct {
        ETCNumber   string `json:"etc_number"`
        TotalAmount int64  `json:"total_amount"`
        TotalCount  int64  `json:"total_count"`
}

// ETCMonthlySummary provides summary statistics per month
type ETCMonthlySummary struct {
        Year        int   `json:"year"`
        Month       int   `json:"month"`
        TotalAmount int64 `json:"total_amount"`
        TotalCount  int64 `json:"total_count"`
}

// ETCMonthlyStats provides detailed monthly statistics
type ETCMonthlyStats struct {
        Year           int                          `json:"year"`
        Month          int                          `json:"month"`
        TotalAmount    int64                        `json:"total_amount"`
        TotalCount     int64                        `json:"total_count"`
        DailyBreakdown map[int]*ETCDailySummary     `json:"daily_breakdown"`
        TopRoutes      []*ETCRouteSummary           `json:"top_routes"`
}

// ETCDailySummary provides daily statistics within a month
type ETCDailySummary struct {
        Day    int   `json:"day"`
        Amount int64 `json:"amount"`
        Count  int64 `json:"count"`
}

// ETCRouteSummary provides statistics for popular routes
type ETCRouteSummary struct {
        EntryIC     string `json:"entry_ic"`
        ExitIC      string `json:"exit_ic"`
        Count       int64  `json:"count"`
        TotalAmount int64  `json:"total_amount"`
        AvgAmount   int64  `json:"avg_amount"`
}</pre>
		
		<pre class="file" id="file3" style="display: none">package models

import (
        "fmt"
        "time"
)

// ETCMeisaiMapping represents the mapping between ETC records and DTako records
type ETCMeisaiMapping struct {
        ID          int64     `json:"id"`
        ETCMeisaiID int64     `json:"etc_meisai_id"`
        DTakoRowID  string    `json:"dtako_row_id"`
        MappingType string    `json:"mapping_type"` // auto, manual
        Confidence  float32   `json:"confidence"`
        Notes       string    `json:"notes,omitempty"`
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`
        CreatedBy   string    `json:"created_by,omitempty"`

        // リレーション
        ETCMeisai *ETCMeisai `json:"etc_meisai,omitempty"`
}

// BeforeCreate prepares the mapping record before creation
func (m *ETCMeisaiMapping) BeforeCreate() error <span class="cov8" title="1">{
        if err := m.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// BeforeUpdate prepares the mapping record before updating
func (m *ETCMeisaiMapping) BeforeUpdate() error <span class="cov8" title="1">{
        if err := m.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Validate checks the mapping record for business rule compliance
func (m *ETCMeisaiMapping) Validate() error <span class="cov8" title="1">{
        if m.ETCMeisaiID &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("ETCMeisaiID must be positive")
        }</span>

        <span class="cov8" title="1">if m.DTakoRowID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("DTakoRowID is required")
        }</span>

        <span class="cov8" title="1">if m.MappingType != "auto" &amp;&amp; m.MappingType != "manual" </span><span class="cov8" title="1">{
                return fmt.Errorf("MappingType must be 'auto' or 'manual'")
        }</span>

        <span class="cov8" title="1">if m.Confidence &lt; 0 || m.Confidence &gt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("Confidence must be between 0 and 1")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsHighConfidence returns true if the mapping has high confidence
func (m *ETCMeisaiMapping) IsHighConfidence() bool <span class="cov8" title="1">{
        return m.Confidence &gt;= 0.8
}</span>

// MappingListParams defines parameters for querying mapping records
type MappingListParams struct {
        Limit         int      `json:"limit"`
        Offset        int      `json:"offset"`
        ETCMeisaiID   *int64   `json:"etc_meisai_id,omitempty"`
        DTakoRowID    string   `json:"dtako_row_id,omitempty"`
        MappingType   string   `json:"mapping_type,omitempty"`
        MinConfidence *float32 `json:"min_confidence,omitempty"`
        CreatedBy     string   `json:"created_by,omitempty"`
}

// PotentialMatch represents a potential mapping match
type PotentialMatch struct {
        DTakoRowID   string                 `json:"dtako_row_id"`
        Confidence   float32                `json:"confidence"`
        MatchReasons []string               `json:"match_reasons"`
        DTakoData    map[string]interface{} `json:"dtako_data"`
}

// MappingStats provides statistics about mappings
type MappingStats struct {
        TotalMappings   int64   `json:"total_mappings"`
        AutoMappings    int64   `json:"auto_mappings"`
        ManualMappings  int64   `json:"manual_mappings"`
        HighConfidence  int64   `json:"high_confidence"`
        LowConfidence   int64   `json:"low_confidence"`
        AverageConfidence float32 `json:"average_confidence"`
        UnmappedRecords int64   `json:"unmapped_records"`
}

// AutoMatchResult represents the result of an auto-matching operation
type AutoMatchResult struct {
        ETCMeisaiID      int64             `json:"etc_meisai_id"`
        PotentialMatches []*PotentialMatch `json:"potential_matches,omitempty"`
        BestMatch        *PotentialMatch   `json:"best_match,omitempty"`
        Error            string            `json:"error,omitempty"`
}</pre>
		
		<pre class="file" id="file4" style="display: none">package models

import (
        "crypto/sha256"
        "fmt"
        "regexp"
        "strconv"
        "strings"
        "time"

        "gorm.io/gorm"
)

// ETCMeisaiRecord represents an ETC toll record with comprehensive validation
type ETCMeisaiRecord struct {
        ID              int64              `gorm:"primaryKey;autoIncrement" json:"id"`
        Hash            string             `gorm:"uniqueIndex;size:64;not null" json:"hash"`
        Date            time.Time          `gorm:"index;not null" json:"date"`
        Time            string             `gorm:"size:8;not null" json:"time"`
        EntranceIC      string             `gorm:"size:100;not null" json:"entrance_ic"`
        ExitIC          string             `gorm:"size:100;not null" json:"exit_ic"`
        TollAmount      int                `gorm:"not null" json:"toll_amount"`
        CarNumber       string             `gorm:"index;size:20;not null" json:"car_number"`
        ETCCardNumber   string             `gorm:"index;size:20;not null" json:"etc_card_number"`
        ETCNum          *string            `gorm:"index;size:50" json:"etc_num,omitempty"`
        DtakoRowID      *int64             `gorm:"index" json:"dtako_row_id,omitempty"`
        CreatedAt       time.Time          `gorm:"autoCreateTime" json:"created_at"`
        UpdatedAt       time.Time          `gorm:"autoUpdateTime" json:"updated_at"`
        DeletedAt       gorm.DeletedAt     `gorm:"index" json:"deleted_at,omitempty"`
}

// TableName returns the table name for GORM
func (ETCMeisaiRecord) TableName() string <span class="cov8" title="1">{
        return "etc_meisai_records"
}</span>

// BeforeCreate hook to generate hash before creating record
func (r *ETCMeisaiRecord) BeforeCreate(tx *gorm.DB) error <span class="cov8" title="1">{
        if err := r.validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if r.Hash == "" </span><span class="cov8" title="1">{
                r.Hash = r.generateHash()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// BeforeSave hook to validate data before saving
func (r *ETCMeisaiRecord) BeforeSave(tx *gorm.DB) error <span class="cov8" title="1">{
        return r.validate()
}</span>

// validate performs comprehensive validation of the record
func (r *ETCMeisaiRecord) validate() error <span class="cov8" title="1">{
        // Validate date (not in future)
        if r.Date.After(time.Now()) </span><span class="cov0" title="0">{
                return fmt.Errorf("date cannot be in the future")
        }</span>

        // Validate time format (HH:MM:SS)
        <span class="cov8" title="1">timeRegex := regexp.MustCompile(`^([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$`)
        if !timeRegex.MatchString(r.Time) </span><span class="cov0" title="0">{
                return fmt.Errorf("time must be in HH:MM:SS format")
        }</span>

        // Validate entrance and exit IC names
        <span class="cov8" title="1">if len(strings.TrimSpace(r.EntranceIC)) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("entrance IC cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(strings.TrimSpace(r.ExitIC)) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("exit IC cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(r.EntranceIC) &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("entrance IC name too long (max 100 characters)")
        }</span>
        <span class="cov8" title="1">if len(r.ExitIC) &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("exit IC name too long (max 100 characters)")
        }</span>

        // Validate toll amount
        <span class="cov8" title="1">if r.TollAmount &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("toll amount must be non-negative")
        }</span>
        <span class="cov8" title="1">if r.TollAmount &gt; 999999 </span><span class="cov0" title="0">{
                return fmt.Errorf("toll amount too large (max 999999)")
        }</span>

        // Validate car number (Japanese vehicle number format)
        <span class="cov8" title="1">if err := r.validateCarNumber(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Validate ETC card number (16-19 digits)
        <span class="cov8" title="1">if err := r.validateETCCardNumber(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Validate ETC number if provided
        <span class="cov8" title="1">if r.ETCNum != nil &amp;&amp; *r.ETCNum != "" </span><span class="cov8" title="1">{
                if err := r.validateETCNum(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateCarNumber validates Japanese vehicle number format
func (r *ETCMeisaiRecord) validateCarNumber() error <span class="cov8" title="1">{
        if len(strings.TrimSpace(r.CarNumber)) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("car number cannot be empty")
        }</span>

        // Japanese vehicle number patterns
        <span class="cov8" title="1">patterns := []string{
                `^\d{3}-\d{2}$`,                    // 軽自動車: 123-45
                `^\d{3}\s\d{2}$`,                   // 軽自動車: 123 45
                `^[あ-ん]{1}\d{3}$`,                // ひらがな + 数字: あ123
                `^[ア-ン]{1}\d{3}$`,                // カタカナ + 数字: ア123
                `^\d{2}-\d{2}$`,                    // 二輪: 12-34
                `^\d{4}$`,                          // 4桁数字
                `^[a-zA-Z0-9\-\s]{3,20}$`,         // 一般的なパターン
        }

        for _, pattern := range patterns </span><span class="cov8" title="1">{
                if matched, _ := regexp.MatchString(pattern, r.CarNumber); matched </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return fmt.Errorf("invalid car number format")</span>
}

// validateETCCardNumber validates ETC card number format
func (r *ETCMeisaiRecord) validateETCCardNumber() error <span class="cov8" title="1">{
        if len(strings.TrimSpace(r.ETCCardNumber)) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("ETC card number cannot be empty")
        }</span>

        // Remove spaces and hyphens for validation
        <span class="cov8" title="1">cleaned := strings.ReplaceAll(strings.ReplaceAll(r.ETCCardNumber, " ", ""), "-", "")

        // Check if it's 16-19 digits
        if len(cleaned) &lt; 16 || len(cleaned) &gt; 19 </span><span class="cov8" title="1">{
                return fmt.Errorf("ETC card number must be 16-19 digits")
        }</span>

        // Check if all characters are digits
        <span class="cov8" title="1">if _, err := strconv.ParseInt(cleaned, 10, 64); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("ETC card number must contain only digits")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateETCNum validates ETC 2.0 device number format
func (r *ETCMeisaiRecord) validateETCNum() error <span class="cov8" title="1">{
        if r.ETCNum == nil || *r.ETCNum == "" </span><span class="cov8" title="1">{
                return nil // Optional field
        }</span>

        // ETC 2.0 device number is typically alphanumeric, 10-20 characters
        <span class="cov8" title="1">etcNum := strings.TrimSpace(*r.ETCNum)
        if len(etcNum) &lt; 5 || len(etcNum) &gt; 50 </span><span class="cov8" title="1">{
                return fmt.Errorf("ETC number must be 5-50 characters")
        }</span>

        // Allow alphanumeric characters and some special characters
        <span class="cov8" title="1">pattern := `^[a-zA-Z0-9\-_]+$`
        if matched, _ := regexp.MatchString(pattern, etcNum); !matched </span><span class="cov0" title="0">{
                return fmt.Errorf("ETC number contains invalid characters")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// generateHash creates a SHA256 hash for the record
func (r *ETCMeisaiRecord) generateHash() string <span class="cov8" title="1">{
        data := fmt.Sprintf("%s|%s|%s|%s|%d|%s|%s",
                r.Date.Format("2006-01-02"),
                r.Time,
                r.EntranceIC,
                r.ExitIC,
                r.TollAmount,
                r.CarNumber,
                r.ETCCardNumber,
        )

        hash := sha256.Sum256([]byte(data))
        return fmt.Sprintf("%x", hash)
}</span>

// GetDateString returns the date in YYYY-MM-DD format
func (r *ETCMeisaiRecord) GetDateString() string <span class="cov8" title="1">{
        return r.Date.Format("2006-01-02")
}</span>

// GenerateHash creates a SHA256 hash for the record (public method)
func (r *ETCMeisaiRecord) GenerateHash() string <span class="cov8" title="1">{
        return r.generateHash()
}</span>

// Validate performs comprehensive validation of the record (public method)
func (r *ETCMeisaiRecord) Validate() error <span class="cov8" title="1">{
        return r.validate()
}</span>

// GetMaskedETCCardNumber returns a masked version of the ETC card number
func (r *ETCMeisaiRecord) GetMaskedETCCardNumber() string <span class="cov8" title="1">{
        if len(r.ETCCardNumber) &lt;= 4 </span><span class="cov8" title="1">{
                return "****"
        }</span>

        // Show only last 4 digits
        <span class="cov8" title="1">return "****-****-****-" + r.ETCCardNumber[len(r.ETCCardNumber)-4:]</span>
}

// IsValidForMapping checks if the record has required fields for mapping
func (r *ETCMeisaiRecord) IsValidForMapping() bool <span class="cov8" title="1">{
        return r.ID &gt; 0 &amp;&amp; r.Hash != "" &amp;&amp; !r.Date.IsZero()
}</pre>
		
		<pre class="file" id="file5" style="display: none">package models

import (
        "encoding/json"
        "fmt"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "github.com/google/uuid"
        "gorm.io/datatypes"
        "gorm.io/gorm"
)

// ImportStatus represents the status of an import session
type ImportStatus string

const (
        ImportStatusPending    ImportStatus = "pending"
        ImportStatusProcessing ImportStatus = "processing"
        ImportStatusCompleted  ImportStatus = "completed"
        ImportStatusFailed     ImportStatus = "failed"
        ImportStatusCancelled  ImportStatus = "cancelled"
)

// AccountType represents the type of account
type AccountType string

const (
        AccountTypeCorporate AccountType = "corporate"
        AccountTypePersonal  AccountType = "personal"
)

// ImportError represents an error that occurred during import
type ImportError struct {
        RowNumber    int    `json:"row_number"`
        ErrorType    string `json:"error_type"`
        ErrorMessage string `json:"error_message"`
        RawData      string `json:"raw_data,omitempty"`
}

// ImportSession represents an import session for CSV files
type ImportSession struct {
        ID            string         `gorm:"primaryKey;size:36" json:"id"` // UUID
        AccountType   string         `gorm:"size:20;not null;index" json:"account_type"`
        AccountID     string         `gorm:"size:50;not null;index" json:"account_id"`
        FileName      string         `gorm:"size:255;not null" json:"file_name"`
        FileSize      int64          `gorm:"not null" json:"file_size"`
        Status        string         `gorm:"size:20;not null;index" json:"status"`
        TotalRows     int            `gorm:"default:0" json:"total_rows"`
        ProcessedRows int            `gorm:"default:0" json:"processed_rows"`
        SuccessRows   int            `gorm:"default:0" json:"success_rows"`
        ErrorRows     int            `gorm:"default:0" json:"error_rows"`
        DuplicateRows int            `gorm:"default:0" json:"duplicate_rows"`
        StartedAt     time.Time      `gorm:"not null" json:"started_at"`
        CompletedAt   *time.Time     `json:"completed_at,omitempty"`
        ErrorLog      datatypes.JSON `gorm:"type:json" json:"error_log,omitempty"`
        CreatedBy     string         `gorm:"size:100" json:"created_by,omitempty"`
        CreatedAt     time.Time      `gorm:"autoCreateTime" json:"created_at"`
}

// TableName returns the table name for GORM
func (ImportSession) TableName() string <span class="cov8" title="1">{
        return "import_sessions"
}</span>

// BeforeCreate hook to generate UUID and validate data before creating
func (s *ImportSession) BeforeCreate(tx *gorm.DB) error <span class="cov8" title="1">{
        // Generate UUID if not provided
        if s.ID == "" </span><span class="cov8" title="1">{
                s.ID = uuid.New().String()
        }</span>

        // Set started time if not provided
        <span class="cov8" title="1">if s.StartedAt.IsZero() </span><span class="cov8" title="1">{
                s.StartedAt = time.Now()
        }</span>

        // Set default status if not provided
        <span class="cov8" title="1">if s.Status == "" </span><span class="cov0" title="0">{
                s.Status = string(ImportStatusPending)
        }</span>

        <span class="cov8" title="1">return s.validate()</span>
}

// BeforeSave hook to validate data before saving
func (s *ImportSession) BeforeSave(tx *gorm.DB) error <span class="cov8" title="1">{
        return s.validate()
}</span>

// validate performs comprehensive validation of the import session
func (s *ImportSession) validate() error <span class="cov8" title="1">{
        // Validate UUID format
        if err := s.validateID(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Validate account type
        <span class="cov8" title="1">if err := s.validateAccountType(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Validate account ID
        <span class="cov8" title="1">if err := s.validateAccountID(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Validate file name
        <span class="cov8" title="1">if err := s.validateFileName(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Validate file size
        <span class="cov8" title="1">if err := s.validateFileSize(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Validate status
        <span class="cov8" title="1">if err := s.validateStatus(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Validate row counts
        <span class="cov8" title="1">if err := s.validateRowCounts(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Validate created_by if provided
        <span class="cov8" title="1">if s.CreatedBy != "" &amp;&amp; len(s.CreatedBy) &gt; 100 </span><span class="cov0" title="0">{
                return fmt.Errorf("created_by field too long (max 100 characters)")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateID validates the UUID format
func (s *ImportSession) validateID() error <span class="cov8" title="1">{
        if s.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("ID cannot be empty")
        }</span>

        // Validate UUID v4 format
        <span class="cov8" title="1">if _, err := uuid.Parse(s.ID); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid UUID format: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateAccountType validates the account type
func (s *ImportSession) validateAccountType() error <span class="cov8" title="1">{
        validTypes := []string{
                string(AccountTypeCorporate),
                string(AccountTypePersonal),
        }

        accountType := strings.ToLower(strings.TrimSpace(s.AccountType))
        if accountType == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("account type cannot be empty")
        }</span>

        <span class="cov8" title="1">for _, validType := range validTypes </span><span class="cov8" title="1">{
                if accountType == validType </span><span class="cov8" title="1">{
                        s.AccountType = accountType // Normalize to lowercase
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return fmt.Errorf("invalid account type: %s (must be one of: %s)",
                s.AccountType, strings.Join(validTypes, ", "))</span>
}

// validateAccountID validates the account ID
func (s *ImportSession) validateAccountID() error <span class="cov8" title="1">{
        accountID := strings.TrimSpace(s.AccountID)
        if accountID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("account ID cannot be empty")
        }</span>

        <span class="cov8" title="1">if len(accountID) &gt; 50 </span><span class="cov8" title="1">{
                return fmt.Errorf("account ID too long (max 50 characters)")
        }</span>

        // Account ID should be alphanumeric with some special characters
        <span class="cov8" title="1">pattern := `^[a-zA-Z0-9\-_@.]+$`
        if matched, _ := regexp.MatchString(pattern, accountID); !matched </span><span class="cov0" title="0">{
                return fmt.Errorf("account ID contains invalid characters")
        }</span>

        <span class="cov8" title="1">s.AccountID = accountID
        return nil</span>
}

// validateFileName validates the file name
func (s *ImportSession) validateFileName() error <span class="cov8" title="1">{
        fileName := strings.TrimSpace(s.FileName)
        if fileName == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("file name cannot be empty")
        }</span>

        <span class="cov8" title="1">if len(fileName) &gt; 255 </span><span class="cov8" title="1">{
                return fmt.Errorf("file name too long (max 255 characters)")
        }</span>

        // Check file extension
        <span class="cov8" title="1">ext := strings.ToLower(filepath.Ext(fileName))
        if ext != ".csv" </span><span class="cov8" title="1">{
                return fmt.Errorf("file must have .csv extension")
        }</span>

        <span class="cov8" title="1">s.FileName = fileName
        return nil</span>
}

// validateFileSize validates the file size
func (s *ImportSession) validateFileSize() error <span class="cov8" title="1">{
        if s.FileSize &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("file size must be greater than 0")
        }</span>

        // Maximum file size: 100MB
        <span class="cov8" title="1">maxSize := int64(100 * 1024 * 1024)
        if s.FileSize &gt; maxSize </span><span class="cov8" title="1">{
                return fmt.Errorf("file size too large (max 100MB)")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateStatus validates the import status
func (s *ImportSession) validateStatus() error <span class="cov8" title="1">{
        validStatuses := []string{
                string(ImportStatusPending),
                string(ImportStatusProcessing),
                string(ImportStatusCompleted),
                string(ImportStatusFailed),
                string(ImportStatusCancelled),
        }

        status := strings.ToLower(strings.TrimSpace(s.Status))
        if status == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("status cannot be empty")
        }</span>

        <span class="cov8" title="1">for _, validStatus := range validStatuses </span><span class="cov8" title="1">{
                if status == validStatus </span><span class="cov8" title="1">{
                        s.Status = status // Normalize to lowercase
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return fmt.Errorf("invalid status: %s (must be one of: %s)",
                s.Status, strings.Join(validStatuses, ", "))</span>
}

// validateRowCounts validates the row count fields
func (s *ImportSession) validateRowCounts() error <span class="cov8" title="1">{
        // All counts must be non-negative
        if s.TotalRows &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("total rows cannot be negative")
        }</span>
        <span class="cov8" title="1">if s.ProcessedRows &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("processed rows cannot be negative")
        }</span>
        <span class="cov8" title="1">if s.SuccessRows &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("success rows cannot be negative")
        }</span>
        <span class="cov8" title="1">if s.ErrorRows &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("error rows cannot be negative")
        }</span>
        <span class="cov8" title="1">if s.DuplicateRows &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("duplicate rows cannot be negative")
        }</span>

        // Processed rows should equal sum of success, error, and duplicate rows
        <span class="cov8" title="1">expectedProcessed := s.SuccessRows + s.ErrorRows + s.DuplicateRows
        if s.ProcessedRows != expectedProcessed </span><span class="cov8" title="1">{
                return fmt.Errorf("processed rows (%d) must equal sum of success (%d) + error (%d) + duplicate (%d) rows",
                        s.ProcessedRows, s.SuccessRows, s.ErrorRows, s.DuplicateRows)
        }</span>

        // Processed rows cannot exceed total rows
        <span class="cov8" title="1">if s.ProcessedRows &gt; s.TotalRows </span><span class="cov8" title="1">{
                return fmt.Errorf("processed rows (%d) cannot exceed total rows (%d)",
                        s.ProcessedRows, s.TotalRows)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsCompleted returns true if the import is completed
func (s *ImportSession) IsCompleted() bool <span class="cov8" title="1">{
        return s.Status == string(ImportStatusCompleted)
}</span>

// IsFailed returns true if the import failed
func (s *ImportSession) IsFailed() bool <span class="cov8" title="1">{
        return s.Status == string(ImportStatusFailed)
}</span>

// IsInProgress returns true if the import is currently processing
func (s *ImportSession) IsInProgress() bool <span class="cov8" title="1">{
        return s.Status == string(ImportStatusProcessing)
}</span>

// IsPending returns true if the import is pending
func (s *ImportSession) IsPending() bool <span class="cov8" title="1">{
        return s.Status == string(ImportStatusPending)
}</span>

// CanTransitionTo checks if the session can transition to the given status
func (s *ImportSession) CanTransitionTo(newStatus string) bool <span class="cov8" title="1">{
        currentStatus := ImportStatus(s.Status)
        targetStatus := ImportStatus(newStatus)

        switch currentStatus </span>{
        case ImportStatusPending:<span class="cov8" title="1">
                return targetStatus == ImportStatusProcessing || targetStatus == ImportStatusCancelled</span>
        case ImportStatusProcessing:<span class="cov8" title="1">
                return targetStatus == ImportStatusCompleted || targetStatus == ImportStatusFailed || targetStatus == ImportStatusCancelled</span>
        case ImportStatusCompleted, ImportStatusFailed, ImportStatusCancelled:<span class="cov8" title="1">
                return false</span> // Terminal states
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// StartProcessing transitions the session to processing status
func (s *ImportSession) StartProcessing() error <span class="cov8" title="1">{
        if !s.CanTransitionTo(string(ImportStatusProcessing)) </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot start processing from status: %s", s.Status)
        }</span>
        <span class="cov8" title="1">s.Status = string(ImportStatusProcessing)
        if s.StartedAt.IsZero() </span><span class="cov8" title="1">{
                s.StartedAt = time.Now()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Complete transitions the session to completed status
func (s *ImportSession) Complete() error <span class="cov8" title="1">{
        if !s.CanTransitionTo(string(ImportStatusCompleted)) </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot complete from status: %s", s.Status)
        }</span>
        <span class="cov8" title="1">s.Status = string(ImportStatusCompleted)
        now := time.Now()
        s.CompletedAt = &amp;now
        return nil</span>
}

// Fail transitions the session to failed status
func (s *ImportSession) Fail() error <span class="cov8" title="1">{
        if !s.CanTransitionTo(string(ImportStatusFailed)) </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot fail from status: %s", s.Status)
        }</span>
        <span class="cov8" title="1">s.Status = string(ImportStatusFailed)
        now := time.Now()
        s.CompletedAt = &amp;now
        return nil</span>
}

// Cancel transitions the session to cancelled status
func (s *ImportSession) Cancel() error <span class="cov8" title="1">{
        if !s.CanTransitionTo(string(ImportStatusCancelled)) </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot cancel from status: %s", s.Status)
        }</span>
        <span class="cov8" title="1">s.Status = string(ImportStatusCancelled)
        now := time.Now()
        s.CompletedAt = &amp;now
        return nil</span>
}

// AddError adds an error to the error log
func (s *ImportSession) AddError(rowNumber int, errorType, errorMessage, rawData string) error <span class="cov8" title="1">{
        var errors []ImportError

        // Get existing errors
        if s.ErrorLog != nil </span><span class="cov8" title="1">{
                if err := json.Unmarshal([]byte(s.ErrorLog), &amp;errors); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to unmarshal existing errors: %w", err)
                }</span>
        }

        // Add new error
        <span class="cov8" title="1">newError := ImportError{
                RowNumber:    rowNumber,
                ErrorType:    errorType,
                ErrorMessage: errorMessage,
                RawData:      rawData,
        }
        errors = append(errors, newError)

        // Update error log
        jsonData, err := json.Marshal(errors)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal errors: %w", err)
        }</span>
        <span class="cov8" title="1">s.ErrorLog = datatypes.JSON(jsonData)
        return nil</span>
}

// GetErrors returns the list of import errors
func (s *ImportSession) GetErrors() ([]ImportError, error) <span class="cov8" title="1">{
        if s.ErrorLog == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">var errors []ImportError
        if err := json.Unmarshal([]byte(s.ErrorLog), &amp;errors); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to unmarshal errors: %w", err)
        }</span>

        <span class="cov8" title="1">return errors, nil</span>
}

// GetProgressPercentage returns the progress as a percentage
func (s *ImportSession) GetProgressPercentage() float64 <span class="cov8" title="1">{
        if s.TotalRows == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>
        <span class="cov8" title="1">return float64(s.ProcessedRows) / float64(s.TotalRows) * 100.0</span>
}

// GetSuccessRate returns the success rate as a percentage
func (s *ImportSession) GetSuccessRate() float64 <span class="cov8" title="1">{
        if s.ProcessedRows == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>
        <span class="cov8" title="1">return float64(s.SuccessRows) / float64(s.ProcessedRows) * 100.0</span>
}

// GetDuration returns the duration of the import session
func (s *ImportSession) GetDuration() time.Duration <span class="cov8" title="1">{
        if s.CompletedAt != nil </span><span class="cov8" title="1">{
                return s.CompletedAt.Sub(s.StartedAt)
        }</span>
        <span class="cov8" title="1">if s.IsInProgress() </span><span class="cov8" title="1">{
                return time.Since(s.StartedAt)
        }</span>
        <span class="cov8" title="1">return 0</span>
}

// UpdateProgress updates the progress counters
func (s *ImportSession) UpdateProgress(success, error, duplicate int) <span class="cov8" title="1">{
        s.SuccessRows += success
        s.ErrorRows += error
        s.DuplicateRows += duplicate
        s.ProcessedRows = s.SuccessRows + s.ErrorRows + s.DuplicateRows
}</pre>
		
		<pre class="file" id="file6" style="display: none">package models

import (
        "fmt"
        "regexp"
        "strings"
        "time"
)

// ValidationError represents a validation error with field information
type ValidationError struct {
        Field   string `json:"field"`
        Value   interface{} `json:"value,omitempty"`
        Message string `json:"message"`
        Code    string `json:"code"`
}

func (e ValidationError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("validation error on field '%s': %s", e.Field, e.Message)
}</span>

// ValidationResult holds the result of validation
type ValidationResult struct {
        Valid  bool               `json:"valid"`
        Errors []ValidationError  `json:"errors,omitempty"`
}

// AddError adds a validation error to the result
func (vr *ValidationResult) AddError(field, message, code string, value interface{}) <span class="cov8" title="1">{
        vr.Valid = false
        vr.Errors = append(vr.Errors, ValidationError{
                Field:   field,
                Value:   value,
                Message: message,
                Code:    code,
        })
}</span>

// ValidateETCMeisai performs comprehensive validation on ETC record
func ValidateETCMeisai(etc *ETCMeisai) *ValidationResult <span class="cov8" title="1">{
        result := &amp;ValidationResult{Valid: true}

        // Check for nil record
        if etc == nil </span><span class="cov8" title="1">{
                result.AddError("record", "Record cannot be nil", "REQUIRED", nil)
                return result
        }</span>

        // Required field validations
        <span class="cov8" title="1">if etc.UseDate.IsZero() </span><span class="cov8" title="1">{
                result.AddError("use_date", "UseDate is required", "REQUIRED", nil)
        }</span>

        <span class="cov8" title="1">if etc.Amount &lt;= 0 </span><span class="cov8" title="1">{
                result.AddError("amount", "Amount must be positive", "POSITIVE_REQUIRED", etc.Amount)
        }</span>

        <span class="cov8" title="1">if strings.TrimSpace(etc.EntryIC) == "" </span><span class="cov8" title="1">{
                result.AddError("entry_ic", "EntryIC is required", "REQUIRED", etc.EntryIC)
        }</span>

        <span class="cov8" title="1">if strings.TrimSpace(etc.ExitIC) == "" </span><span class="cov8" title="1">{
                result.AddError("exit_ic", "ExitIC is required", "REQUIRED", etc.ExitIC)
        }</span>

        // Date validations
        <span class="cov8" title="1">if !etc.UseDate.IsZero() </span><span class="cov8" title="1">{
                // Check if date is not in the future
                if etc.UseDate.After(time.Now()) </span><span class="cov0" title="0">{
                        result.AddError("use_date", "UseDate cannot be in the future", "FUTURE_DATE", etc.UseDate)
                }</span>

                // Check if date is not too old (older than 2 years)
                <span class="cov8" title="1">twoYearsAgo := time.Now().AddDate(-2, 0, 0)
                if etc.UseDate.Before(twoYearsAgo) </span><span class="cov0" title="0">{
                        result.AddError("use_date", "UseDate cannot be older than 2 years", "TOO_OLD", etc.UseDate)
                }</span>
        }

        // Time format validation
        <span class="cov8" title="1">if etc.UseTime != "" </span><span class="cov8" title="1">{
                if !isValidTimeFormat(etc.UseTime) </span><span class="cov8" title="1">{
                        result.AddError("use_time", "UseTime must be in HH:MM format", "INVALID_FORMAT", etc.UseTime)
                }</span>
        }

        // ETC Number validation
        <span class="cov8" title="1">if len(etc.ETCNumber) &gt; 20 </span><span class="cov0" title="0">{
                result.AddError("etc_number", "ETCNumber cannot exceed 20 characters", "MAX_LENGTH", etc.ETCNumber)
        }</span>

        <span class="cov8" title="1">if etc.ETCNumber != "" &amp;&amp; !isValidETCNumber(etc.ETCNumber) </span><span class="cov8" title="1">{
                result.AddError("etc_number", "ETCNumber contains invalid characters", "INVALID_FORMAT", etc.ETCNumber)
        }</span>

        // Car number validation
        <span class="cov8" title="1">if len(etc.CarNumber) &gt; 20 </span><span class="cov0" title="0">{
                result.AddError("car_number", "CarNumber cannot exceed 20 characters", "MAX_LENGTH", etc.CarNumber)
        }</span>

        // IC name validation
        <span class="cov8" title="1">if len(etc.EntryIC) &gt; 100 </span><span class="cov0" title="0">{
                result.AddError("entry_ic", "EntryIC cannot exceed 100 characters", "MAX_LENGTH", etc.EntryIC)
        }</span>

        <span class="cov8" title="1">if len(etc.ExitIC) &gt; 100 </span><span class="cov0" title="0">{
                result.AddError("exit_ic", "ExitIC cannot exceed 100 characters", "MAX_LENGTH", etc.ExitIC)
        }</span>

        // Amount range validation
        <span class="cov8" title="1">if etc.Amount &gt; 100000 </span><span class="cov8" title="1">{ // 10万円以上は異常値として扱う
                result.AddError("amount", "Amount seems unusually high", "SUSPICIOUS_VALUE", etc.Amount)
        }</span>

        <span class="cov8" title="1">return result</span>
}

// ValidateETCMeisaiMapping performs validation on mapping record
func ValidateETCMeisaiMapping(mapping *ETCMeisaiMapping) *ValidationResult <span class="cov8" title="1">{
        result := &amp;ValidationResult{Valid: true}

        // Required field validations
        if mapping.ETCMeisaiID &lt;= 0 </span><span class="cov8" title="1">{
                result.AddError("etc_meisai_id", "ETCMeisaiID must be positive", "POSITIVE_REQUIRED", mapping.ETCMeisaiID)
        }</span>

        <span class="cov8" title="1">if strings.TrimSpace(mapping.DTakoRowID) == "" </span><span class="cov0" title="0">{
                result.AddError("dtako_row_id", "DTakoRowID is required", "REQUIRED", mapping.DTakoRowID)
        }</span>

        // MappingType validation
        <span class="cov8" title="1">validMappingTypes := map[string]bool{"auto": true, "manual": true}
        if !validMappingTypes[mapping.MappingType] </span><span class="cov8" title="1">{
                result.AddError("mapping_type", "MappingType must be 'auto' or 'manual'", "INVALID_ENUM", mapping.MappingType)
        }</span>

        // Confidence validation
        <span class="cov8" title="1">if mapping.Confidence &lt; 0 || mapping.Confidence &gt; 1 </span><span class="cov0" title="0">{
                result.AddError("confidence", "Confidence must be between 0 and 1", "RANGE_ERROR", mapping.Confidence)
        }</span>

        // Notes length validation
        <span class="cov8" title="1">if len(mapping.Notes) &gt; 500 </span><span class="cov0" title="0">{
                result.AddError("notes", "Notes cannot exceed 500 characters", "MAX_LENGTH", mapping.Notes)
        }</span>

        // DTako Row ID format validation
        <span class="cov8" title="1">if mapping.DTakoRowID != "" &amp;&amp; !isValidDTakoRowID(mapping.DTakoRowID) </span><span class="cov0" title="0">{
                result.AddError("dtako_row_id", "DTakoRowID has invalid format", "INVALID_FORMAT", mapping.DTakoRowID)
        }</span>

        <span class="cov8" title="1">return result</span>
}

// ValidateETCImportBatch performs validation on import batch
func ValidateETCImportBatch(batch *ETCImportBatch) *ValidationResult <span class="cov8" title="1">{
        result := &amp;ValidationResult{Valid: true}

        // Check for nil batch
        if batch == nil </span><span class="cov8" title="1">{
                result.AddError("batch", "Batch cannot be nil", "REQUIRED", nil)
                return result
        }</span>

        // Required field validations
        <span class="cov8" title="1">if strings.TrimSpace(batch.FileName) == "" </span><span class="cov8" title="1">{
                result.AddError("file_name", "FileName is required", "REQUIRED", batch.FileName)
        }</span>

        <span class="cov8" title="1">if batch.TotalRecords &lt; 0 </span><span class="cov8" title="1">{
                result.AddError("total_records", "TotalRecords cannot be negative", "NON_NEGATIVE", batch.TotalRecords)
        }</span>

        // Status validation
        <span class="cov8" title="1">validStatuses := map[string]bool{
                "pending":    true,
                "processing": true,
                "completed":  true,
                "failed":     true,
                "cancelled":  true,
        }
        if !validStatuses[batch.Status] </span><span class="cov0" title="0">{
                result.AddError("status", "Invalid status value", "INVALID_ENUM", batch.Status)
        }</span>

        // File name validation
        <span class="cov8" title="1">if len(batch.FileName) &gt; 255 </span><span class="cov0" title="0">{
                result.AddError("file_name", "FileName cannot exceed 255 characters", "MAX_LENGTH", batch.FileName)
        }</span>

        // Count consistency validation
        <span class="cov8" title="1">if batch.ProcessedCount &gt; batch.TotalRecords </span><span class="cov8" title="1">{
                result.AddError("processed_count", "ProcessedCount cannot exceed TotalRecords", "LOGICAL_ERROR", batch.ProcessedCount)
        }</span>

        <span class="cov8" title="1">if batch.CreatedCount &gt; batch.ProcessedCount </span><span class="cov0" title="0">{
                result.AddError("created_count", "CreatedCount cannot exceed ProcessedCount", "LOGICAL_ERROR", batch.CreatedCount)
        }</span>

        // Time validation
        <span class="cov8" title="1">if batch.StartTime != nil &amp;&amp; batch.CompleteTime != nil </span><span class="cov0" title="0">{
                if batch.CompleteTime.Before(*batch.StartTime) </span><span class="cov0" title="0">{
                        result.AddError("complete_time", "CompleteTime cannot be before StartTime", "LOGICAL_ERROR", batch.CompleteTime)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// Helper functions for validation

// isValidTimeFormat checks if time string is in HH:MM format
func isValidTimeFormat(timeStr string) bool <span class="cov8" title="1">{
        matched, _ := regexp.MatchString(`^([01]?[0-9]|2[0-3]):[0-5][0-9]$`, timeStr)
        return matched
}</span>

// isValidETCNumber checks if ETC number has valid format (digits only)
func isValidETCNumber(etcNumber string) bool <span class="cov8" title="1">{
        matched, _ := regexp.MatchString(`^[0-9]+$`, etcNumber)
        return matched
}</span>

// isValidDTakoRowID checks if DTako row ID has valid format
func isValidDTakoRowID(rowID string) bool <span class="cov8" title="1">{
        // DTako row IDs are typically alphanumeric with possible hyphens
        matched, _ := regexp.MatchString(`^[A-Za-z0-9\-_]+$`, rowID)
        return matched &amp;&amp; len(rowID) &lt;= 50
}</span>

// BatchValidationOptions contains options for batch validation
type BatchValidationOptions struct {
        StrictMode    bool `json:"strict_mode"`     // Fail on any warning
        SkipDuplicates bool `json:"skip_duplicates"` // Skip duplicate hash validation
        MaxErrors     int  `json:"max_errors"`      // Stop after N errors
}

// ValidateETCMeisaiBatch validates a batch of ETC records
func ValidateETCMeisaiBatch(records []*ETCMeisai, options *BatchValidationOptions) map[int]*ValidationResult <span class="cov8" title="1">{
        if options == nil </span><span class="cov0" title="0">{
                options = &amp;BatchValidationOptions{
                        StrictMode:    false,
                        SkipDuplicates: false,
                        MaxErrors:     100,
                }
        }</span>

        <span class="cov8" title="1">results := make(map[int]*ValidationResult)
        hashMap := make(map[string]int) // Track hashes for duplicate detection
        errorCount := 0

        for i, record := range records </span><span class="cov8" title="1">{
                if options.MaxErrors &gt; 0 &amp;&amp; errorCount &gt;= options.MaxErrors </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">result := ValidateETCMeisai(record)

                // Check for duplicate hashes within the batch
                if !options.SkipDuplicates &amp;&amp; record.Hash != "" </span><span class="cov8" title="1">{
                        if existingIndex, exists := hashMap[record.Hash]; exists </span><span class="cov0" title="0">{
                                result.AddError("hash", fmt.Sprintf("Duplicate hash found with record at index %d", existingIndex), "DUPLICATE_HASH", record.Hash)
                        }</span> else<span class="cov8" title="1"> {
                                hashMap[record.Hash] = i
                        }</span>
                }

                <span class="cov8" title="1">if !result.Valid </span><span class="cov8" title="1">{
                        errorCount++
                }</span>

                <span class="cov8" title="1">results[i] = result</span>
        }

        <span class="cov8" title="1">return results</span>
}

// ValidationSummary provides a summary of validation results
type ValidationSummary struct {
        TotalRecords   int                     `json:"total_records"`
        ValidRecords   int                     `json:"valid_records"`
        InvalidRecords int                     `json:"invalid_records"`
        ErrorsByField  map[string]int          `json:"errors_by_field"`
        ErrorsByCode   map[string]int          `json:"errors_by_code"`
        FirstErrors    []ValidationError       `json:"first_errors,omitempty"` // First few errors for quick review
}

// SummarizeValidation creates a summary from validation results
func SummarizeValidation(results map[int]*ValidationResult, maxFirstErrors int) *ValidationSummary <span class="cov8" title="1">{
        summary := &amp;ValidationSummary{
                TotalRecords:   len(results),
                ValidRecords:   0,
                InvalidRecords: 0,
                ErrorsByField:  make(map[string]int),
                ErrorsByCode:   make(map[string]int),
                FirstErrors:    make([]ValidationError, 0, maxFirstErrors),
        }

        for _, result := range results </span><span class="cov8" title="1">{
                if result.Valid </span><span class="cov8" title="1">{
                        summary.ValidRecords++
                }</span> else<span class="cov8" title="1"> {
                        summary.InvalidRecords++

                        for _, err := range result.Errors </span><span class="cov8" title="1">{
                                summary.ErrorsByField[err.Field]++
                                summary.ErrorsByCode[err.Code]++

                                if len(summary.FirstErrors) &lt; maxFirstErrors </span><span class="cov8" title="1">{
                                        summary.FirstErrors = append(summary.FirstErrors, err)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return summary</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
